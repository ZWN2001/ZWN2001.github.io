<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>FLutter性能优化 | ZWN's blog</title><meta name="keywords" content="flutter"><meta name="author" content="洛雪"><meta name="copyright" content="洛雪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="FLutter性能优化 准备 以 profile 模式启动应用，如果是混合 Flutter 应用，在 Flutter SDK的flutter&#x2F;packages&#x2F;flutter_tools&#x2F;gradle&#x2F;flutter.gradle 的 buildModeFor 方法中将 debug 模式改为 profile即可。  当然，如非必要，不太建议使用第二种方式  位置如图： Run &gt; Flutt">
<meta property="og:type" content="article">
<meta property="og:title" content="FLutter性能优化">
<meta property="og:url" content="https://zwn2001.github.io/2022/09/19/FLutter%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/index.html">
<meta property="og:site_name" content="ZWN&#39;s blog">
<meta property="og:description" content="FLutter性能优化 准备 以 profile 模式启动应用，如果是混合 Flutter 应用，在 Flutter SDK的flutter&#x2F;packages&#x2F;flutter_tools&#x2F;gradle&#x2F;flutter.gradle 的 buildModeFor 方法中将 debug 模式改为 profile即可。  当然，如非必要，不太建议使用第二种方式  位置如图： Run &gt; Flutt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zwn2001.github.io/img/cover3/21-min.jpg">
<meta property="article:published_time" content="2022-09-19T01:13:39.000Z">
<meta property="article:modified_time" content="2023-05-12T14:14:03.568Z">
<meta property="article:author" content="洛雪">
<meta property="article:tag" content="flutter">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zwn2001.github.io/img/cover3/21-min.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zwn2001.github.io/2022/09/19/FLutter%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"It has been","messageNext":"days since the last update, the content of the article may be outdated."},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'FLutter性能优化',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-12 22:14:03'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transpancy.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">117</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover3/21-min.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZWN's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">FLutter性能优化</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-19T01:13:39.000Z" title="发表于 2022-09-19 09:13:39">2022-09-19</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-12T14:14:03.568Z" title="更新于 2023-05-12 22:14:03">2023-05-12</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86/">编程知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>25分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>FLutter性能优化</h1>
<h2 id="准备">准备</h2>
<p>以 profile 模式启动应用，如果是混合 Flutter 应用，在 Flutter SDK的<code>flutter/packages/flutter_tools/gradle/flutter.gradle</code> 的 buildModeFor 方法中将 debug 模式改为 profile即可。</p>
<blockquote>
<p>当然，如非必要，不太建议使用第二种方式</p>
</blockquote>
<p>位置如图：</p>
<p><strong>Run &gt; Flutter Run main.dart in Profile Mode</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="FLutter性能优化/1.png" style="zoom:30%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="FLutter性能优化/2.png" style="zoom:30%;" />
<p>与调试代码可以在调试模式下检测 Bug 不同，性能问题需要在发布模式下使用真机进行检测。这是因为，相比发布模式而言，<strong>调试模式增加了很多额外的检查（比如断言），这些检查可能会耗费很多资源，而更重要的是，调试模式使用 JIT 模式运行应用，代码执行效率较低。这就使得调试模式运行的应用，无法真实反映出它的性能问题</strong>。</p>
<p>而另一方面，<strong>模拟器使用的指令集为 x86，而真机使用的指令集是 ARM</strong>。这两种方式的二进制代码执行行为完全不同，因此，模拟器与真机的性能差异较大，例如，针对一些 x86 指令集擅长的操作，模拟器会比真机快，而另一些操作则会比真机慢。这也同时意味着，你无法使用模拟器来评估真机才能出现的性能问题。</p>
<p> </p>
<h3 id="Flutter-Inspector">Flutter Inspector</h3>
<h4 id="Repaint-Rainbow">Repaint Rainbow</h4>
<p>点击 “Repaint Rainbow” 图标，它会 <strong>为所有 RenderBox 绘制一层外框，并在它们重绘时会改变颜色</strong>。</p>
<h4 id="作用">作用</h4>
<p><strong>帮你找到 App 中频繁重绘导致性能消耗过大的部分</strong>。</p>
<p>例如：一个小动画可能会导致整个页面重绘，这个时候使用 RepaintBoundary Widget 包裹它，可以将重绘范围缩小至本身所占用的区域，这样就可以减少绘制消耗。</p>
<h4 id="使用场景">使用场景</h4>
<p>例如 <strong>页面的进度条动画刷新时会导致整个布局频繁重绘</strong>。</p>
<h4 id="缺点">缺点</h4>
<p>使用 RepaintBoundary Widget 会创建额外的绘制画布，这将会增加一定的内存消耗。</p>
<p> </p>
<h3 id="使用性能视图-Performance-view">使用性能视图 (Performance view)</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="FLutter性能优化/4.png" style="zoom:30%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="FLutter性能优化/5.png" alt = "一些可能的关注点" style="zoom:30%;" />
<h4 id="帧事件图：">帧事件图：</h4>
<p>UI 线程执行 Dart VM 中的 Dart 代码。它包括你的应用程序和 Flutter 框架的所有代码。当你创建或打开一个页面， UI 线程会创建一个图层树和一个轻量级的与设备无关的绘制指令集，并把图层树交给设备的 raster（栅格）线程进行渲染</p>
<p>栅格化线程（也就是我们之前知道的 GPU 线程）执行 Flutter 引擎中图形相关的代码。这个线程通过与 GPU (图形处理单元) 通信，获取图形树并显示它。你不能直接访问 Raster 线程或它的数据，但如果这个线程较慢，那它肯定是由你的 Dart 代码引起的。图形化库 Skia 运行在这个线程上，有时候也称它为光栅线程。</p>
<p>有时候一个页面的图形层树比较容易构建但 raster 线程的渲染却比较昂贵。在这种情形下，你需要找出导致渲染变慢的代码。为 GPU 设定特定多种类型的 workload 是相当困难的。在一些特定的情形下，多个对象的透明度重叠、剪切或阴影，有可能会导致不必要的 <code>saveLayer()</code> 的调用。</p>
<p>卡顿 (Jank)：帧渲染图表使用红色图层显示帧延时。如果一帧的渲染时间超过 16ms，则会被认为此帧是延时的，为了达到帧渲染频率到 60 FPS (每秒帧数)，每一帧的渲染时间必须等于或少于 16 ms。如果没有达到这个目标，你会发现 UI 不流畅或丢帧。</p>
<p>着色器渲染：在 Flutter 应用中，着色器会在初次使用时发生渲染。参与了着色器编译的构建帧已标记为深红色。</p>
<h4 id="时间线事件图：">时间线事件图：</h4>
<p>时间线事件图显示了应用程序中的所有事件跟踪。Flutter 框架在构建框架、绘制场景和跟踪 HTTP 流量等其他活动时发出时间线事件。这些事件会在时间轴上显示出来。还可以通过 dart: developerTimeline 和 TimelineTaskAPI 发送自己的 Timeline 事件。</p>
<h4 id="Enhance-Tracing">Enhance Tracing</h4>
<blockquote>
<p>启用该选项后，帧构建时间可能会受到影响。</p>
</blockquote>
<p> </p>
<h2 id="性能指标">性能指标</h2>
<p>摘自https://flutter.cn/docs/perf/metrics</p>
<ul>
<li>第一帧的启动时间
<ul>
<li>当 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://api.flutter-io.cn/flutter/widgets/WidgetsBinding/firstFrameRasterized.html">WidgetsBinding.instance.firstFrameRasterized</a> 为 true 时查看耗时。</li>
<li>查看 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://flutter-flutter-perf.skia.org/e/?queries=sub_result%3DtimeToFirstFrameRasterizedMicros">性能数据看板</a>。</li>
</ul>
</li>
<li>一帧的构建时间，栅格化时间，以及总时间
<ul>
<li>在 API 文档中查看 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://api.flutter-io.cn/flutter/dart-ui/FrameTiming-class.html."><code>FrameTiming</code></a> 。</li>
</ul>
</li>
<li>一帧的构建时间 <code>buildDuration</code> (<code>*_frame_build_time_millis</code>)
<ul>
<li>我们建议监测四个数据：平均值、90 分位值、99 分位值和最差帧构建时间。</li>
<li>例如，查看 <code>flutter_gallery__transition_perf</code> 测试案例中的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://flutter-flutter-perf.skia.org/e/?queries=sub_result%3D90th_percentile_frame_build_time_millis%26sub_result%3D99th_percentile_frame_build_time_millis%26sub_result%3Daverage_frame_build_time_millis%26sub_result%3Dworst_frame_build_time_millis%26test%3Dflutter_gallery__transition_perf">构建数据</a> 。</li>
</ul>
</li>
<li>一帧的栅格化时间 <code>rasterDuration</code> (<code>*_frame_build_time_millis</code>)
<ul>
<li>我们建议监测四个数据：平均值、90 分位值、99 分位值和最差帧构建时间。</li>
<li>例如，查看 <code>flutter_gallery__transition_perf</code> 测试案例中的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://flutter-flutter-perf.skia.org/e/?queries=sub_result%3D90th_percentile_frame_build_time_millis%26sub_result%3D99th_percentile_frame_build_time_millis%26sub_result%3Daverage_frame_build_time_millis%26sub_result%3Dworst_frame_build_time_millis%26test%3Dflutter_gallery__transition_perf">栅格化数据</a> 。</li>
</ul>
</li>
<li>CPU/GPU 的使用情况（一个可以近似衡量功耗的指标）
<ul>
<li>该数据目前仅能通过跟踪事件获取。查看 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/flutter/flutter/blob/master/packages/flutter_driver/lib/src/driver/profiling_summarizer.dart">profiling_summarizer.dart</a> 。</li>
<li>查看 <code>simple_animation_perf_ios</code> 测试案例中的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://flutter-flutter-perf.skia.org/e/?queries=sub_result%3Daverage_cpu_usage%26sub_result%3Daverage_gpu_usage%26test%3Dsimple_animation_perf_ios">CPU/GPU 数据</a>。</li>
</ul>
</li>
<li>release_size_bytes 对 Flutter 应用程序的大小进行估算
<ul>
<li>查看 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/flutter/flutter/blob/master/dev/devicelab/bin/tasks/basic_material_app_android__compile.dart">basic_material_app_android</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/flutter/flutter/blob/master/dev/devicelab/bin/tasks/basic_material_app_ios__compile.dart">basic_material_app_ios</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/flutter/flutter/blob/master/dev/devicelab/bin/tasks/hello_world_android__compile.dart">hello_world_android</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/flutter/flutter/blob/master/dev/devicelab/bin/tasks/hello_world_ios__compile.dart">hello_world_ios</a>、<a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/flutter/flutter/blob/master/dev/devicelab/bin/tasks/flutter_gallery_android__compile.dart">flutter_gallery_android</a> 和 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/flutter/flutter/blob/master/dev/devicelab/bin/tasks/flutter_gallery_ios__compile.dart">flutter_gallery_ios</a> 测试案例。</li>
<li>查看数据看板中的 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://flutter-flutter-perf.skia.org/e/?queries=sub_result%3Drelease_size_bytes%26test%3Dbasic_material_app_android__compile%26test%3Dbasic_material_app_ios__compile%26test%3Dhello_world_android__compile%26test%3Dhello_world_ios__compile%26test%3Dflutter_gallery_ios__compile%26test%3Dflutter_gallery_android__compile">体积大小</a> 数据。</li>
<li>有关如何更精确的测量应用体积信息，查看 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://flutter.cn/docs/perf/app-size">应用体积</a> 页面。</li>
</ul>
</li>
</ul>
<p> </p>
<h2 id="布局加载优化">布局加载优化</h2>
<blockquote>
<p>Flutter 为什么要使用声明书 UI 的编写方式？</p>
</blockquote>
<p>为了减轻开发人员的负担，无需编写如何在不同的 UI 状态之间进行切换的代码，Flutter 使用了声明式的 UI 编写方式，而不是 Android 和 iOS 中的命令式编写方式。</p>
<p>这样的话，<strong>当用户界面发生变化时，Flutter  不会修改旧的 Widget 实例，而是会构造新的 Widget 实例</strong>。</p>
<p>Fluuter 框架使用 RenderObjects 管理传统 UI 对象的职责（比如维护布局的状态）。 RenderObjects 在帧之间保持不变， Flutter 的轻量级 Widget 通知框架在状态之间修改 RenderObjects， 而 Flutter Framework 则负责处理其余部分。</p>
<h3 id="常规优化">常规优化</h3>
<p>常规优化即针对 build() 进行优化，build() 方法中的性能问题一般有两种：<strong>耗时操作和 Widget 堆叠</strong>。</p>
<h4 id="在-build-方法中执行了耗时操作">在 build() 方法中执行了耗时操作</h4>
<p>我们应该尽量避免在 build() 中执行耗时操作，因为 build() 会被频繁地调用，尤其是当 Widget 重建的时候。</p>
<p>此外，我们不要在代码中进行阻塞式操作，可以将文件读取、数据库操作、网络请求等通过 Future 来转换成异步方式来完成。</p>
<p>最后，对于 CPU 计算频繁的操作，例如图片压缩，可以使用 isolate 来充分利用多核心 CPU。</p>
<p><strong>isolate 作为 Flutter 中的多线程实现方式，之所以被称之为 isolate（隔离），是因为每一个 isolate 都有一份单独的内存</strong>。</p>
<p><strong>Flutter 会运行一个事件循环，它会从事件队列中取得最旧的事件，处理它，然后再返回下一个事件进行处理，依此类推，直到事件队列清空为止。每当动作中断时，线程就会等待下一个事件</strong>。</p>
<p>实质上，不仅仅是 isolate，所有的高级 API 都能够应用于异步编程，例如 Futures、Streams、async 和 await，它们全部都是构建在这个简单的事件循环之上。</p>
<p>而，<strong>async 和 await 实际上只是使用 futures 和 streams 的替代语法</strong>，它将代码编写形式从异步变为同步，主要用来帮助你编写更清晰、简洁的代码。</p>
<p>此外，async 和 await 也能使用 try on catch finally 来进行异常处理，这能够帮助你处理一些数据解析方面的异常。</p>
<h4 id="使用-Widget-而不是函数">使用 Widget 而不是函数</h4>
<p>如果一个函数可以做同样的事情，Flutter 就不会有 StatelessWidget ，使用 StatelessWidget 的最大好处在于：能尽量避免不必要的重建。总的来说，它的优势有：</p>
<ul>
<li>1）、允许性能优化：const 构造函数，更细粒度的重建等等。</li>
<li>2）、确保在两个不同的布局之间切换时，能够正确地处理资源（因为函数可能重用某些先前的状态）。</li>
<li>3）、确保热重载正常工作，使用函数可能会破坏热重载。</li>
<li>4）、在 flutter 自带的 Widget 显示工具中能看到 Widget 的状态和参数。</li>
<li>5）、发生错误时，有更清晰的提示：此时，Flutter 框架将为你提供当前构建的 Widget 名称，更容易排查问题。</li>
<li>6）、可以定义 key 和方便使用 context 的 API。</li>
</ul>
<h4 id="使用-nil-去替代-Container-和-SizedBox">使用 nil 去替代 Container() 和 SizedBox()</h4>
<p>首先，你需要明白 <strong>nil 仅仅是一个基础的 Widget 元素 ，它的构建成本几乎没有。</strong></p>
<p>在某些情况下，如果你不想显示任何内容，且不能返回 null 的时候，你可能会返回类似 const SizedBox/Container 的 Widget，但是 SizedBox 会创建 RenderObject，而渲染树中的 RenderObject 会带来多余的生命周期控制和额外的计算消耗，即便你没有给 SizedBox 指定任何的参数。</p>
<p>下面，是我平时使用 nil 的一套方式：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// BEST</span></span><br><span class="line">text != <span class="keyword">null</span> ? Text(text) : nil</span><br><span class="line">or</span><br><span class="line"><span class="keyword">if</span> (text != <span class="keyword">null</span>) Text(text)</span><br><span class="line">text != <span class="keyword">null</span> ? Text(text) : <span class="keyword">const</span> Container()/SizedBox()</span><br></pre></td></tr></table></figure>
<h3 id="列表优化">列表优化</h3>
<p>在构建大型网格或列表的时候，我们要尽量避免使用 <code>ListView(children: [],)</code> 或 <code>GridView(children: [],)</code>，因为，在这种场景下，不管列表内容是否可见，会导致列表中所有的数据都会被一次性绘制出来，这种用法类似于 Android 的 ScrollView。</p>
<p>如果我们列表数据比较大的时候，建议使用 ListView 和 GridView 的 builder 方法，它们只会绘制可见的列表内容，类似于 Android 的 RecyclerView。</p>
<p>其实，本质上，<strong>就是对列表采用了懒加载而不是直接一次性创建所有的子 Widget，这样视图的初始化时间就减少了</strong>。</p>
<h4 id="针对于长列表，记得在-ListView-中使用-itemExtent。">针对于长列表，记得在 ListView 中使用 itemExtent。</h4>
<p>有时候当我们有一个很长的列表，想要用滚动条来大跳时，使用 itemExtent 就很重要了，<strong>它会帮助 Flutter 去计算 ListView 的滚动位置而不是计算每一个 Widget 的高度，与此同时，它能够使滚动动画有更好的性能</strong>。</p>
<h4 id="减少可折叠-ListView-的构建时间">减少可折叠 ListView 的构建时间</h4>
<p><strong>针对于可折叠的 ListView，未展开状态时，设置其 itemCount 为 0，这样 item 只会在展开状态下才进行构建，以减少页面第一次的打开构建时间</strong>。</p>
<p> </p>
<h3 id="深入优化">深入优化</h3>
<h4 id="优化光栅线程">优化光栅线程</h4>
<p>所有的 Flutter 应用至少都会运行在两个并行的线程上：<strong>UI 线程和 Raster 线程</strong>。</p>
<p>**UI 线程是你构建 Widgets 和运行应用逻辑的地方。 ** <strong>Raster 线程是 Flutter 用来栅格化你的应用的。它从 UI 线程获取指令并将它们转换为可以发送到图形卡的内容。</strong></p>
<p><strong>在光栅线程中，会获取图片的字节，调整图像的大小，应用透明度、混合模式、模糊等等，直到产生最后的图形像素。然后，光栅线程会将其发送到图形卡，继而发送到屏幕上显示。</strong></p>
<p>使用 Flutter DevTools-Performance 进行检测，步骤如下：</p>
<ul>
<li>1、在 Performance Overlay 中，查看光栅线程和 UI 线程哪个负载过重。</li>
<li>2、在 Timeline Events 中，找到那些耗费时间最长的事件，例如常见的 SkCanvas::Flush，它负责解决所有待处理的 GPU 操作。</li>
<li>3、找到对应的代码区域，通过删除 Widgets 或方法的方式来看对性能的影响。</li>
</ul>
<h4 id="用-key-加速-Flutter-的性能优化光栅线程">用 key 加速 Flutter 的性能优化光栅线程</h4>
<p>一个 element 是由 Widget 内部创建的，它的主要目的是，<strong>知道对应的 Widget 在 Widget 树中所处的位置。但是元素的创建是非常昂贵的，通过 Keys（ValueKeys 和 GlobalKeys），我们可以去重复使用它们。</strong></p>
<blockquote>
<p>GlobalKey 与 ValueKey 的区别？</p>
</blockquote>
<p><strong>GlobalKey 是全局使用的 key，在跨小部件的场景时，你就可以使用它去刷新其它小部件。但，它是很昂贵的，如果你不需要访问 BuildContext、Element 和 State，应该尽量使用 LocalKey。</strong></p>
<p>而 ValueKey 和 ObjectKey、UniqueKey 一样都归属于局部使用的 LocalKey，无法跨容器使用，ValueKey 比较的是 Widget 的值，而 ObjectKey 比较的是对象的 key，UniqueKey 则每次都会生成一个不同的值。</p>
<h5 id="元素的生命周期">元素的生命周期</h5>
<ul>
<li><strong>Mount</strong>：挂载，当元素第一次被添加到树上的时候调用。</li>
<li><strong>Active</strong>：当需要激活之前失活的元素时被调用。</li>
<li><strong>Update</strong>：用新数据去更新 RenderObject。</li>
<li><strong>Deactive</strong>：当元素从 Widget 树中被移除或移动时被调用。如果一个元素在同一帧期间被移动了且它有 GlobalKey，那么它仍然能够被激活。</li>
<li><strong>UnMount</strong>：卸载，如果一个元素在一帧期间没有被激活，它将会被卸载，并且再也不会被复用。</li>
</ul>
<h5 id="优化方式">优化方式</h5>
<p>**为了去改善性能，你需要去尽可能让 Widget 使用 Activie 和 Update 操作，并且尽量避免让 Widget触发 UnMount 和 Mount。**而使用 GlobayKeys 和 ValueKey 则能做到这一点：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// <span class="language-markdown">1、给 MaterialApp 指定 GlobalKeys</span></span></span><br><span class="line">MaterialApp(key: global, home: child,);</span><br><span class="line"><span class="comment">/// <span class="language-markdown">2、通过把 ValueKey 分配到正在被卸载的根 Widget，你就能够</span></span></span><br><span class="line"><span class="comment">/// <span class="language-markdown">减少 Widget 的平均构建时间。</span></span></span><br><span class="line">Widget build(BuildContext context) &#123;</span><br><span class="line">  <span class="keyword">return</span> Column(</span><br><span class="line">    children: [</span><br><span class="line">      value</span><br><span class="line">          ? <span class="keyword">const</span> SizedBox(key: ValueKey(<span class="string">&#x27;SizedBox&#x27;</span>))</span><br><span class="line">          : <span class="keyword">const</span> Placeholder(key: ValueKey(<span class="string">&#x27;Placeholder&#x27;</span>)),</span><br><span class="line">      GestureDetector(</span><br><span class="line">        key: ValueKey(<span class="string">&#x27;GestureDetector&#x27;</span>),</span><br><span class="line">        onTap: () &#123;</span><br><span class="line">          setState(() &#123;</span><br><span class="line">            value = !value;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Container(</span><br><span class="line">          width: <span class="number">100</span>,</span><br><span class="line">          height: <span class="number">100</span>,</span><br><span class="line">          color: Colors.red,</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">      !value</span><br><span class="line">          ? <span class="keyword">const</span> SizedBox(key: ValueKey(<span class="string">&#x27;SizedBox&#x27;</span>))</span><br><span class="line">          : <span class="keyword">const</span> Placeholder(key: ValueKey(<span class="string">&#x27;Placeholder&#x27;</span>)),</span><br><span class="line">    ],</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如何知道哪些 Widget 会被 Update，哪些 Widget会被 UnMount？</p>
</blockquote>
<p>只有 build 直接 return 的那个根 Widget 会自动更新，其它都有可能被 UnMount，因此都需要给其分配 ValueKey。</p>
<blockquote>
<p>为什么没有给 Container 分配 ValueKey？</p>
</blockquote>
<p>因为 Container 是 GestureDetector 的一个子 Widget，所以当给 GestureDetector 使用 ValueKey 去实现复用更新时，Container 也能被自动更新。</p>
<h5 id="优势">优势</h5>
<p>大幅度减少 Widget的平均构建时间。</p>
<h5 id="缺点-2">缺点</h5>
<ul>
<li><strong>过多使用 ValueKey 会让你的代码变得更冗余。</strong></li>
<li><strong>如果你的根 Widget 是 MaterialApp 时，则需要使用 GlobalKey，但当你去重复使用 GlobalKey 时可能会导致一些错误，所以一定要避免滥用 Key。</strong></li>
</ul>
<p>注意📢：在大部分场景下，Flutter 的性能都是足够的，不需要这么细致的优化，只有当产生了视觉上的问题，例如卡顿时才需要去分析优化。</p>
<p> </p>
<h2 id="预编译Shader">预编译Shader</h2>
<p>If the animations on your mobile app appear to be janky, but only on the first run, you can warm up the shader captured in the Skia Shader Language (SkSL) for a significant improvement.</p>
<p>如果你的手机 App上的动画看起来很卡顿，但只是在第一次运行时，你可以预热在 Skia shaders语言 (SkSL) 中捕获的shaders，以此获得显着的改进。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cfanz.cdn.bcebos.com/uploads/gif/2022/01/20/1/aeWa8NV443.gif" alt=""></p>
<h3 id="What-is-shader-compilation-jank-什么是shaders编译卡顿？">What is shader compilation jank? -什么是shaders编译卡顿？</h3>
<p>If an app has janky animations during the first run, and later becomes smooth for the same animation, then it’s very likely due to shader compilation jank.</p>
<p>如果一个App在第一次运行时出现了animation卡顿，后来相同的animation却变得流畅，那么很可能是shaders编译 导致的卡顿。</p>
<p>More technically, a shader is a piece of code that runs on a GPU (graphics processing unit). When a shader is first used, it needs to be compiled on the device. The compilation could cost up to a few hundred milliseconds whereas a smooth frame needs to be drawn within 16 milliseconds for a 60 fps (frame-per-second) display.</p>
<p>从技术上讲，shaders是在 GPU（图形处理单元）上运行的一段代码。 首次使用shaders时，需要在设备上对其进行编译。 编译可能会花费数百毫秒，而流畅的显示帧需要在 16 毫秒内绘制，才能实现 60 fps（每秒帧数）的显示。</p>
<p>Therefore, a compilation could cause tens of frames to be missed, and drop the fps from 60 to 6. This is compilation jank. After the compilation is complete, the animation should be smooth.</p>
<p>因此，一次编译可能会导致数十帧丢失，并将 fps 从 60 降至 6。这就是编译卡顿。 在编译完成后，animation应该是流畅运行的。</p>
<p>Definitive evidence for the presence of shader compilation jank is to see GrGLProgramBuilder::finalize in the tracing with --trace-skia enabled. See the following screenshot for an example timeline tracing.</p>
<p>存在shaders编译卡顿的明确现象是在启用了 --trace-skia 的跟踪中看到 GrGLProgramBuilder::finalize。 有关时间线跟踪的示例，请参见下面的屏幕截图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://cfanz.cdn.bcebos.com/uploads/png/2022/01/20/1/Q39H4HbcKG.png" alt=""></p>
<h3 id="What-do-we-mean-by-“first-run”-我们所说的“第一次运行”是什么意思？">What do we mean by “first run”? - 我们所说的“第一次运行”是什么意思？</h3>
<p>On Android, “first run” means that the user might see jank the first time opening the app after a fresh installation. Subsequent runs should be fine.</p>
<p>在 Android 上，“首次运行”意味着用户在全新安装后第一次打开App时可能会看到卡顿。 后续运行就没问题。</p>
<p>On iOS, “first run” means that the user might see jank when an animation first occurs every time the user opens the app from scratch.</p>
<p>在 iOS 上，“首次运行”意味着用户可能会在每次用户从头开始打开App时第一次出现动画时看到卡顿。</p>
<h3 id="How-to-use-SkSL-warmup-如何使用-SkSL-热身">How to use SkSL warmup - 如何使用 SkSL 热身</h3>
<p>As of release 1.20, Flutter provides command line tools for app developers to collect shaders that might be needed for end-users in the SkSL (Skia Shader Language) format. The SkSL shaders can then be packaged into the app, and get warmed up (pre-compiled) when an end-user first opens the app, thereby reducing the compilation jank in later animations. Use the following instructions to collect and package the SkSL shaders:</p>
<p>从 1.20 版开始，Flutter 为App开发人员提供命令行工具，以收集最终用户可能需要的 SkSL（Skia shaders语言）格式的shaders。SkSL shaders可以打包到App中，并在最终用户首次打开App时进行预热（预编译），从而减少后续animation的编译卡顿。 使用以下指令收集和打包 SkSL shaders：</p>
<p>1.Run the app with --cache-sksl turned on to capture shaders in SkSL:</p>
<p>1.运行App带上 --cache-sksl 参数，以便在 SkSL 中捕获shaders：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run --profile --cache-sksl</span><br></pre></td></tr></table></figure>
<p>If the same app has been previously run without --cache-sksl, then the --purge-persistent-cache flag may be needed:</p>
<p>如果之前在没有 --cache-sksl 的情况下运行相同的App，则可能需要 --purge-persistent-cache 标志：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter run --profile --cache-sksl --purge-persistent-cache</span><br></pre></td></tr></table></figure>
<p>This flag removes older non-SkSL shader caches that could interfere with SkSL shader capturing. It also purges the SkSL shaders so use it only on the first --cache-sksl run.</p>
<p>此标志会消除 ”较旧的非 SkSL shaders缓存“ 对 ”SkSL shaders捕获“的干扰。 它还会清除 SkSL shaders，所以只在第一次运行 --cache-sksl 时使用它。</p>
<p>2.Play with the app to trigger as many animations as needed; particularly those with compilation jank.</p>
<p>2.运行App以根据需要触发尽可能多的animation； 特别是那些有编译卡顿的。</p>
<p>3.Press M at the command line of flutter run to write the captured SkSL shaders into a file named something like flutter_01.sksl.json. For best results, capture SkSL shaders on actual Android and iOS devices separately.</p>
<p>3.在 flutter run 的命令行按 M （<strong>我的是Alt+M</strong>）将捕获的 SkSL shaders写入名为 flutter_01.sksl.json 的文件中。 为了获取到最佳效果，请分别在真实的 Android 和 iOS 手机上捕获 SkSL shaders。</p>
<p>Build the app with SkSL warm-up using the following, as appropriate:</p>
<p>适当的通过以下方法 让 编译的 App带上 ”SkSL 预热“：</p>
<p>Android:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build apk --bundle-sksl-path flutter_01.sksl.json</span><br></pre></td></tr></table></figure>
<p>or 或者</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build appbundle --bundle-sksl-path flutter_01.sksl.json</span><br></pre></td></tr></table></figure>
<p>iOS:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter build ios --bundle-sksl-path flutter_01.sksl.json</span><br></pre></td></tr></table></figure>
<p>If it’s built for a driver test like test_driver/app.dart, make sure to also specify --target=test_driver/app.dart (e.g., flutter build ios --bundle-sksl-path flutter_01.sksl.json --target=test_driver/app.dart).</p>
<p>如果它是为像 test_driver/app.dart 这样的驱动程序测试而构建的，请确保还指定 --target=test_driver/app.dart （例如，flutter build ios --bundle-sksl-path flutter_01.sksl.json --target= test_driver/app.dart）。</p>
<p>5.Test the newly built app.</p>
<p>5.测试新建的App。</p>
<p>Alternatively, you can write some integration tests to automate the first three steps using a single command. For example:</p>
<p>或者，你可以编写一些集成测试以使用单个命令自动执行前三个步骤。 例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter drive --profile --cache-sksl --write-sksl-on-exit flutter_01.sksl.json -t test_driver/app.dart</span><br></pre></td></tr></table></figure>
<p>With such integration tests, you can easily and reliably get the new SkSLs when the app code changes, or when Flutter upgrades. Such tests can also be used to verify the performance change before and after the SkSL warm-up. Even better, you can put those tests into a CI (continuous integration) system so the SkSLs are generated and tested automatically over the lifetime of an app.</p>
<p>通过此类集成测试，你可以在app代码更改或 Flutter 升级时轻松可靠地获取新的 SkSL。 此类测试还可用于验证 SkSL 预热前后的性能变化。 更好的是，你可以将这些测试放入 CI（持续集成）系统中，以便在App的整个生命周期内自动生成和测试 SkSL。</p>
<p>Take the original version of Flutter Gallery as an example. The CI system is set up to generate SkSLs for every Flutter commit, and verifies the performance, in the transitions_perf_test.dart test. For more details, see the flutter_gallery_sksl_warmup__transition_perf and flutter_gallery_sksl_warmup__transition_perf_e2e_ios32 tasks.</p>
<p>以原版 Flutter Gallery 为例。 CI 系统设置为为每次 Flutter 提交生成 SkSL，并在 transitions_perf_test.dart 测试中验证性能。 有关更多详细信息，请参阅 flutter_gallery_sksl_warmup__transition_perf 和flutter_gallery_sksl_warmup__transition_perf_e2e_ios32 任务。</p>
<p>The worst frame rasterization time is a nice metric from such integration tests to indicate the severity of shader compilation jank. For instance, the steps above reduce Flutter gallery’s shader compilation jank and speeds up its worst frame rasterization time on a Moto G4 from ~90 ms to ~40 ms. On iPhone 4s, it’s reduced from ~300 ms to ~80 ms. That leads to the visual difference as illustrated in the beginning of this article.</p>
<p>最差帧raster时间是此类集成测试的一个很好的指标，用于指示shaders编译卡顿的严重性。 例如，上述步骤减少了 Flutter 库的shaders编译卡顿，并将其在 Moto G4 上的最差raster时间从 ~90 ms 加速到 ~40 ms。 在 iPhone 4s 上，它从 ~300 ms 减少到 ~80 ms。 这导致了本文开头所示的视觉差异。</p>
<h3 id="Frequently-asked-questions-常问的问题">Frequently asked questions- 常问的问题</h3>
<h4 id="Why-not-just-compile-or-warm-up-all-possible-shaders-为什么不直接编译或预热所有可能的shaders？">Why not just compile or warm up all possible shaders? - 为什么不直接编译或预热所有可能的shaders？</h4>
<p>If there were only a limited number of possible shaders, then Flutter could compile all of them when an application is built. However, for the best overall performance, the Skia GPU backend used by Flutter dynamically generates shaders based on many parameters at runtime (for example draws, device models, and driver versions). Due to all possible combinations of those parameters, the number of possible shaders multiplies quickly. In short, Flutter uses programs (app, Flutter, and Skia code) to generate some other programs (shaders).</p>
<p>如果shaders数量有上限，那么 Flutter 可以在构建App时编译所有shaders。 然而，为了获得最佳的整体性能，Flutter 使用的 Skia GPU 在背后会在运行时根据许多参数（例如绘图、设备模型和驱动程序版本）动态生成shaders。 由于这些参数的所有可能组合，可能的shaders数量迅速增加。 简而言之，Flutter 使用程序（app、Flutter 和 Skia 代码）来生成其他一些程序（shaders）。</p>
<p>The number of possible shader programs that Flutter can generate is too large to precompute and bundle with an application.</p>
<p>Flutter 可以生成的可能shaders程序的数量太大而无法预先计算并与App捆绑在一起。</p>
<h4 id="Can-SkSLs-captured-from-one-device-help-shader-compilation-jank-on-another-device-从一台设备捕获的-SkSL-能否帮助shaders编译在另一台设备上卡顿？">Can SkSLs captured from one device help shader compilation jank on another device? -从一台设备捕获的 SkSL 能否帮助shaders编译在另一台设备上卡顿？</h4>
<p>Theoretically, there’s no guarantee that the SkSLs from one device would help on another device (but they also won’t cause any troubles if SkSLs aren’t compatible across devices). Practically, as shown in the table on this SkSL-based warmup issue, SkSLs work surprisingly well even if 1) SkSLs are captured from iOS and then applied to Android devices, or 2) SkSLs are captured from emulators and then applied to real mobile devices. As the Flutter team has only a limited number of devices in the lab, we currently don’t have enough data to provide a big picture of cross-device effectiveness. We’d love you to provide us more data points to see how it works in the wild—FrameTiming can be used to compute the worst frame rasterization time in release mode; the worst frame rasterization time is a good indicator on how severe the shader compilation jank is.</p>
<p>从理论上讲，不能保证来自一台设备的 SkSL 会在另一台设备上有所帮助（但如果 SkSL 不能跨设备兼容，它们也不会造成任何问题）。 实际上，如这个基于 SkSL 的预热问题的表格所示，即使 1) 从 iOS 捕获 SkSL，然后将其应用于 Android 设备，或者 2) 从模拟器捕获 SkSL，然后将其应用于真实的移动设备，SkSL 的工作效果也出奇地好 . 由于 Flutter 团队在实验室中只有有限数量的设备，我们目前没有足够的数据来提供跨设备有效性的大图。 我们希望你提供更多数据点，看看它在实验室之外是如何工作的——FrameTiming 可用于计算release模式下最差的raster化时间； 最差帧raster时间可以很好地指示shaders编译卡顿的严重程度。</p>
<h4 id="Why-can’t-you-create-a-single-“ubershader”-and-just-compile-that-once-为什么你不能创建一个单一的“ubershader”并且只编译一次呢？">Why can’t you create a single “ubershader” and just compile that once? -为什么你不能创建一个单一的“ubershader”并且只编译一次呢？</h4>
<p>One idea that people sometimes suggest is to create a single large shader that implements all of Skia’s features, and use that shader while the more optimized bespoke shaders are being compiled.</p>
<p>人们有时建议的一个想法是创建一个实现 Skia 所有功能的大型shaders，并在编译更优化的定制shaders时使用该shaders。</p>
<p>This is similar to a solution used by the Dolphin Emulator.</p>
<p>这类似于 Dolphin Emulator 使用的解决方案。</p>
<p>In practice we believe implementing this for Flutter (or more specifically for Skia) would be impractical. Such a shader would be fantastically large, essentially reimplementing all of Skia on the GPU. This would itself take a long time to compile, thus introducing more jank; it would not necessarily be fast enough to avoid jank even when compiled; and it would likely introduce fidelity issues (e.g. flickering) since there would likely be differences in precise rendering between the optimized shaders and the “ubershader”.</p>
<p>在实践中，我们认为为 Flutter（或更具体地为 Skia）实现这一点是不切实际的。 这样的shaders会非常大，本质上是在 GPU 上重新实现所有 Skia。 这本身会花费很长时间来编译，从而引入更多的卡顿问题； 即使在编译时，它也不一定足够快以避免卡顿； 并且它可能会引入保真度问题（例如闪烁），因为优化shaders和“ubershader”之间的精确渲染可能存在差异。</p>
<p>That said, Flutter and Skia are open source and we are eager to see proofs-of-concept along these lines if this is something that interests you. To get started, please see our contribution guidelines.</p>
<p>也就是说，Flutter 和 Skia 是开源的，如果你对此感兴趣，我们渴望看到这些方面的概念验证。 要开始使用，请参阅我们的贡献指南。</p>
<h3 id="Future-work-未来的工作">Future work - 未来的工作</h3>
<p>On both Android and iOS, shader warm-up has a few drawbacks:</p>
<p>在 Android 和 iOS 上，shaders预热都有一些缺点：</p>
<ol>
<li>The size of the deployed app is larger because it contains the bundled shaders.</li>
<li>发布的App的包体积会更大，因为它包含捆绑的shaders。</li>
<li>App startup latency is longer because the bundled shaders need to be precompiled.</li>
<li>App启动时间会较长，因为捆绑的shaders需要预编译。</li>
</ol>
<p> </p>
<p> </p>
<h2 id="参考">参考</h2>
<blockquote>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://flutter.cn/docs/perf/best-practices">https://flutter.cn/docs/perf/best-practices</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://juejin.cn/post/7066954522655981581">https://juejin.cn/post/7066954522655981581</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://flutter.cn/docs/perf/shader">https://flutter.cn/docs/perf/shader</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://flutter.cn/docs/development/tools/devtools/performance">https://flutter.cn/docs/development/tools/devtools/performance</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ZWN2001.github.io">洛雪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwn2001.github.io/2022/09/19/FLutter%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">https://zwn2001.github.io/2022/09/19/FLutter%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ZWN2001.github.io" target="_blank">ZWN's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/flutter/">flutter</a></div><div class="post_share"><div class="social-share" data-image="/img/cover3/21-min.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/09/15/%E5%AE%89%E5%8D%93Jetpack%E4%BB%8E%E4%B8%A4%E7%9C%BC%E4%B8%80%E6%8A%B9%E9%BB%91%E5%88%B0%E4%B8%A4%E7%9C%BC%E4%B8%80%E9%BB%91/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/23-min.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">安卓Jetpack从两眼一抹黑到两眼一黑</div></div></a></div><div class="next-post pull-right"><a href="/2022/09/23/CSharp%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">CSharp从入门到入门</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/23/Dart-Mixin/" title="Dart-Mixin是什么"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/16-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-23</div><div class="title">Dart-Mixin是什么</div></div></a></div><div><a href="/2022/04/20/flutter-context/" title="flutter-context"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/33.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-20</div><div class="title">flutter-context</div></div></a></div><div><a href="/2022/05/05/flutter-generate-uml/" title="flutter生成UML"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-05</div><div class="title">flutter生成UML</div></div></a></div><div><a href="/2022/04/20/flutter-key/" title="学线培训：flutter-key"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/4.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-20</div><div class="title">学线培训：flutter-key</div></div></a></div><div><a href="/2022/02/01/flutter%E5%A6%82%E4%BD%95%E7%9B%91%E5%90%AC%E9%BC%A0%E6%A0%87-desktop/" title="flutter如何监听鼠标-desktop"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/34.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-01</div><div class="title">flutter如何监听鼠标-desktop</div></div></a></div><div><a href="/2021/09/29/flutterweb%E9%BC%A0%E6%A0%87%E7%A7%BB%E5%85%A5%E6%97%B6%E6%94%B9%E5%8F%98card%E7%9A%84%E9%98%B4%E5%BD%B1/" title="flutterweb鼠标移入时改变card的阴影"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/26.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-29</div><div class="title">flutterweb鼠标移入时改变card的阴影</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">洛雪</div><div class="author-info__description">我虽无意逐鹿，却知苍生苦楚</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">117</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">40</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ZWN2001"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZWN2001" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">新域名：www.zwn2001.space，有效期：10年。https://www.zwn-blog.xyz/将在2023年末过期。建议使用无痕模式以更快地得到更新，或者访问以下永久域名https://zwn-2001-github-io.vercel.app/,或https://zwn2001.github.io</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">FLutter性能优化</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%86%E5%A4%87"><span class="toc-number">1.1.</span> <span class="toc-text">准备</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flutter-Inspector"><span class="toc-number">1.1.1.</span> <span class="toc-text">Flutter Inspector</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Repaint-Rainbow"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">Repaint Rainbow</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%9C%E7%94%A8"><span class="toc-number">1.1.1.2.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">1.1.1.3.</span> <span class="toc-text">使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">1.1.1.4.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E6%80%A7%E8%83%BD%E8%A7%86%E5%9B%BE-Performance-view"><span class="toc-number">1.1.2.</span> <span class="toc-text">使用性能视图 (Performance view)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A7%E4%BA%8B%E4%BB%B6%E5%9B%BE%EF%BC%9A"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">帧事件图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E7%BA%BF%E4%BA%8B%E4%BB%B6%E5%9B%BE%EF%BC%9A"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">时间线事件图：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Enhance-Tracing"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">Enhance Tracing</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87"><span class="toc-number">1.2.</span> <span class="toc-text">性能指标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B8%83%E5%B1%80%E5%8A%A0%E8%BD%BD%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.</span> <span class="toc-text">布局加载优化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E8%A7%84%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.1.</span> <span class="toc-text">常规优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9C%A8-build-%E6%96%B9%E6%B3%95%E4%B8%AD%E6%89%A7%E8%A1%8C%E4%BA%86%E8%80%97%E6%97%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">在 build() 方法中执行了耗时操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Widget-%E8%80%8C%E4%B8%8D%E6%98%AF%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">使用 Widget 而不是函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-nil-%E5%8E%BB%E6%9B%BF%E4%BB%A3-Container-%E5%92%8C-SizedBox"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">使用 nil 去替代 Container() 和 SizedBox()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%97%E8%A1%A8%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.2.</span> <span class="toc-text">列表优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E4%BA%8E%E9%95%BF%E5%88%97%E8%A1%A8%EF%BC%8C%E8%AE%B0%E5%BE%97%E5%9C%A8-ListView-%E4%B8%AD%E4%BD%BF%E7%94%A8-itemExtent%E3%80%82"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">针对于长列表，记得在 ListView 中使用 itemExtent。</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%8F%E5%B0%91%E5%8F%AF%E6%8A%98%E5%8F%A0-ListView-%E7%9A%84%E6%9E%84%E5%BB%BA%E6%97%B6%E9%97%B4"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">减少可折叠 ListView 的构建时间</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%85%A5%E4%BC%98%E5%8C%96"><span class="toc-number">1.3.3.</span> <span class="toc-text">深入优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E5%85%89%E6%A0%85%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">优化光栅线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%94%A8-key-%E5%8A%A0%E9%80%9F-Flutter-%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%85%89%E6%A0%85%E7%BA%BF%E7%A8%8B"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">用 key 加速 Flutter 的性能优化光栅线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%85%83%E7%B4%A0%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">1.3.3.2.1.</span> <span class="toc-text">元素的生命周期</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.3.2.2.</span> <span class="toc-text">优化方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BC%98%E5%8A%BF"><span class="toc-number">1.3.3.2.3.</span> <span class="toc-text">优势</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">1.3.3.2.4.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%84%E7%BC%96%E8%AF%91Shader"><span class="toc-number">1.4.</span> <span class="toc-text">预编译Shader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#What-is-shader-compilation-jank-%E4%BB%80%E4%B9%88%E6%98%AFshaders%E7%BC%96%E8%AF%91%E5%8D%A1%E9%A1%BF%EF%BC%9F"><span class="toc-number">1.4.1.</span> <span class="toc-text">What is shader compilation jank? -什么是shaders编译卡顿？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#What-do-we-mean-by-%E2%80%9Cfirst-run%E2%80%9D-%E6%88%91%E4%BB%AC%E6%89%80%E8%AF%B4%E7%9A%84%E2%80%9C%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%90%E8%A1%8C%E2%80%9D%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D%EF%BC%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">What do we mean by “first run”? - 我们所说的“第一次运行”是什么意思？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#How-to-use-SkSL-warmup-%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-SkSL-%E7%83%AD%E8%BA%AB"><span class="toc-number">1.4.3.</span> <span class="toc-text">How to use SkSL warmup - 如何使用 SkSL 热身</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Frequently-asked-questions-%E5%B8%B8%E9%97%AE%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">1.4.4.</span> <span class="toc-text">Frequently asked questions- 常问的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Why-not-just-compile-or-warm-up-all-possible-shaders-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%9B%B4%E6%8E%A5%E7%BC%96%E8%AF%91%E6%88%96%E9%A2%84%E7%83%AD%E6%89%80%E6%9C%89%E5%8F%AF%E8%83%BD%E7%9A%84shaders%EF%BC%9F"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">Why not just compile or warm up all possible shaders? - 为什么不直接编译或预热所有可能的shaders？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Can-SkSLs-captured-from-one-device-help-shader-compilation-jank-on-another-device-%E4%BB%8E%E4%B8%80%E5%8F%B0%E8%AE%BE%E5%A4%87%E6%8D%95%E8%8E%B7%E7%9A%84-SkSL-%E8%83%BD%E5%90%A6%E5%B8%AE%E5%8A%A9shaders%E7%BC%96%E8%AF%91%E5%9C%A8%E5%8F%A6%E4%B8%80%E5%8F%B0%E8%AE%BE%E5%A4%87%E4%B8%8A%E5%8D%A1%E9%A1%BF%EF%BC%9F"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">Can SkSLs captured from one device help shader compilation jank on another device? -从一台设备捕获的 SkSL 能否帮助shaders编译在另一台设备上卡顿？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Why-can%E2%80%99t-you-create-a-single-%E2%80%9Cubershader%E2%80%9D-and-just-compile-that-once-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%A0%E4%B8%8D%E8%83%BD%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E5%8D%95%E4%B8%80%E7%9A%84%E2%80%9Cubershader%E2%80%9D%E5%B9%B6%E4%B8%94%E5%8F%AA%E7%BC%96%E8%AF%91%E4%B8%80%E6%AC%A1%E5%91%A2%EF%BC%9F"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">Why can’t you create a single “ubershader” and just compile that once? -为什么你不能创建一个单一的“ubershader”并且只编译一次呢？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-work-%E6%9C%AA%E6%9D%A5%E7%9A%84%E5%B7%A5%E4%BD%9C"><span class="toc-number">1.4.5.</span> <span class="toc-text">Future work - 未来的工作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.5.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/04/25/Butterfly%E4%B8%80%E5%9B%BE%E6%B5%81%E8%B8%A9%E5%9D%91/" title="Butterfly一图流踩坑"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/4-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Butterfly一图流踩坑"/></a><div class="content"><a class="title" href="/2023/04/25/Butterfly%E4%B8%80%E5%9B%BE%E6%B5%81%E8%B8%A9%E5%9D%91/" title="Butterfly一图流踩坑">Butterfly一图流踩坑</a><time datetime="2023-04-25T02:46:28.000Z" title="发表于 2023-04-25 10:46:28">2023-04-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/22/%E7%BD%91%E9%A1%B5%E8%A7%A3%E9%99%A4%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E9%99%90%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/" title="网页解除复制粘贴限制的一些小技巧"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/13-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="网页解除复制粘贴限制的一些小技巧"/></a><div class="content"><a class="title" href="/2023/04/22/%E7%BD%91%E9%A1%B5%E8%A7%A3%E9%99%A4%E5%A4%8D%E5%88%B6%E7%B2%98%E8%B4%B4%E9%99%90%E5%88%B6%E7%9A%84%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/" title="网页解除复制粘贴限制的一些小技巧">网页解除复制粘贴限制的一些小技巧</a><time datetime="2023-04-22T05:33:02.000Z" title="发表于 2023-04-22 13:33:02">2023-04-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/" title="机器学习实验"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/6-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器学习实验"/></a><div class="content"><a class="title" href="/2023/03/29/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%AE%9E%E9%AA%8C/" title="机器学习实验">机器学习实验</a><time datetime="2023-03-29T13:10:02.000Z" title="发表于 2023-03-29 21:10:02">2023-03-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/21/huaweiCodeCraft%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/" title="huaweiCodeCraft的一些反思"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/34.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="huaweiCodeCraft的一些反思"/></a><div class="content"><a class="title" href="/2023/03/21/huaweiCodeCraft%E7%9A%84%E4%B8%80%E4%BA%9B%E5%8F%8D%E6%80%9D/" title="huaweiCodeCraft的一些反思">huaweiCodeCraft的一些反思</a><time datetime="2023-03-21T01:31:06.000Z" title="发表于 2023-03-21 09:31:06">2023-03-21</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="机器学习"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/26.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="机器学习"/></a><div class="content"><a class="title" href="/2023/03/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" title="机器学习">机器学习</a><time datetime="2023-03-01T13:10:02.000Z" title="发表于 2023-03-01 21:10:02">2023-03-01</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By 洛雪</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">喵喵喵？</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '7MlJqmD9Ceux2bxiKqPqsMHW-gzGzoHsz',
      appKey: '3oP9XaednBAwtfMk2q28dwGP',
      avatar: 'hide',
      serverURLs: 'https://7mljqmd9.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://my-hexo-github-calender.vercel.app/api/?ZWN2001";
            var git_color =['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c'];
            var git_user ="ZWN2001";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://ZWN2001.github.io/categories/编程知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 洛雪の编程知识 (16)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://ZWN2001.github.io/categories/实用知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 洛雪の实用知识 (13)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://ZWN2001.github.io/categories/学习-课外拓展/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 洛雪の学习-课外拓展 (17)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://ZWN2001.github.io/categories/学习-课内知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 洛雪の学习-课内知识 (42)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://ZWN2001.github.io/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><!-- hexo injector body_end end --></body></html>