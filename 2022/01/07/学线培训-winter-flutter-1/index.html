<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>学线培训:winter-flutter-1 | ZWN's blog</title><meta name="keywords" content="移动"><meta name="author" content="ZWN"><meta name="copyright" content="ZWN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Widget 简介（了解） Widget 概念 在前面的介绍中，我们知道在Flutter中几乎所有的对象都是一个 widget 。与原生开发中“控件”不同的是，Flutter 中的 widget 的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector 、用于APP主题数据传递的 Theme 等等，而原生开发中的控件通常只是指UI元素。在后">
<meta property="og:type" content="article">
<meta property="og:title" content="学线培训:winter-flutter-1">
<meta property="og:url" content="https://zwn2001.github.io/2022/01/07/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD-winter-flutter-1/index.html">
<meta property="og:site_name" content="ZWN&#39;s blog">
<meta property="og:description" content="Widget 简介（了解） Widget 概念 在前面的介绍中，我们知道在Flutter中几乎所有的对象都是一个 widget 。与原生开发中“控件”不同的是，Flutter 中的 widget 的概念更广泛，它不仅可以表示UI元素，也可以表示一些功能性的组件如：用于手势检测的 GestureDetector 、用于APP主题数据传递的 Theme 等等，而原生开发中的控件通常只是指UI元素。在后">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zwn2001.github.io/img/cover1/38.jpg">
<meta property="article:published_time" content="2022-01-07T08:29:00.000Z">
<meta property="article:modified_time" content="2022-07-01T12:46:06.406Z">
<meta property="article:author" content="ZWN">
<meta property="article:tag" content="移动">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zwn2001.github.io/img/cover1/38.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zwn2001.github.io/2022/01/07/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD-winter-flutter-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: ZWN","link":"链接: ","source":"来源: ZWN's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '学线培训:winter-flutter-1',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-01 20:46:06'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">94</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover1/38.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZWN's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">学线培训:winter-flutter-1</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-07T08:29:00.000Z" title="发表于 2022-01-07 16:29:00">2022-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-01T12:46:06.406Z" title="更新于 2022-07-01 20:46:06">2022-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD/">学线培训</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>23分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="学线培训:winter-flutter-1"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>Widget 简介（了解）</h1>
<h2 id="Widget-概念">Widget 概念</h2>
<p>在前面的介绍中，我们知道在Flutter中几乎所有的对象都是一个 widget 。与原生开发中“控件”不同的是，Flutter 中的 widget 的概念更广泛，<strong>它不仅可以表示UI元素，也可以表示一些功能性的组件</strong>如：用于手势检测的 <code>GestureDetector</code> 、用于APP主题数据传递的 <code>Theme</code> 等等，而<strong>原生开发中的控件通常只是指UI元素</strong>。在后面的内容中，我们在描述UI元素时可能会用到“控件”、“组件”这样的概念，读者心里需要知道他们就是 widget ，只是在不同场景的不同表述而已。由于 Flutter 主要就是用于构建用户界面的，所以，在大多数时候，读者可以认为 widget 就是一个控件，不必纠结于概念。</p>
<p>Flutter 中是通过 Widget 嵌套 Widget 的方式来构建UI和进行实践处理的，所以记住，<strong>Flutter 中万物皆为Widget。</strong></p>
<h2 id="Flutter中的四棵树（比较抽象，尽量理解即可）">Flutter中的四棵树（比较抽象，尽量理解即可）</h2>
<p>既然 Widget 只是描述一个UI元素的配置信息，那么真正的布局、绘制是由谁来完成的呢？Flutter 框架的的处理流程是这样的：</p>
<ol>
<li>根据 Widget 树生成一个 Element 树，Element 树中的节点都继承自 <code>Element</code> 类。</li>
<li>根据 Element 树生成 Render 树（渲染树），渲染树中的节点都继承自<code>RenderObject</code> 类。</li>
<li>根据渲染树生成 Layer 树，然后上屏显示，Layer 树中的节点都继承自 <code>Layer</code> 类。</li>
</ol>
<p>真正的布局和渲染逻辑在 Render 树中，Element 是 Widget 和 RenderObject 的粘合剂，可以理解为一个中间代理。我们通过一个例子来说明，假设有如下 Widget 树：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Container( <span class="comment">// 一个容器 widget</span></span><br><span class="line">  color: Colors.blue, <span class="comment">// 设置容器背景色</span></span><br><span class="line">  child: Row( <span class="comment">// 可以将子widget沿水平方向排列</span></span><br><span class="line">    children: [</span><br><span class="line">      Image.network(<span class="string">&#x27;https://www.example.com/1.png&#x27;</span>), <span class="comment">// 显示图片的 widget</span></span><br><span class="line">      <span class="keyword">const</span> Text(<span class="string">&#x27;A&#x27;</span>),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>注意，如果 Container 设置了背景色，Container 内部会创建一个新的 ColoredBox 来填充背景，相关逻辑如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (color != <span class="keyword">null</span>)</span><br><span class="line">  current = ColoredBox(color: color!, child: current);</span><br></pre></td></tr></table></figure>
<p>而 Image 内部会通过 RawImage 来渲染图片、Text 内部会通过 RichText 来渲染文本，所以最终的 Widget树、Element 树、渲染树结构如下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="8.png" alt=""></p>
<p>这里需要注意：</p>
<ol>
<li>三棵树中，Widget 和 Element 是一一对应的，但并不和 RenderObject 一一对应。比如 <code>StatelessWidget</code> 和 <code>StatefulWidget</code> 都没有对应的 RenderObject。</li>
<li>渲染树在上屏前会生成一棵 Layer 树。</li>
<li>以上的内容比较涉及底层原理，这里只是让大家了解一下界面渲染原理，不必深究。</li>
</ol>
<h2 id="Context">Context</h2>
<p><code>build</code>方法有一个<code>context</code>参数，它是<code>BuildContext</code>类的一个实例，表示当前 widget 在 widget 树中的上下文，每一个 widget 都会对应一个 context 对象（因为每一个 widget 都是 widget 树上的一个节点）。实际上，<code>context</code>是当前 widget 在 widget 树中位置中执行”相关操作“的一个句柄(handle)，比如它提供了从当前 widget 开始向上遍历 widget 树以及按照 widget 类型查找父级 widget 的方法。下面是在子树中获取父级 widget 的一个示例：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span>  </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;Context测试&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Container(</span><br><span class="line">        child: Builder(builder: (context) &#123;</span><br><span class="line">          <span class="comment">// 在 widget 树中向上查找最近的父级`Scaffold`  widget </span></span><br><span class="line">          Scaffold scaffold = context.findAncestorWidgetOfExactType&lt;Scaffold&gt;();</span><br><span class="line">          <span class="comment">// 直接返回 AppBar的title， 此处实际上是Text(&quot;Context测试&quot;)</span></span><br><span class="line">          <span class="keyword">return</span> (scaffold.appBar <span class="keyword">as</span> AppBar).title;</span><br><span class="line">        &#125;),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="0.png" alt="运行后效果"></p>
<h3 id="通过Context获取State对象">通过Context获取State对象</h3>
<p><code>  context</code>对象有一个<code>findAncestorStateOfType()</code>方法，该方法可以从当前节点沿着 widget 树向上查找指定类型的 StatefulWidget 对应的 State 对象。通常用于在子 widget 树中获取父级 StatefulWidget 的State 对象。</p>
<p>一般来说，如果 StatefulWidget 的状态是私有的（不应该向外部暴露），那么我们代码中就不应该去直接获取其 State 对象；如果StatefulWidget的状态是希望暴露出的（通常还有一些组件的操作方法），我们则可以去直接获取其State对象。但是通过 <code>context.findAncestorStateOfType</code> 获取 StatefulWidget 的状态的方法是通用的，我们并不能在语法层面指定 StatefulWidget 的状态是否私有，所以在 Flutter 开发中便有了一个默认的约定：**如果 StatefulWidget 的状态是希望暴露出的，应当在 StatefulWidget 中提供一个<code>of</code> 静态方法来获取其 State 对象，开发者便可直接通过该方法来获取；如果 State不希望暴露，则不提供<code>of</code>方法。**这个约定在 Flutter SDK 里随处可见。</p>
<p>但其实也可以通过GlobalKey去获取，但是代价比较大，加上key的概念更加抽象难以理解，也不做解释。</p>
<h2 id="StatefulWidget-生命周期：">StatefulWidget 生命周期：</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="1.jpg" alt=""></p>
<p>跟安卓相比，基本一模一样。</p>
<h1>热重载</h1>
<p>Flutter的热重载(hot reload)功能可以帮助您在无需重新启动应用的情况下快速、轻松地进行测试、构建用户界面、添加功能以及修复错误。 通过将更新后的源代码文件注入正在运行的Dart虚拟机（VM）中来实现热重载。在虚拟机使用新的的字段和函数更新类后，Flutter框架会自动重新构建widget树，以便您快速查看更改的效果。</p>
<p>要热重载一个Flutter应用程序:</p>
<ol>
<li>
<p>从受支持的IntelliJ IDE或终端窗口运行应用程序。物理机或虚拟器都可以运行。</p>
</li>
<li>
<p>修改项目中的一个Dart文件。大多数类型的代码更改可以重新加载; 有关需要完全重新启动的更改列表，请参阅<a target="_blank" rel="noopener" href="https://flutterchina.club/hot-reload/#limitations">限制</a>。</p>
</li>
<li>
<p>单击工具栏上的Hot Reload按钮。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://flutterchina.club/images/intellij/hot-reload.gif" alt=""></p>
</li>
</ol>
<p>如果您正在使用命令行<code>flutter run</code>运行应用程序，请在终端窗口输入<code>r</code></p>
<p>成功执行热重载后，您将在控制台中看到类似于以下内容的消息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Performing hot reload...</span><br><span class="line">Reloaded 1 of 448 libraries in 2,777ms.</span><br></pre></td></tr></table></figure>
<p>在android studio中的位置：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2.png" alt=""></p>
<p>比较简单，可以自行尝试</p>
<h1>路由管理</h1>
<p>路由（Route）在移动开发中通常指页面（Page），这跟 Web 开发中单页应用的 Route 概念意义是相同的，Route 在 Android中 通常指一个 Activity，在 iOS 中指一个 ViewController。所谓路由管理，就是管理页面之间如何跳转，通常也可被称为导航管理。Flutter 中的路由管理和原生开发类似，无论是 Android 还是 iOS，导航管理都会维护一个路由栈，路由入栈（push）操作对应打开一个新页面，路由出栈（pop）操作对应页面关闭操作，而<strong>路由管理主要是指如何来管理路由栈</strong>。</p>
<p>同样地，我们在原生中常常遇到一个界面在不可见之后是否要销毁的问题以及清空路由栈等等操作，而这些操作在Flutter中更加便利，我们可以直接调用Navigator进行统一的路由管理，其中的操作其实也不仅限于push与pop。</p>
<h2 id="Navigator">Navigator</h2>
<p><code>Navigator</code>是一个路由管理的组件，它提供了打开和退出路由页方法。<code>Navigator</code>通过一个栈来管理活动路由集合，其实就是路由栈。通常当前屏幕显示的页面就是栈顶的路由。<code>Navigator</code>提供了一系列方法来管理路由栈，在此我们只介绍其最常用的两个方法：</p>
<h3 id="Future-push-BuildContext-context-Route-route">Future push(BuildContext context, Route route)</h3>
<p>将给定的路由入栈（即打开新的页面），返回值是一个<code>Future</code>对象，用以接收新路由出栈（即关闭）时的返回数据。但是实际上，如果你仅仅是想打开一个新的界面，完全可以这样：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IconButton(</span><br><span class="line">    onPressed:()&#123;</span><br><span class="line">         Navigator.push(context, PageName());</span><br><span class="line">    &#125;</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<p>意味着将这个界面打开（入栈）。</p>
<h3 id="bool-pop-BuildContext-context-result">bool pop(BuildContext context, [ result ])</h3>
<p>将栈顶路由出栈，也就是关闭当前界面，<code>result</code> 为页面关闭时返回给上一个页面的数据。</p>
<p>同上，如果没有什么需求，直接这样就行：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IconButton(</span><br><span class="line">    onPressed:()&#123;</span><br><span class="line">         Navigator.pop(context);</span><br><span class="line">    &#125;</span><br><span class="line">),</span><br></pre></td></tr></table></figure>
<h3 id="PS">PS.</h3>
<p><code>Navigator</code> 还有很多其它方法，如<code>Navigator.replace</code>、<code>Navigator.popUntil</code>等,通过这些方法的使用甚至组合使用，其实可以解决很多逻辑上的难题，详情自行使用搜索引擎进行查阅，在此不再赘述，路由逻辑上的问题，只要能够发现，一般都会有现成的比较成熟的解决方案。下面我们还需要介绍一下路由相关的另一个概念“命名路由”。</p>
<h4 id="实例方法">实例方法</h4>
<p>Navigator类中第一个参数为context的<strong>静态方法</strong>都对应一个Navigator的<strong>实例方法</strong>， 比如<code>Navigator.push(BuildContext context, Route route)</code>等价于<code>Navigator.of(context).push(Route route)</code> ，下面命名路由相关的方法也是一样的。这个在上面的context与widget树部分有提到。</p>
<h2 id="路由传值">路由传值</h2>
<p>很多时候，在路由跳转时我们需要带一些参数，比如打开商品详情页时，我们需要带一个商品id，这样商品详情页才知道展示哪个商品信息；又比如我们在填写订单时需要选择收货地址，打开地址选择页并选择地址后，可以将用户选择的地址返回到订单页等等。下面我们通过一个简单的示例来演示新旧路由如何传参。</p>
<h3 id="示例">示例</h3>
<p>我们创建一个<code>TipRoute</code>路由，它接受一个提示文本参数，负责将传入它的文本显示在页面上，另外<code>TipRoute</code>中我们添加一个“返回”按钮，点击后在返回上一个路由的同时会带上一个返回参数，下面我们看一下实现代码。</p>
<p><code>TipRoute</code>实现代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TipRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  TipRoute(&#123;</span><br><span class="line">    Key key,</span><br><span class="line">    <span class="meta">@required</span> <span class="keyword">this</span>.text,  <span class="comment">// 接收一个text参数</span></span><br><span class="line">  &#125;) : <span class="keyword">super</span>(key: key);</span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">String</span> text;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Scaffold(</span><br><span class="line">      appBar: AppBar(</span><br><span class="line">        title: Text(<span class="string">&quot;提示&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">      body: Padding(</span><br><span class="line">        padding: EdgeInsets.all(<span class="number">18</span>),</span><br><span class="line">        child: Center(</span><br><span class="line">          child: Column(</span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Text(text),</span><br><span class="line">              ElevatedButton(</span><br><span class="line">                onPressed: () =&gt; Navigator.pop(context, <span class="string">&quot;我是返回值&quot;</span>),</span><br><span class="line">                child: Text(<span class="string">&quot;返回&quot;</span>),</span><br><span class="line">              )</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是打开新路由<code>TipRoute</code>的代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouterTestRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Center(</span><br><span class="line">      child: ElevatedButton(</span><br><span class="line">        onPressed: () <span class="keyword">async</span> &#123;</span><br><span class="line">          <span class="comment">// 打开`TipRoute`，并等待返回结果</span></span><br><span class="line">          <span class="keyword">var</span> result = <span class="keyword">await</span> Navigator.push(</span><br><span class="line">            context,</span><br><span class="line">            MaterialPageRoute(</span><br><span class="line">              builder: (context) &#123;</span><br><span class="line">                <span class="keyword">return</span> TipRoute(</span><br><span class="line">                  <span class="comment">// 路由参数</span></span><br><span class="line">                  text: <span class="string">&quot;我是提示xxxx&quot;</span>,</span><br><span class="line">                );</span><br><span class="line">              &#125;,</span><br><span class="line">            ),</span><br><span class="line">          );</span><br><span class="line">          <span class="comment">//输出`TipRoute`路由返回结果</span></span><br><span class="line">          <span class="built_in">print</span>(<span class="string">&quot;路由返回值: <span class="subst">$result</span>&quot;</span>);</span><br><span class="line">        &#125;,</span><br><span class="line">        child: Text(<span class="string">&quot;打开提示页&quot;</span>),</span><br><span class="line">      ),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行上面代码，点击<code>RouterTestRoute</code>页的“打开提示页”按钮，会打开<code>TipRoute</code>页，运行效果如图2-4所示下：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://book.flutterchina.club/assets/img/2-4.1abb1cab.png" alt=""></p>
<p>需要说明：</p>
<ol>
<li>
<p>提示文案“我是提示xxxx”是通过<code>TipRoute</code>的<code>text</code>参数传递给新路由页的。我们可以通过等待<code>Navigator.push(…)</code>返回的<code>Future</code>来获取新路由的返回数据。</p>
</li>
<li>
<p>在<code>TipRoute</code>页中有两种方式可以返回到上一页；第一种方式是直接点击导航栏返回箭头，第二种方式是点击页面中的“返回”按钮。这两种返回方式的区别是前者不会返回数据给上一个路由，而后者会。下面是分别点击页面中的返回按钮和导航栏返回箭头后，<code>RouterTestRoute</code>页中<code>print</code>方法在控制台输出的内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I/flutter (27896): 路由返回值: 我是返回值</span><br><span class="line">I/flutter (27896): 路由返回值: null</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面介绍的是非命名路由的传值方式，命名路由的传值方式会有所不同，我们会在下面介绍命名路由时介绍。</p>
<h2 id="命名路由">命名路由</h2>
<p>所谓“命名路由”（Named Route）即有名字的路由，我们可以先给路由起一个名字，然后就可以通过路由名字直接打开新的路由了，这为路由管理带来了一种直观、简单的方式。其实这种方式只是方便对路由进行统一管理，可以理解为键值对，与直接使用并无太大区别。通过使用命名路由，可以将路由与跳转的界面进行解耦，方便修改目标界面（不过小型项目倒无所谓）。</p>
<h3 id="路由表">路由表</h3>
<p>要想使用命名路由，我们必须先提供并注册一个路由表（routing table），这样应用程序才知道哪个名字与哪个路由组件相对应。路由表的定义如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Map</span>&lt;<span class="built_in">String</span>, WidgetBuilder&gt; routes;</span><br></pre></td></tr></table></figure>
<p>它是一个<code>Map</code>，key为路由的名字，是个字符串；value是个<code>builder</code>回调函数，用于生成相应的路由widget。我们在通过路由名字打开新路由时，应用会根据路由名字在路由表中查找到对应的<code>WidgetBuilder</code>回调函数，然后调用该回调函数生成路由widget并返回。</p>
<h3 id="注册路由表">注册路由表</h3>
<p>路由表的注册方式很简单，我们回到之前“计数器”的示例，然后在<code>MyApp</code>类的<code>build</code>方法中找到<code>MaterialApp</code>，添加<code>routes</code>属性，代码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">  theme: ThemeData(</span><br><span class="line">    primarySwatch: Colors.blue,</span><br><span class="line">  ),</span><br><span class="line">  <span class="comment">//注册路由表</span></span><br><span class="line">  routes:&#123;</span><br><span class="line">   <span class="string">&quot;new_page&quot;</span>:(context) =&gt; NewRoute(),</span><br><span class="line">    ... <span class="comment">// 省略其它路由注册信息</span></span><br><span class="line">  &#125; ,</span><br><span class="line">  home: MyHomePage(title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>现在我们就完成了路由表的注册。上面的代码中<code>home</code>路由并没有使用命名路由，如果我们也想将<code>home</code>注册为命名路由应该怎么做呢？其实很简单，直接看代码：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">MaterialApp(</span><br><span class="line">  title: <span class="string">&#x27;Flutter Demo&#x27;</span>,</span><br><span class="line">  initialRoute:<span class="string">&quot;/&quot;</span>, <span class="comment">//名为&quot;/&quot;的路由作为应用的home(首页)</span></span><br><span class="line">  theme: ThemeData(</span><br><span class="line">    primarySwatch: Colors.blue,</span><br><span class="line">  ),</span><br><span class="line">  <span class="comment">//注册路由表</span></span><br><span class="line">  routes:&#123;</span><br><span class="line">   <span class="string">&quot;new_page&quot;</span>:(context) =&gt; NewRoute(),</span><br><span class="line">   <span class="string">&quot;/&quot;</span>:(context) =&gt; MyHomePage(title: <span class="string">&#x27;Flutter Demo Home Page&#x27;</span>), <span class="comment">//注册首页路由</span></span><br><span class="line">  &#125; </span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>可以看到，我们只需在路由表中注册一下<code>MyHomePage</code>路由，然后将其名字作为<code>MaterialApp</code>的<code>initialRoute</code>属性值即可，该属性决定应用的初始路由页是哪一个命名路由。</p>
<h3 id="通过路由名打开新路由页">通过路由名打开新路由页</h3>
<p>要通过路由名称来打开新路由，可以使用<code>Navigator</code> 的<code>pushNamed</code>方法：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Future pushNamed(BuildContext context, <span class="built_in">String</span> routeName,&#123;<span class="built_in">Object</span> arguments&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Navigator</code> 除了<code>pushNamed</code>方法，还有<code>pushReplacementNamed</code>等其他管理命名路由的方法，可以自行使用搜索引擎查看他们的作用。接下来我们通过路由名来打开新的路由页，修改<code>TextButton</code>的<code>onPressed</code>回调代码，改为：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">onPressed: () &#123;</span><br><span class="line">  Navigator.pushNamed(context, <span class="string">&quot;new_page&quot;</span>);</span><br><span class="line">  <span class="comment">//Navigator.push(context,</span></span><br><span class="line">  <span class="comment">//  MaterialPageRoute(builder: (context) &#123;</span></span><br><span class="line">  <span class="comment">//  return NewRoute();</span></span><br><span class="line">  <span class="comment">//&#125;));  </span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>热重载应用，再次点击“open new route”按钮，依然可以打开新的路由页。</p>
<h3 id="命名路由参数传递">命名路由参数传递</h3>
<p>在Flutter最初的版本中，命名路由是不能传递参数的，后来才支持了参数；下面展示命名路由如何传递并获取路由参数：</p>
<p>我们先注册一个路由：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">routes:&#123;</span><br><span class="line">  <span class="string">&quot;new_page&quot;</span>:(context) =&gt; EchoRoute(),</span><br><span class="line"> &#125; ,</span><br></pre></td></tr></table></figure>
<p>在路由页通过<code>RouteSetting</code>对象获取路由参数：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EchoRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="comment">//获取路由参数  </span></span><br><span class="line">    <span class="keyword">var</span> args=ModalRoute.of(context).settings.arguments;</span><br><span class="line">    <span class="comment">//...省略无关代码</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在打开路由时传递参数</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Navigator.of(context).pushNamed(<span class="string">&quot;new_page&quot;</span>, arguments: <span class="string">&quot;hi&quot;</span>);</span><br></pre></td></tr></table></figure>
<h3 id="PS-2">PS.</h3>
<p>关于一些路由的基本逻辑操作，可以参考<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/44650be76110">这篇博客</a></p>
<h1>布局逻辑</h1>
<p>在原生开发的时候一直提倡大家用LinearLayout，其中一个原因就是Flutter的默认布局逻辑基本就是LinearLayout，所以在原生使用相对布局的同学可能会比较难受，不过用习惯了就好，毕竟这个布局逻辑是很容易接受的。</p>
<p>如果大家看《Flutter实战》，在布局类组件（第四章）可以先忽略4.1和4.2，这两部分可能对大家来说特别陌生、难以接受，不过还是推荐了解一下SizedBox，这个容器简单好用。</p>
<p>下面主要说一下线性布局与弹性布局。</p>
<h2 id="线性布局">线性布局</h2>
<p>Flutter 中通过<code>Row</code>和<code>Column</code>来实现线性布局，类似于Android 中的<code>LinearLayout</code>控件。<code>Row</code>和<code>Column</code>都继承自<code>Flex</code>，我们将在弹性布局一节中详细介绍<code>Flex</code>。</p>
<h3 id="主轴和纵轴">主轴和纵轴</h3>
<p>对于线性布局，有<strong>主轴</strong>和<strong>纵轴</strong>之分，<strong>如果布局是沿水平方向，那么主轴就是指水平方向，而纵轴即垂直方向；如果布局沿垂直方向，那么主轴就是指垂直方向，而纵轴就是水平方向。在线性布局中，有两个定义对齐方式的枚举类<code>MainAxisAlignment</code>和<code>CrossAxisAlignment</code>，分别代表主轴对齐和纵轴对齐。</strong></p>
<h3 id="Row">Row</h3>
<p>Row可以沿水平方向排列其子widget。定义如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Row(&#123;</span><br><span class="line">  ...  </span><br><span class="line">  TextDirection textDirection,    </span><br><span class="line">  MainAxisSize mainAxisSize = MainAxisSize.max,    </span><br><span class="line">  MainAxisAlignment mainAxisAlignment = MainAxisAlignment.start,</span><br><span class="line">  VerticalDirection verticalDirection = VerticalDirection.down,  </span><br><span class="line">  CrossAxisAlignment crossAxisAlignment = CrossAxisAlignment.center,</span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li><code>textDirection</code>：表示水平方向子组件的布局顺序(是从左往右还是从右往左)，默认为系统当前Locale环境的文本方向(如中文、英语都是从左往右，而阿拉伯语是从右往左)。</li>
<li><code>mainAxisSize</code>：<strong>表示<code>Row</code>在主轴(水平)方向占用的空间</strong>，默认是<code>MainAxisSize.max</code>，表示尽可能多的占用水平方向的空间，此时无论子 widgets 实际占用多少水平空间，<code>Row</code>的宽度始终等于水平方向的最大宽度；而<code>MainAxisSize.min</code>表示尽可能少的占用水平空间，当子组件没有占满水平剩余空间，则<code>Row</code>的实际宽度等于所有子组件占用的的水平空间；</li>
<li><code>mainAxisAlignment</code>：<strong>表示子组件在<code>Row</code>所占用的水平空间内对齐方式</strong>，如果<code>mainAxisSize</code>值为<code>MainAxisSize.min</code>，则此属性无意义，因为子组件的宽度等于<code>Row</code>的宽度。只有当<code>mainAxisSize</code>的值为<code>MainAxisSize.max</code>时，此属性才有意义，<code>MainAxisAlignment.start</code>表示沿<code>textDirection</code>的初始方向对齐，如<code>textDirection</code>取值为<code>TextDirection.ltr</code>时，则<code>MainAxisAlignment.start</code>表示左对齐，<code>textDirection</code>取值为<code>TextDirection.rtl</code>时表示从右对齐。而<code>MainAxisAlignment.end</code>和<code>MainAxisAlignment.start</code>正好相反；<code>MainAxisAlignment.center</code>表示居中对齐。读者可以这么理解：<code>textDirection</code>是<code>mainAxisAlignment</code>的参考系。</li>
<li><code>verticalDirection</code>：表示<code>Row</code>纵轴（垂直）的对齐方向，默认是<code>VerticalDirection.down</code>，表示从上到下。</li>
<li><code>crossAxisAlignment</code>：表示子组件在纵轴方向的对齐方式，<code>Row</code>的高度等于子组件中最高的子元素高度，它的取值和<code>MainAxisAlignment</code>一样(包含<code>start</code>、<code>end</code>、 <code>center</code>三个值)，不同的是<code>crossAxisAlignment</code>的参考系是<code>verticalDirection</code>，即<code>verticalDirection</code>值为<code>VerticalDirection.down</code>时<code>crossAxisAlignment.start</code>指顶部对齐，<code>verticalDirection</code>值为<code>VerticalDirection.up</code>时，<code>crossAxisAlignment.start</code>指底部对齐；而<code>crossAxisAlignment.end</code>和<code>crossAxisAlignment.start</code>正好相反；</li>
<li><strong><code>children</code> ：子组件数组。</strong></li>
</ul>
<h3 id="示例-2">示例</h3>
<p>请阅读下面代码，先想象一下运行的结果：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Column(</span><br><span class="line">  <span class="comment">//测试Row对齐方式，排除Column默认居中对齐的干扰</span></span><br><span class="line">  crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">  children: &lt;Widget&gt;[</span><br><span class="line">    Row(</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">&quot; hello world &quot;</span>),</span><br><span class="line">        Text(<span class="string">&quot; I am Jack &quot;</span>),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">    Row(</span><br><span class="line">      mainAxisSize: MainAxisSize.min,</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.center,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">&quot; hello world &quot;</span>),</span><br><span class="line">        Text(<span class="string">&quot; I am Jack &quot;</span>),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">    Row(</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.end,</span><br><span class="line">      textDirection: TextDirection.rtl,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">&quot; hello world &quot;</span>),</span><br><span class="line">        Text(<span class="string">&quot; I am Jack &quot;</span>),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">    Row(</span><br><span class="line">      crossAxisAlignment: CrossAxisAlignment.start,  </span><br><span class="line">      verticalDirection: VerticalDirection.up,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">&quot; hello world &quot;</span>, style: TextStyle(fontSize: <span class="number">30.0</span>),),</span><br><span class="line">        Text(<span class="string">&quot; I am Jack &quot;</span>),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">  ],</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>实际运行结果如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="3.png" alt=""></p>
<p>解释：第一个<code>Row</code>很简单，默认为居中对齐；第二个<code>Row</code>，由于<code>mainAxisSize</code>值为<code>MainAxisSize.min</code>，<code>Row</code>的宽度等于两个<code>Text</code>的宽度和，所以对齐是无意义的，所以会从左往右显示；第三个<code>Row</code>设置<code>textDirection</code>值为<code>TextDirection.rtl</code>，所以子组件会从右向左的顺序排列，而此时<code>MainAxisAlignment.end</code>表示左对齐，所以最终显示结果就是图中第三行的样子；第四个 Row 测试的是纵轴的对齐方式，由于两个子 Text 字体不一样，所以其高度也不同，我们指定了<code>verticalDirection</code>值为<code>VerticalDirection.up</code>，即从低向顶排列，而此时<code>crossAxisAlignment</code>值为<code>CrossAxisAlignment.start</code>表示底对齐。</p>
<h3 id="Column">Column</h3>
<p><code>Column</code>可以在垂直方向排列其子组件。参数和<code>Row</code>一样，不同的是布局方向为垂直，主轴纵轴正好相反，读者可类比<code>Row</code>来理解，下面看一个例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&#x27;package:flutter/material.dart&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CenterColumnRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">        Text(<span class="string">&quot;world&quot;</span>),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="4.png" alt=""></p>
<p>解释：</p>
<ul>
<li>由于我们没有指定<code>Column</code>的<code>mainAxisSize</code>，所以使用默认值<code>MainAxisSize.max</code>，则<code>Column</code>会在垂直方向占用尽可能多的空间，此例中会占满整个屏幕高度。</li>
<li>由于我们指定了 <code>crossAxisAlignment</code> 属性为<code>CrossAxisAlignment.center</code>，那么子项在<code>Column</code>纵轴方向（此时为水平方向）会居中对齐。注意，在水平方向对齐是有边界的，总宽度为<code>Column</code>占用空间的实际宽度，而实际的宽度取决于子项中宽度最大的Widget。在本例中，<code>Column</code>有两个子Widget，而显示“world”的<code>Text</code>宽度最大，所以<code>Column</code>的实际宽度则为<code>Text(&quot;world&quot;)</code> 的宽度，所以居中对齐后<code>Text(&quot;hi&quot;)</code>会显示在<code>Text(&quot;world&quot;)</code>的中间部分。</li>
</ul>
<p><strong>实际上，<code>Row</code>和<code>Column</code>都只会在主轴方向占用尽可能大的空间，而纵轴的长度则取决于他们最大子元素的长度</strong>。如果我们想让本例中的两个文本控件在整个手机屏幕中间对齐，我们有两种方法：</p>
<ul>
<li>
<p>将<code>Column</code>的宽度指定为屏幕宽度；这很简单，我们可以通过<code>ConstrainedBox</code>或<code>SizedBox</code>（我们将在后面章节中专门介绍这两个Widget）来强制更改宽度限制，例如：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ConstrainedBox(</span><br><span class="line">  constraints: BoxConstraints(minWidth: <span class="built_in">double</span>.infinity), </span><br><span class="line">  child: Column(</span><br><span class="line">    crossAxisAlignment: CrossAxisAlignment.center,</span><br><span class="line">    children: &lt;Widget&gt;[</span><br><span class="line">      Text(<span class="string">&quot;hi&quot;</span>),</span><br><span class="line">      Text(<span class="string">&quot;world&quot;</span>),</span><br><span class="line">    ],</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>将<code>minWidth</code>设为<code>double.infinity</code>，可以使宽度占用尽可能多的空间。</p>
</li>
<li>
<p>使用<code>Center</code> 组件；将在后面章节中介绍。</p>
</li>
</ul>
<h3 id="特殊情况">特殊情况</h3>
<p>如果<code>Row</code>里面嵌套<code>Row</code>，或者<code>Column</code>里面再嵌套<code>Column</code>，那么只有最外面的<code>Row</code>或<code>Column</code>会占用尽可能大的空间，里面<code>Row</code>或<code>Column</code>所占用的空间为实际大小，下面以<code>Column</code>为例说明：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">Container(</span><br><span class="line">  color: Colors.green,</span><br><span class="line">  child: Padding(</span><br><span class="line">    padding: <span class="keyword">const</span> EdgeInsets.all(<span class="number">16.0</span>),</span><br><span class="line">    child: Column(</span><br><span class="line">      crossAxisAlignment: CrossAxisAlignment.start,</span><br><span class="line">      mainAxisSize: MainAxisSize.max, <span class="comment">//有效，外层Colum高度为整个屏幕</span></span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Container(</span><br><span class="line">          color: Colors.red,</span><br><span class="line">          child: Column(</span><br><span class="line">            mainAxisSize: MainAxisSize.max,<span class="comment">//无效，内层Colum高度为实际高度  </span></span><br><span class="line">            children: &lt;Widget&gt;[</span><br><span class="line">              Text(<span class="string">&quot;hello world &quot;</span>),</span><br><span class="line">              Text(<span class="string">&quot;I am Jack &quot;</span>),</span><br><span class="line">            ],</span><br><span class="line">          ),</span><br><span class="line">        )</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>运行效果如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="5.png" alt=""></p>
<p>如果要让里面的<code>Column</code>占满外部<code>Column</code>，可以使用<code>Expanded</code> 组件：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Expanded( </span><br><span class="line">  child: Container(</span><br><span class="line">    color: Colors.red,</span><br><span class="line">    child: Column(</span><br><span class="line">      mainAxisAlignment: MainAxisAlignment.center, <span class="comment">//垂直方向居中对齐</span></span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        Text(<span class="string">&quot;hello world &quot;</span>),</span><br><span class="line">        Text(<span class="string">&quot;I am Jack &quot;</span>),</span><br><span class="line">      ],</span><br><span class="line">    ),</span><br><span class="line">  ),</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>运行效果如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="6.png" alt=""></p>
<p>我们将在介绍弹性布局时详细介绍Expanded。</p>
<h2 id="弹性布局">弹性布局</h2>
<p>弹性布局允许子组件按照一定比例来分配父容器空间。弹性布局的概念在其它UI系统中也都存在，如 H5 中的弹性盒子布局，Android中 的<code>FlexboxLayout</code>等。Flutter 中的弹性布局主要通过<code>Flex</code>和<code>Expanded</code>来配合实现。</p>
<h3 id="Flex">Flex</h3>
<p><code>Flex</code>组件可以沿着水平或垂直方向排列子组件，如果你知道主轴方向，使用<code>Row</code>或<code>Column</code>会方便一些，<strong>因为<code>Row</code>和<code>Column</code>都继承自<code>Flex</code></strong>，参数基本相同，所以能使用Flex的地方基本上都可以使用<code>Row</code>或<code>Column</code>。<code>Flex</code>本身功能是很强大的，它也可以和<code>Expanded</code>组件配合实现弹性布局。接下来我们只讨论<code>Flex</code>和弹性布局相关的属性(其它属性已经在介绍<code>Row</code>和<code>Column</code>时介绍过了)。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Flex(&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">required</span> <span class="keyword">this</span>.direction, <span class="comment">//弹性布局的方向, Row默认为水平方向，Column默认为垂直方向</span></span><br><span class="line">  <span class="built_in">List</span>&lt;Widget&gt; children = <span class="keyword">const</span> &lt;Widget&gt;[],</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>Flex</code>继承自<code>MultiChildRenderObjectWidget</code>，对应的<code>RenderObject</code>为<code>RenderFlex</code>，<code>RenderFlex</code>中实现了其布局算法。</p>
<h3 id="Expanded">Expanded</h3>
<p><strong>Expanded 只能作为 Flex 的孩子（否则会报错）</strong>，它可以按比例“扩伸”<code>Flex</code>子组件所占用的空间。因为 <code>Row</code>和<code>Column</code> 继都承自Flex，所以 Expanded 也可以作为它们的孩子。</p>
<p>也就是说，Expanded组件必须用在Row、Column、Flex内，并且从Expanded到封装它的Row、Column、Flex的路径必须只包括StatelessWidgets或StatefulWidgets组件(不能是其他类型的组件，像RenderObjectWidget，它是渲染对象，不再改变尺寸了，因此Expanded不能放进RenderObjectWidget)。</p>
<p>注意一点：在Row中使用Expanded的时候，无法指定Expanded中的子组件的宽度width，但可以指定其高度height。同理，在Column中使用Expanded的时候，无法指定Expanded中的子组件的高度height，可以指定宽度width。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> Expanded(&#123;</span><br><span class="line">  <span class="built_in">int</span> flex = <span class="number">1</span>, </span><br><span class="line">  <span class="keyword">required</span> Widget child,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><code>flex</code>参数为弹性系数，如果为 0 或<code>null</code>，则<code>child</code>是没有弹性的，即不会被扩伸占用的空间。如果大于0，所有的<code>Expanded</code>按照其 flex 的比例来分割主轴的全部空闲空间。下面我们看一个例子：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FlexLayoutTestRoute</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Column(</span><br><span class="line">      children: &lt;Widget&gt;[</span><br><span class="line">        <span class="comment">//Flex的两个子widget按1：2来占据水平空间  </span></span><br><span class="line">        Flex(</span><br><span class="line">          direction: Axis.horizontal,</span><br><span class="line">          children: &lt;Widget&gt;[</span><br><span class="line">            Expanded(</span><br><span class="line">              flex: <span class="number">1</span>,</span><br><span class="line">              child: Container(</span><br><span class="line">                height: <span class="number">30.0</span>,</span><br><span class="line">                color: Colors.red,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">            Expanded(</span><br><span class="line">              flex: <span class="number">2</span>,</span><br><span class="line">              child: Container(</span><br><span class="line">                height: <span class="number">30.0</span>,</span><br><span class="line">                color: Colors.green,</span><br><span class="line">              ),</span><br><span class="line">            ),</span><br><span class="line">          ],</span><br><span class="line">        ),</span><br><span class="line">        Padding(</span><br><span class="line">          padding: <span class="keyword">const</span> EdgeInsets.only(top: <span class="number">20.0</span>),</span><br><span class="line">          child: SizedBox(</span><br><span class="line">            height: <span class="number">100.0</span>,</span><br><span class="line">            <span class="comment">//Flex的三个子widget，在垂直方向按2：1：1来占用100像素的空间  </span></span><br><span class="line">            child: Flex(</span><br><span class="line">              direction: Axis.vertical,</span><br><span class="line">              children: &lt;Widget&gt;[</span><br><span class="line">                Expanded(</span><br><span class="line">                  flex: <span class="number">2</span>,</span><br><span class="line">                  child: Container(</span><br><span class="line">                    height: <span class="number">30.0</span>,</span><br><span class="line">                    color: Colors.red,</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">                Spacer(</span><br><span class="line">                  flex: <span class="number">1</span>,</span><br><span class="line">                ),</span><br><span class="line">                Expanded(</span><br><span class="line">                  flex: <span class="number">1</span>,</span><br><span class="line">                  child: Container(</span><br><span class="line">                    height: <span class="number">30.0</span>,</span><br><span class="line">                    color: Colors.green,</span><br><span class="line">                  ),</span><br><span class="line">                ),</span><br><span class="line">              ],</span><br><span class="line">            ),</span><br><span class="line">          ),</span><br><span class="line">        ),</span><br><span class="line">      ],</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行效果如图所示：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="7.png" alt="弹性布局"></p>
<p>示例中的<code>Spacer</code>的功能是占用指定比例的空间，实际上它只是<code>Expanded</code>的一个包装类，<code>Spacer</code>的源码如下：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spacer</span> <span class="keyword">extends</span> <span class="title">StatelessWidget</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> Spacer(&#123;Key? key, <span class="keyword">this</span>.flex = <span class="number">1</span>&#125;)</span><br><span class="line">    : <span class="keyword">assert</span>(flex != <span class="keyword">null</span>),</span><br><span class="line">      <span class="keyword">assert</span>(flex &gt; <span class="number">0</span>),</span><br><span class="line">      <span class="keyword">super</span>(key: key);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">final</span> <span class="built_in">int</span> flex;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@override</span></span><br><span class="line">  Widget build(BuildContext context) &#123;</span><br><span class="line">    <span class="keyword">return</span> Expanded(</span><br><span class="line">      flex: flex,</span><br><span class="line">      child: <span class="keyword">const</span> SizedBox.shrink(),</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="小结">小结</h3>
<p>弹性布局比较简单，唯一需要注意的就是<code>Row</code>、<code>Column</code>以及<code>Flex</code>的关系。</p>
<p>Expanded经常会出现应用不正确的报错，一般是将Expanded用在了一个无界widget中导致渲染器报错，大家多去尝试、踩坑。</p>
<p>可以参考<a target="_blank" rel="noopener" href="https://blog.csdn.net/devnn/article/details/105892081">这个博客</a>去了解一些expanded与col和row的组合使用</p>
<h3 id="PS-3">PS.</h3>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903857697325069">占位 Spacer()</a>,以及<a target="_blank" rel="noopener" href="https://www.youtube.com/watch?v=7FJgd7QN1zI">油管教学</a></p>
<h1>状态管理</h1>
<p>这里提一嘴状态管理，但是初期遇到的状态管理问题可能并不多。</p>
<p>响应式的编程框架中都会有一个永恒的主题——“状态(State)管理”，无论是在 React/Vue（两者都是支持响应式编程的 Web 开发框架）还是 Flutter 中，他们讨论的问题和解决的思想都是一致的。所以，<code>StatefulWidget</code>的状态应该被谁管理？Widget本身？父 Widget ？都会？还是另一个对象？答案是取决于实际情况！以下是管理状态的最常见的方法：</p>
<ul>
<li>Widget 管理自己的状态。</li>
<li>Widget 管理子 Widget 状态。</li>
<li>混合管理（父 Widget 和子 Widget 都管理状态）。</li>
</ul>
<p>实际上，还是以计数器为例，一个很经典的问题就是，点击加号之后如何更新界面？如果你使用setState，当然可以，但是会将整个widget树都更新一遍，但是实际上我们很明确只会更新树中的一个节点的属性，这是很浪费性能的。在者，若果在一个界面上改变了某个值，如何在其余界面上将这个改变表现出来？或者说，如何通知其他界面更新这个值？这都是状态管理的问题。或许你可以重新跳转到那个界面，但同样地，如果这个界面本就在路由栈中，重新构建这个界面会浪费性能，而且可能导致路由错乱。</p>
<p>为此，开发者们可谓耗尽心机，为此做了很多库，比如Provider和GetX，都是很好用的状态管理库，如果有兴趣可以尝试，GetX优先。</p>
<p>参考资料：</p>
<blockquote>
<p><a target="_blank" rel="noopener" href="https://book.flutterchina.club/">《Flutter实战·第二版》</a></p>
<p><a target="_blank" rel="noopener" href="https://flutterchina.club/">Flutter中文网</a></p>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903857697325069">https://juejin.cn/post/6844903857697325069</a></p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tian874540961/p/10515020.html">https://www.cnblogs.com/tian874540961/p/10515020.html</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ZWN2001.github.io">ZWN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwn2001.github.io/2022/01/07/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD-winter-flutter-1/">https://zwn2001.github.io/2022/01/07/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD-winter-flutter-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ZWN2001.github.io" target="_blank">ZWN's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E7%A7%BB%E5%8A%A8/">移动</a></div><div class="post_share"><div class="social-share" data-image="/img/cover1/38.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/01/01/2022-new-year/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/6-min.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2022:new_year</div></div></a></div><div class="next-post pull-right"><a href="/2022/01/10/mix-code-flutter-cpp%EF%BC%9A%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/7.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">mix-code_flutter-cpp</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/02/26/2022-sdu-online-core-member-interview/" title="2022_sdu_online_core_member_interview"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/27.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-02-26</div><div class="title">2022_sdu_online_core_member_interview</div></div></a></div><div><a href="/2022/04/20/flutter-context/" title="flutter-context"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/7-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-20</div><div class="title">flutter-context</div></div></a></div><div><a href="/2022/04/20/flutter-key/" title="学线培训：flutter-key"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/17-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-20</div><div class="title">学线培训：flutter-key</div></div></a></div><div><a href="/2022/01/26/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD-winter-flutter-%E7%BD%91%E7%BB%9C%E3%80%81%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/" title="学线培训:winter-flutter:网络、同步与异步"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/10.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-26</div><div class="title">学线培训:winter-flutter:网络、同步与异步</div></div></a></div><div><a href="/2022/01/17/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD%EF%BC%9Awinter-flutter%EF%BC%9AMethodChannel%E4%B8%8E%E6%A1%8C%E9%9D%A2%E7%BB%84%E4%BB%B6/" title="学线培训：winter-flutter：PlatformChannel与桌面组件"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/21-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-17</div><div class="title">学线培训：winter-flutter：PlatformChannel与桌面组件</div></div></a></div><div><a href="/2022/05/16/%E5%AD%A6%E7%BA%BF%E7%A7%BB%E5%8A%A8%E7%9A%84%E4%B8%A4%E5%B9%B4-%E5%AE%89%E5%8D%93%E4%BB%8E%E5%B0%8F%E7%99%BD%E5%88%B0%E8%BF%9B%E9%98%B6/" title="学线移动的两年：安卓从小白到进阶"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/12-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-16</div><div class="title">学线移动的两年：安卓从小白到进阶</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZWN</div><div class="author-info__description">我虽无意逐鹿，却知苍生苦楚</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">94</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZWN2001"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZWN2001" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">建议使用无痕模式以更快地得到更新，或者访问新站https://zwn-2001-github-io.vercel.app/而非github page,github page将在九月停止运营</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">Widget 简介（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Widget-%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">Widget 概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Flutter%E4%B8%AD%E7%9A%84%E5%9B%9B%E6%A3%B5%E6%A0%91%EF%BC%88%E6%AF%94%E8%BE%83%E6%8A%BD%E8%B1%A1%EF%BC%8C%E5%B0%BD%E9%87%8F%E7%90%86%E8%A7%A3%E5%8D%B3%E5%8F%AF%EF%BC%89"><span class="toc-number">1.2.</span> <span class="toc-text">Flutter中的四棵树（比较抽象，尽量理解即可）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Context"><span class="toc-number">1.3.</span> <span class="toc-text">Context</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87Context%E8%8E%B7%E5%8F%96State%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.3.1.</span> <span class="toc-text">通过Context获取State对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#StatefulWidget-%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%EF%BC%9A"><span class="toc-number">1.4.</span> <span class="toc-text">StatefulWidget 生命周期：</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">热重载</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">路由管理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Navigator"><span class="toc-number">3.1.</span> <span class="toc-text">Navigator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Future-push-BuildContext-context-Route-route"><span class="toc-number">3.1.1.</span> <span class="toc-text">Future push(BuildContext context, Route route)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#bool-pop-BuildContext-context-result"><span class="toc-number">3.1.2.</span> <span class="toc-text">bool pop(BuildContext context, [ result ])</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PS"><span class="toc-number">3.1.3.</span> <span class="toc-text">PS.</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95"><span class="toc-number">3.1.3.1.</span> <span class="toc-text">实例方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E4%BC%A0%E5%80%BC"><span class="toc-number">3.2.</span> <span class="toc-text">路由传值</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1"><span class="toc-number">3.3.</span> <span class="toc-text">命名路由</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="toc-number">3.3.1.</span> <span class="toc-text">路由表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E5%86%8C%E8%B7%AF%E7%94%B1%E8%A1%A8"><span class="toc-number">3.3.2.</span> <span class="toc-text">注册路由表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E8%B7%AF%E7%94%B1%E5%90%8D%E6%89%93%E5%BC%80%E6%96%B0%E8%B7%AF%E7%94%B1%E9%A1%B5"><span class="toc-number">3.3.3.</span> <span class="toc-text">通过路由名打开新路由页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D%E8%B7%AF%E7%94%B1%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.3.4.</span> <span class="toc-text">命名路由参数传递</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PS-2"><span class="toc-number">3.3.5.</span> <span class="toc-text">PS.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">布局逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%B8%83%E5%B1%80"><span class="toc-number">4.1.</span> <span class="toc-text">线性布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BB%E8%BD%B4%E5%92%8C%E7%BA%B5%E8%BD%B4"><span class="toc-number">4.1.1.</span> <span class="toc-text">主轴和纵轴</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Row"><span class="toc-number">4.1.2.</span> <span class="toc-text">Row</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">4.1.3.</span> <span class="toc-text">示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Column"><span class="toc-number">4.1.4.</span> <span class="toc-text">Column</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E6%83%85%E5%86%B5"><span class="toc-number">4.1.5.</span> <span class="toc-text">特殊情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%B9%E6%80%A7%E5%B8%83%E5%B1%80"><span class="toc-number">4.2.</span> <span class="toc-text">弹性布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Flex"><span class="toc-number">4.2.1.</span> <span class="toc-text">Flex</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Expanded"><span class="toc-number">4.2.2.</span> <span class="toc-text">Expanded</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%8F%E7%BB%93"><span class="toc-number">4.2.3.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PS-3"><span class="toc-number">4.2.4.</span> <span class="toc-text">PS.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">状态管理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/17/myBatis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%93/" title="myBatis+springboot从入门到删库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/39.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="myBatis+springboot从入门到删库"/></a><div class="content"><a class="title" href="/2022/07/17/myBatis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%93/" title="myBatis+springboot从入门到删库">myBatis+springboot从入门到删库</a><time datetime="2022-07-17T12:15:52.000Z" title="发表于 2022-07-17 20:15:52">2022-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/11/%E5%9F%9F%E6%A8%A1%E5%9E%8B%E3%80%81DDD%E3%80%81CQRS%E4%B8%8E12306%E7%9A%84%E8%AE%BE%E8%AE%A1/" title="域模型、DDD、CQRS与12306的设计"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/34.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="域模型、DDD、CQRS与12306的设计"/></a><div class="content"><a class="title" href="/2022/07/11/%E5%9F%9F%E6%A8%A1%E5%9E%8B%E3%80%81DDD%E3%80%81CQRS%E4%B8%8E12306%E7%9A%84%E8%AE%BE%E8%AE%A1/" title="域模型、DDD、CQRS与12306的设计">域模型、DDD、CQRS与12306的设计</a><time datetime="2022-07-11T11:39:51.000Z" title="发表于 2022-07-11 19:39:51">2022-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/11/Python%E7%88%AC12306%E4%BD%99%E7%A5%A8/" title="Python爬12306余票"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/2-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python爬12306余票"/></a><div class="content"><a class="title" href="/2022/07/11/Python%E7%88%AC12306%E4%BD%99%E7%A5%A8/" title="Python爬12306余票">Python爬12306余票</a><time datetime="2022-07-11T03:24:04.000Z" title="发表于 2022-07-11 11:24:04">2022-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/06/Python%E5%B0%8F%E6%8A%84/" title="Python小抄"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/11.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python小抄"/></a><div class="content"><a class="title" href="/2022/07/06/Python%E5%B0%8F%E6%8A%84/" title="Python小抄">Python小抄</a><time datetime="2022-07-06T08:18:57.000Z" title="发表于 2022-07-06 16:18:57">2022-07-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/06/cpp%E5%B0%8F%E6%8A%84/" title="cpp小抄"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/9-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="cpp小抄"/></a><div class="content"><a class="title" href="/2022/07/06/cpp%E5%B0%8F%E6%8A%84/" title="cpp小抄">cpp小抄</a><time datetime="2022-07-06T08:18:57.000Z" title="发表于 2022-07-06 16:18:57">2022-07-06</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/cover1/38.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By ZWN</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">喵喵喵？</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '7MlJqmD9Ceux2bxiKqPqsMHW-gzGzoHsz',
      appKey: '3oP9XaednBAwtfMk2q28dwGP',
      avatar: 'retro',
      serverURLs: 'https://7mljqmd9.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="app-refresh" id="app-refresh"> <div class="app-refresh-wrap"> <label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" onclick="location.reload()">点击刷新</a> </div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"点击刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>