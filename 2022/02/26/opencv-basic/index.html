<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>opencv_basic | ZWN's blog</title><meta name="keywords" content="Python,opencv"><meta name="author" content="ZWN"><meta name="copyright" content="ZWN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="图像基本操作 读取图像 1retval &#x3D;cv2.imread (filename[,flags])  可以使用相对路径，如：  也可以使用绝对路径。 显示图像  在显示图像中，还涉及其他函数   以下的很多例子里都会见到这几个函数 保存图像  图像处理基础 基本图像 二值图 仅包含黑色和白色，用01进行表示。 灰度图 可以在读取时将参数设为0，即为灰度图 ​        通常， 计算机会将灰度">
<meta property="og:type" content="article">
<meta property="og:title" content="opencv_basic">
<meta property="og:url" content="https://zwn2001.github.io/2022/02/26/opencv-basic/index.html">
<meta property="og:site_name" content="ZWN&#39;s blog">
<meta property="og:description" content="图像基本操作 读取图像 1retval &#x3D;cv2.imread (filename[,flags])  可以使用相对路径，如：  也可以使用绝对路径。 显示图像  在显示图像中，还涉及其他函数   以下的很多例子里都会见到这几个函数 保存图像  图像处理基础 基本图像 二值图 仅包含黑色和白色，用01进行表示。 灰度图 可以在读取时将参数设为0，即为灰度图 ​        通常， 计算机会将灰度">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zwn2001.github.io/img/cover1/35.jpg">
<meta property="article:published_time" content="2022-02-26T11:12:12.000Z">
<meta property="article:modified_time" content="2022-07-01T12:54:08.711Z">
<meta property="article:author" content="ZWN">
<meta property="article:tag" content="Python">
<meta property="article:tag" content="opencv">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zwn2001.github.io/img/cover1/35.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zwn2001.github.io/2022/02/26/opencv-basic/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: ZWN","link":"链接: ","source":"来源: ZWN's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'opencv_basic',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-01 20:54:08'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover1/35.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZWN's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">opencv_basic</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-02-26T11:12:12.000Z" title="发表于 2022-02-26 19:12:12">2022-02-26</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-01T12:54:08.711Z" title="更新于 2022-07-01 20:54:08">2022-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/cv/">cv</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">30.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>108分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="opencv_basic"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>图像基本操作</h1>
<h2 id="读取图像">读取图像</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">retval =cv2.imread (filename[,flags])</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imread.png" style="zoom: 80%;" />
<p>可以使用相对路径，如：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="51.png" style="zoom: 70%;" />
<p>也可以使用绝对路径。</p>
<h2 id="显示图像">显示图像</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imshow.png" style="zoom: 100%;" />
<p>在显示图像中，还涉及其他函数</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="waitkey.png" style="zoom: 80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="destroyWindow.png" style="zoom: 80%;" />
<p>以下的很多例子里都会见到这几个函数</p>
<h2 id="保存图像">保存图像</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="imwrite.png" style="zoom: 80%;" />
<h1>图像处理基础</h1>
<h2 id="基本图像">基本图像</h2>
<h3 id="二值图">二值图</h3>
<p>仅包含黑色和白色，用01进行表示。</p>
<h3 id="灰度图">灰度图</h3>
<p><strong>可以在读取时将参数设为0，即为灰度图</strong></p>
<p>​        通常， 计算机会将灰度处理为256个灰度级， 用数值区间[0,255]来表示。 其中， 数值”255”表示纯白色， 数值”0”表示纯黑色， 其余的数值表示从纯白到纯黑之间不同级别的灰度。用于表示256个灰度级的数值0~255, 正好可以用一个字节(8位二进制值）来表示。 <strong>所以灰度图一定是单通道的</strong></p>
<h3 id="彩图（以RGB色彩空间为例）">彩图（以RGB色彩空间为例）</h3>
<p><strong>读取时参数为1，或者省略</strong></p>
<p>​       在 RGB 色彩空间中， 存在 R (red, 红色）通道、 G (green, 绿色）通道和 B (blue, 蓝色）通<br>
道， 共三个通道。 每个色彩通道值的范围都在[0,255]之间 ， 我们用这三个色彩通道的组合表示颜色。<br>
以比较通俗的方式来解释就是， 有三个油漆桶， 分别装了红色、 绿色、 蓝色的油漆， 我们分别从每个油漆桶中取容星为0~255个单位的不等星的油漆， 将三种油漆混合就可以调配出一种新的颜色。三种油漆经过不同的组合， 共可以调配出所有常见的256x256x256=16 777 216种颜色。</p>
<p>​       通常用一个三维数组来表示一幅RGB色彩空间的彩色图像。一般情况下 ， 在RGB色彩空间中， 图像通道的顺序是R➔G➔B, 即第1个通道是R通道 ， 第2个通道是G通道， 第3个通道是B通道。 <strong>需要特别注意的是， 在OpenCV中， 通道的顺序是B➔G➔R</strong>。</p>
<h2 id="像素处理">像素处理</h2>
<p>​        需要说明的是 ， 在OpenCV中， 最小的数据类型是无符号的8位数。 因此 ， 在OpenCV中实际上并没有二值图像这种数据类型， 二值图像经常是通过处理得到的 ， 然后使用0表示黑色， 使用255表示白色。</p>
<p>​        可以将二值图像理解为特殊的灰度图像， 这里仅以灰度图像为例讨论像素的读取和修改。 通过2.1节的分析可知， 可以将图像理解为一个矩阵，在面向Python的OpenCV(Open CV for Python)中，<strong>图像就是 Numpy 库中的数组</strong>。 一个 OpenCV 灰度图像是一个二维数组， 可以使用表达式访间其中的像素值。 例如， 可以使用image[0,0]访间图像image第0行第0列位置上的像素点。 第0行第0列位于图像的左上角 ， 其中第1个索引表示第0行， 第2个索引表示第0列。</p>
<p>​         同样地，彩图就是三维数组，分别是BGR三个二维数组。（RGB色彩空间）。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="0.png" style="zoom: 80%;" />
<p>这部分建议多学numpy。</p>
<h2 id="通道操作（基于RGB）">通道操作（基于RGB）</h2>
<h3 id="通道拆分">通道拆分</h3>
<h4 id="通过索引拆分-numpy">通过索引拆分(numpy)</h4>
<p>如下语句分别从中提取了B通道、 G通道、 R通道。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b=img[: ,: ,O]</span><br><span class="line">g=img[: ,: ,<span class="number">1</span>]</span><br><span class="line">r=img[: ,: ,<span class="number">2</span>] </span><br></pre></td></tr></table></figure>
<h4 id="通过函数拆分">通过函数拆分</h4>
<p>函数<code>cv2.split()</code>能够拆分图像的通道。 例如， 可以使用如下语句拆分彩色BGR图像img, 得到B通道图像b、 G通道图像g和R通道图像r。</p>
<p><code>b,g,r=cv2.split (img) </code></p>
<p>上述语句与如下语句是等价的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b = cv2.split (a) [<span class="number">0</span>]</span><br><span class="line">g = cv2.split (a) [<span class="number">1</span>]</span><br><span class="line">r = cv2.split (a) [<span class="number">2</span>]</span><br></pre></td></tr></table></figure>
<h3 id="通道合并">通道合并</h3>
<p>通道合并是通道拆分的逆过程， 通过合并通道可以将三个通道的灰度图像构成一幅彩色图像。 函数cv2.merge(）可以实现图像通道的合并， 例如有B通道图像b、 G通道图像g和R通道图像r, 使用函数<code>cv2.merge()</code>可以将这三个通道合并为一幅BGR的三通道彩色图像。 其实现的语句为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bgr=cv2.merge ([b,g,r]) </span><br></pre></td></tr></table></figure>
<p>如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = cv2.imread(<span class="string">&quot;image\\0.png&quot;</span>)</span><br><span class="line">    b, g, r = cv2.split(src)</span><br><span class="line">    bgr = cv2.merge([b, g, r])</span><br><span class="line">    cv2.imshow(<span class="string">&quot;dst&quot;</span>,bgr)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h2 id="图像属性">图像属性</h2>
<p>在图像处理过程中， 经常需要获取图像的属性， 例如图像的大小。</p>
<ul>
<li>
<p>shape: 如果是彩色图像， 则返回包含行数 列数 通道数的数组；如果是二值图像或者灰度图像， 则仅返回行数和列数。 通过该属性的返回值是否包含通道数， 可以判断一幅图像是灰度图像（或二值图像）还是彩色图像。</p>
</li>
<li>
<p>size：返回图像的像素数目。 其值为行x列x通道数”， 灰度图像或者二值图像的通道数为1。</p>
</li>
</ul>
<h1>图像运算</h1>
<h2 id="加法">加法</h2>
<h3 id="加号运算符">加号运算符</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="1.png" style="zoom: 80%;" />
<h3 id="add-函数"><code>add()</code>函数</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2.png" style="zoom: 80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="3.png" style="zoom: 80%;" />
<h3 id="加权和">加权和</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="4.png" style="zoom: 80%;" />
<h2 id="按位逻辑">按位逻辑</h2>
<h3 id="按位与">按位与</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="5.png" style="zoom: 80%;" />
<p>任何数与0都是0，与255则不变，都是二进制的按位与</p>
<h3 id="按位或与按位非、按位异或">按位或与按位非、按位异或</h3>
<p>与按位与类似。</p>
<p>按位或：<code>dst = cv2.bitwise_or(src[,mask])</code></p>
<p>按位非：<code>dst = cv2.bitwise_not(src[,mask])</code></p>
<p>按位异或：<code>dst = cv2.bitwise_xor(src[,mask])</code></p>
<h3 id="掩模">掩模</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="6.png" style="zoom: 80%;" />
<p>可以理解为结果在返回前与掩模进行了按位与。</p>
<h2 id="图像与数值的运算">图像与数值的运算</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="7.png" style="zoom: 80%;" />
<h2 id="位平面分解与其应用">位平面分解与其应用</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="8.png" style="zoom: 80%;" />
<p>例子：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="9.png" style="zoom: 80%;" />
<h3 id="应用：加解密与数字水印">应用：加解密与数字水印</h3>
<p>加解密是使用密钥图像对原图进行位运算，数字水印是在最低位平面嵌入信息，因为这样对原图影响最小。</p>
<p>这里仅介绍了原始载体图像为灰度图像的情况，在实际中可以根据需要在多个通道内嵌入相同的水印（提高鲁棒性，即使部分水印丢失，也能提取出完整水印信息），或在各个不同的通道内嵌入不同的水印（提高嵌入容量）。在彩色图像的多个通道内嵌入水印的方法，与在灰度图像内嵌入水印的方法相同。</p>
<h1>色彩空间</h1>
<p>RGB是常见的色彩表示方法，但对于人眼来讲，很难直观地将一种色彩的RGB区分开来，并且在计算机处理色彩时，也有很多其他的颜色表现形式，这就形成了色彩空间。</p>
<h2 id="色彩空间举例">色彩空间举例</h2>
<p>1）RGB颜色空间</p>
<p>RGB（红绿蓝）是依据人眼识别的颜色定义出的空间，可表示大部分颜色。但在科学研究一般不采用RGB颜色空间，因为它的细节难以进行数字化的调整。它将色调，亮度，饱和度三个量放在一起表示，很难分开。它是最通用的面向硬件的彩色模型。该模型用于彩色监视器和一大类彩色视频摄像。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="rgb_color_space.jpg" alt="rgb_color_space" style="zoom:50%;" />
<p>2）CMY/CMYK颜色空间</p>
<p>CMY是工业印刷采用的颜色空间。它与RGB对应。简单的类比RGB来源于是物体发光，而CMY是依据<a href="https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/%E5%8F%8D%E5%B0%84%E5%85%89">反射光</a>得到的。具体应用如打印机：一般采用四色墨盒，即CMY加黑色墨盒</p>
<p>3）HSV/HSB颜色空间</p>
<p>HSV颜色空间是为了更好的数字化处理颜色而提出来的。有许多种HSX颜色空间，其中的X可能是V,也可能是I，依据具体使用而X含义不同。H是色调，S是饱和度，I是强度。HSB（Hue, Saturation, Brightness）颜色模型，这个颜色模型和HSL颜色模型同样都是用户台式机图形程序的颜色表示， 用六角形锥体表示自己的颜色模型。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="hsv_color_space.jpg" alt="hsv_color_space"></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="11.png" style="zoom: 80%;" />
<p>4）HSI/HSL颜色空间</p>
<p>HSI颜色空间是为了更好的数字化处理颜色而提出来的。有许多种HSX颜色空间，其中的X可能是V,也可能是I，依据具体使用而X含义不同。H是色调，S是饱和度，I是强度。HSL（Hue, Saturation, Lightness）颜色模型，这个颜色模型都是用户台式机图形程序的颜色表示， 用六角形锥体表示自己的颜色模型。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="hsi_color_space.jpg" alt="hsi_color_space" style="zoom:67%;" />
<p>5）Lab颜色空间</p>
<p><a href="https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/Lab%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%9E%8B">Lab颜色模型</a>是由CIE（<a href="https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/%E5%9B%BD%E9%99%85%E7%85%A7%E6%98%8E%E5%A7%94%E5%91%98%E4%BC%9A">国际照明委员会</a>）制定的一种色彩模式。自然界中任何一点色都可以在Lab空间中表达出来，它的<a href="https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">色彩空间</a>比RGB空间还要大。另外，这种模式是以数字化方式来描述人的视觉感应， 与设备无关，所以它弥补了RGB和CMYK模式必须依赖于设备色彩特性的不足。由于Lab的色彩空间要比RGB模式和CMYK模式的色彩空间大。这就意味着RGB以及CMYK所能描述的色彩信息在Lab空间中都能 得以影射。<a href="https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/Lab%E9%A2%9C%E8%89%B2%E6%A8%A1%E5%9E%8B">Lab颜色模型</a>取坐标Lab，其中L亮度；a的正数代表红色，负端代表绿色；b的正数代表黄色， 负端代表兰色(a,b)有L=116f(y)-16, a=500[f(x/0.982)-f(y)], b=200[f(y)-f(z/1.183 )]；其中： f(x)=7.787x+0.138, x&lt;0.008856; f(x)=(x)1/3,x&gt;0.008856</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="lab_color_space.jpg" alt="lab_color_space" style="zoom:50%;" />
<p>6）YUV/YCbCr颜色空间</p>
<p>YUV是通过亮度-色差来描述颜色的颜色空间。</p>
<p>亮度信号经常被称作Y，色度信号是由两个互相独立的信号组成。视<a href="https://link.zhihu.com/?target=http%3A//baike.baidu.com/item/%E9%A2%9C%E8%89%B2%E7%B3%BB%E7%BB%9F">颜色系统</a>和格式不同，两种色度信号经常被称作UV或PbPr或CbCr。这些都是由不同的编码格式所产生的，但是实际上，他们的概念基本相同。在DVD中，色度信号被存储成Cb和Cr（C代表颜色，b代表蓝色，r代表红色）。</p>
<p>YCbCr：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="10.png" style="zoom: 80%;" />
<h2 id="色彩空间转换">色彩空间转换</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="12.png" style="zoom: 80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="13.png" style="zoom: 80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="14.png" style="zoom: 80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="15.png" style="zoom: 80%;" />
<p>等等</p>
<h2 id="alpha通道">alpha通道</h2>
<p>在RGB色彩空间三个通道的基础上 ，还可以加上一个A通道，也叫alpha通道，表示透明度。这种4 个通道的色彩空间被称为RGBA色彩空间，PNG图像是一种典型的4通道图像。alpha 通道的赋值范围是[0,1]， 或者[0,255]， 表示从透明到不透明。</p>
<h1>几何变换</h1>
<p>略</p>
<h1>阈值处理</h1>
<p>阈值处理是指剔除图像内像素值高于一定值或者低于一定值的像素点。</p>
<h2 id="阈值化处理">阈值化处理</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="16.png" style="zoom: 80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="17.png" style="zoom: 80%;" />
<p>如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = cv2.imread(<span class="string">&quot;image\\0.png&quot;</span>,-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">    cv2.imshow(<span class="string">&quot;src&quot;</span>,src)</span><br><span class="line">    ret,dst = cv2.threshold(src,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;dst&quot;</span>,dst)</span><br><span class="line"></span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="52.png" style="zoom: 60%;" />
<p>或者，修改相应参数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret,dst = cv2.threshold(src,<span class="number">70</span>,<span class="number">150</span>,cv2.THRESH_BINARY)</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="53.png" style="zoom: 40%;" />
<p>反二值化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret,dst = cv2.threshold(src,<span class="number">127</span>,<span class="number">255</span>,cv2.THRESH_BINARY_INV)</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="54.png" style="zoom: 60%;" />
<h2 id="自适应阈值处理">自适应阈值处理</h2>
<p>对于色彩均衡的图像，直接使用一个阈值就能完成对图像的阈值化处理。 但是，有时图像的色彩是不均衡的，此时如果只使用一个阈值，就无法得到清晰有效的阈值分割结果图像。</p>
<p>在进行阈值处理时，自适应阈值处理的方式通过计算每个像素点周围临近区域的加权平均值获得阈值，并使用该闯值对当前像素点进行处理。<strong>与普通的阈值处理方法相比，自适应阈值处理能够更好地处理明暗差异较大的图像</strong>。</p>
<p><u><strong>处理的图像必须是八位单通道图像 ！！</strong></u></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="18.png" style="zoom: 80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="19.png" style="zoom: 80%;" />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = cv2.imread(<span class="string">&quot;image\\0.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line">    dst = cv2.adaptiveThreshold(src, <span class="number">255</span>, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, <span class="number">3</span>, <span class="number">3</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;dst&quot;</span>, dst)</span><br><span class="line"></span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="55.png" style="zoom: 60%;" />
<h2 id="最优阈值函数">最优阈值函数</h2>
<p>实际处理的图像往往是很复杂的， 不太可能像上述img那样 ， 一眼就观察出最合适的阈值。 如果一个个去尝试， 工作量无疑是巨大的。Otsu方法能够根据当前图像给出最佳的类间分割阈值。 简而言之， <strong>Otsu方法会遍历所有可能阈值， 从而找到最佳的阈值。</strong></p>
<p>在 OpenCV 中， 通过在函数<code> cv2.threshold ()</code>中对参数<code> type</code> 的类型多传递 一个参数 “cv2.THRESH_ OTSU” ， 即可实现Otsu方式的阈值分割。需要说明的是， <strong>在使用Otsu方法时， 要把阈值设为0。此时的函数<code>cv2.threshold()</code>会自动寻找最优阈值， 并将该阈值返回</strong>。</p>
<p><u><strong>处理的图像必须是八位单通道图像 ！！</strong></u></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="20.png" style="zoom: 80%;" />
<ul>
<li>设定的阈值为0。</li>
<li>返回值t是Otsu方法计算得到并使用的最优阈值。</li>
<li>需要注意，如果采用普通的阈值分割，返回的闯值就是设定的阈值。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = cv2.imread(<span class="string">&quot;image\\0.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line">    t,dst = cv2.threshold(src, <span class="number">0</span>,<span class="number">255</span>, cv2.THRESH_BINARY+cv2.THRESH_OTSU)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;dst&quot;</span>, dst)</span><br><span class="line"></span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="56.png" style="zoom: 60%;" />
<h1>图像平滑处理（滤波）</h1>
<p>如果针对图像内的每一个像素点都进行上述平滑处理， 就能够对整幅图像完成平滑处理， 有效地去除图像内的噪声信息。<strong>图像平滑处理的基本原理是， 将噪声所在像素点的像素值处理为其周围临近像素点的值的近似值</strong>。</p>
<h2 id="均值滤波">均值滤波</h2>
<h3 id="原理">原理</h3>
<p>均值滤波是指用当前像素点周围N·N个像素值的均值来代替当前像素值。在进行均值滤波时，首先要考虑需要对周围多少个像素点<strong>取平均值</strong>。通常情况下，我们会以当前像素点为中心， 对行数和列数相等的一块区域内的所有像素点的像素值求平均。针对边缘像素点， 可以只取图像内存在的周围邻域点的像素值均值。</p>
<p>以<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>5</mn><mo>×</mo><mn>5</mn></mrow><annotation encoding="application/x-tex">5\times5</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">5</span></span></span></span>均值滤波为例，相当于：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="21.png" style="zoom: 80%;" />
<h3 id="函数">函数</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="22.png" style="zoom: 80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="23.png" style="zoom: 80%;" />
<p>卷积核小，滤波效果差，卷积核大，图片失真严重（类似高斯模糊），类似于近视的感觉</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = cv2.imread(<span class="string">&quot;image\\0.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;src&quot;</span>, src)</span><br><span class="line">    dst=cv2.blur(src,(<span class="number">10</span>,<span class="number">10</span>))</span><br><span class="line">    cv2.imshow(<span class="string">&quot;dst&quot;</span>, dst)</span><br><span class="line"></span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="57.png" style="zoom: 60%;" />
<h2 id="方框滤波">方框滤波</h2>
<h3 id="原理-2">原理</h3>
<p>方框滤波中，可以自由选择是否对均值滤波的结果进行归一化， 即可以自由选择滤波结果是邻域像素值之和的平均值，还是邻域像素值之和。</p>
<h3 id="函数-2">函数</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="24.png" style="zoom: 80%;" />
<p>当 normalize=0时， 因为不进行归一化处理， 因此滤波得到的值很可能超过当前像素值范围的最大值， 从而被截断为最大值。 这样， 就会得到一幅纯白色的图像。</p>
<h2 id="高斯滤波">高斯滤波</h2>
<h3 id="原理-3">原理</h3>
<p>在进行均值滤波和方框滤波时，其邻域内每个像素的权重是相等的。在高斯滤波中，<strong>会将中心点的权重值加大， 远离中心点的权重值减小，在此基础上计算邻域内各个像素值不同权重的和</strong>。</p>
<p>例如：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="25.png" style="zoom: 80%;" />
<h3 id="函数-3">函数</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="26.png" style="zoom: 80%;" />
<p><strong><u>滤波核必须是奇数！！</u></strong></p>
<p>在该函数中， <code>sigmaY</code>和<code>borderType</code>是可选参数。 <code>sigmaX</code>是必选参数， 但是可以将该参数设置为0, 让函数自己去计算<code>sigmaX</code>的具体值。<br>
官方文档建议显式地指定<code>ksize</code>、 <code>sigmaX</code>和<code>sigmaY三</code>个参数的值， 以避免将来函数修改后可能造成的语法错误。 <strong>当然， 在实际处理中， 可以显式指定<code>sigmaX</code>和 <code>sigmaY</code>为默认值0</strong>。因此， 函数<code>cv2.GaussianBlur()</code>的常用形式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dst = cv2.GaussianBlur (src,ksize,<span class="number">0</span>,<span class="number">0</span>) </span><br></pre></td></tr></table></figure>
<p>效果略好于方框滤波</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = cv2.imread(<span class="string">&quot;image\\0.png&quot;</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;src&quot;</span>, src)</span><br><span class="line">    dst = cv2.GaussianBlur(src, (<span class="number">9</span>, <span class="number">9</span>), <span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;dst&quot;</span>, dst)</span><br><span class="line"></span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="58.png" style="zoom: 60%;" />
<h2 id="中值滤波">中值滤波</h2>
<h3 id="原理-4">原理</h3>
<p>中值滤波会取当前像素点及其周围临近像素点（一共有奇数个像素点）的像素值，将这些像素值排序，然后<strong>将位于中间位置的像素值</strong>作为当前像素点的像素值。(取中位数)</p>
<h3 id="函数-4">函数</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="27.png" style="zoom: 80%;" />
<h2 id="双边滤波">双边滤波</h2>
<h3 id="原理-5">原理</h3>
<p>前述滤波方式基本都只考虑了空间的权重信息， 这种情况计算起来比较方便， 但是在边缘信息的处理上存在较大的问题。在均值滤波、 方框滤波、 高斯滤波中， 都会计算边缘上各个像素点的加权平均值， 从而模糊边缘息。</p>
<p>双边滤波在计算某一个像素点的新值时， 不仅考虑距离信息（距离越远，权重越小），还考虑色彩信息（色彩差别越大，权重越小）。双边滤波综合考虑距离和色彩的权重结果，既能够有效地去除噪声，又能够较好地保护边缘信息。</p>
<p>在双边滤波中，<strong>当处在边缘时，与当前点色彩相近的像素点（颜色距离很近）会被给予较大的权重值；而与当前色彩差别较大的像素点（颜色距离很远）会被给予较小的权重值（极端情况下权重可能为0, 直接忽略该点）</strong>，这样就保护了边缘信息。</p>
<h3 id="函数-5">函数</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="28.png" style="zoom: 80%;" />
<p>双边滤波对边缘的保护很好，但对噪声的处理不是很好。</p>
<h2 id="2D卷积">2D卷积</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="29.png" style="zoom: 80%;" />
<h1>形态学操作</h1>
<p>这一部分是以后很多操作的基础，以后很多操作或多或少都跟形态学有关系。</p>
<h2 id="腐蚀">腐蚀</h2>
<h3 id="原理-6">原理</h3>
<p>腐蚀能够将图像的边界点消除，使图像沿着边界向内收缩，也可以将小于指定结构体元素的部分去除。<strong>腐蚀用来“收缩“或者“细化”二值图像中的前景，借此实现去除噪声、元素分割等功能</strong>。在腐蚀过程中，通常使用一个<strong>结构元</strong>来逐个像素地扫描要被腐蚀的图像，并根据结构元和被腐蚀图像的关系来确定腐蚀结果。</p>
<p>需要注意的是，腐蚀操作等形态学操作是<strong>逐个像素</strong>地来决定值的，每次判定的点都是与结构元中心点所对应的点。图8-3中的两幅图像表示结构元与前景色的两种不同关系。根据这两种不同的关系来决定，腐蚀结果图像中的结构元中心点所对应位置像素点的像素值。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="30.png" style="zoom: 80%;" />
<h3 id="函数-6">函数</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="31.png" style="zoom: 80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="32.png" style="zoom: 80%;" />
<p>例如：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src=".png" style="zoom: 80%;" />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = cv2.imread(<span class="string">&quot;image\\0.png&quot;</span>,-<span class="number">1</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;src&quot;</span>, src)</span><br><span class="line">    kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">    dst = cv2.erode(src, kernel)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;dst&quot;</span>, dst)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="59.png" style="zoom: 60%;" />
<h2 id="膨胀">膨胀</h2>
<h3 id="原理-7">原理</h3>
<p>与腐蚀相反，同样地，处理思路也与其相反。</p>
<ul>
<li>如果结构元中任意一点处千前景图像中，就将膨胀结果图像中对应像素点处理为前景色。</li>
<li>如果结构元完全处千背景图像外，就将膨胀结果图像中对应像素点处理为背景色。</li>
</ul>
<h3 id="函数-7">函数</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="34.png" style="zoom: 80%;" />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = cv2.imread(<span class="string">&quot;image\\0.png&quot;</span>,-<span class="number">1</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;src&quot;</span>, src)</span><br><span class="line">    kernel = np.ones((<span class="number">5</span>,<span class="number">5</span>),np.uint8)</span><br><span class="line">    dst = cv2.dilate(src, kernel)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;dst&quot;</span>, dst)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="60.png" style="zoom: 60%;" />
<h2 id="通用形态学函数">通用形态学函数</h2>
<h3 id="函数-8">函数</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="35.png" style="zoom: 80%;" />
<ul>
<li>
<p>开运算进行的操作是先将图像腐蚀，再对腐蚀的结果进行膨胀。开运算可以用千去噪、计数等。（计数：可以利用开运算将连接在一起的不同区域划分开）</p>
</li>
<li>
<p>闭运算是先膨胀、 后腐蚀的运算， 它有助于关闭前景物体内部的小孔， 或去除物体上的小黑点，还可以将不同的前景图像进行连接。</p>
</li>
<li>
<p>形态学梯度运算是用图像的膨胀图像减腐蚀图像的操作， 该操作可以获取原始图像中前景图像的边缘。</p>
</li>
<li>
<p>礼帽运算是用原始图像减去其开运算图像的操作。 礼帽运算能够获取图像的噪声信息，或者得到比原始图像的边缘更亮的边缘信息。</p>
</li>
<li>
<p>黑帽运算是用闭运算图像减去原始图像的操作。黑帽运算能够获取图像内部的小孔，或前景色中的小黑点， 或者得到比原始图像的边缘更暗的边缘部分。</p>
</li>
</ul>
<h2 id="核函数">核函数</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="36.png" style="zoom: 80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="37.png" style="zoom: 80%;" />
<h1>图像梯度</h1>
<p>图像梯度计算的是图像变化的速度。对千图像的边缘部分，其灰度值变化较大，梯度值也较大；相反，对于图像中比较平滑的部分， 其灰度值变化较小，相应的梯度值也较小。一般情况下，<strong>图像梯度计算的是图像的边缘信息</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="38.png" style="zoom: 80%;" />
<p>原书对此做了很详细的讲解，可以直接参考。</p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUyNzY5OTE5Mw==&amp;mid=2247488231&amp;idx=2&amp;sn=490533849bd36d6e9c70d7d2560936b8&amp;chksm=fa7acf71cd0d4667266a339339b834b1ae6fde2ae002e8d0a16c10deb37aebe2bfd605f20058&amp;scene=178&amp;cur_album_id=1343718009222905856#rd">以下参考</a></p>
<h2 id="Roberts-算子"><strong>Roberts 算子</strong></h2>
<p>Roberts 算子，又称罗伯茨算子，是一种最简单的算子，是一种利用局部差分算子寻找边缘的算子。他采用对角线方向相邻两象素之差近似梯度幅值检测边缘。<strong>检测垂直边缘的效果好于斜向边缘，定位精度高，对噪声敏感，无法抑制噪声的影响</strong>。</p>
<p>1963年， Roberts 提出了这种寻找边缘的算子。 Roberts 边缘算子是一个 2x2 的模版，采用的是对角方向相邻的两个像素之差。</p>
<p><strong>Roberts 算子的模板分为水平方向和垂直方向，如下所示，从其模板可以看出， Roberts 算子能较好的增强正负 45 度的图像边缘</strong>。</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>d</mi><mi>x</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.1600em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">dx= \left[\begin{matrix}  -1 &amp; 0 \\ 0 &amp; 1 \\ \end{matrix} \right] \tag{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span><span class="tag"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>d</mi><mi>y</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.1600em" columnalign="center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(2)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">dy = \left[\begin{matrix}  0 &amp; -1 \\ 1 &amp; 0 \\ \end{matrix} \right] \tag{2}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size3">[</span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.45em;"><span style="top:-3.61em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-2.4099999999999997em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.9500000000000004em;"><span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size3">]</span></span></span></span><span class="tag"><span class="strut" style="height:2.40003em;vertical-align:-0.95003em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">2</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>Roberts 算子在水平方向和垂直方向的计算公式如下：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_x(i,j)=f(i+1,j+1)-f(i,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>d</mi><mi>y</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo><mo>=</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo>−</mo><mi>f</mi><mo stretchy="false">(</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">d_y(i,j)=f(i,j+1)-f(i+1,j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span></p>
<p>Roberts 算子像素的最终计算公式如下：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo>=</mo><msqrt><mrow><msub><mi>d</mi><mi>x</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><msub><mi>d</mi><mi>y</mi></msub><mo stretchy="false">(</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow></msqrt><mrow></mrow></mrow><annotation encoding="application/x-tex">S=\sqrt{d_x(i,j)^2+d_y(i,j)^2}{}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.24em;vertical-align:-0.32305399999999995em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.916946em;"><span class="svg-align" style="top:-3.2em;"><span class="pstrut" style="height:3.2em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span><span style="top:-2.8769460000000002em;"><span class="pstrut" style="height:3.2em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.28em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.28em' viewBox='0 0 400000 1296' preserveAspectRatio='xMinYMin slice'><path d='M263,681c0.7,0,18,39.7,52,119
c34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120
c340,-704.7,510.7,-1060.3,512,-1067
l0 -0
c4.7,-7.3,11,-11,19,-11
H40000v40H1012.3
s-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232
c-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1
s-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26
c-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.32305399999999995em;"><span></span></span></span></span></span><span class="mord"></span></span></span></span></p>
<p>实现 Roberts 算子，我们主要通过 OpenCV 中的 <code>filter2D()</code> 这个函数，这个函数的主要功能是通过卷积核实现对图像的卷积运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter2D</span>(<span class="params">src, ddepth, kernel, dst=<span class="literal">None</span>, anchor=<span class="literal">None</span>, delta=<span class="literal">None</span>, borderType=<span class="literal">None</span></span>)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>src: 输入图像</li>
<li>ddepth: 目标图像所需的深度</li>
<li>kernel: 卷积核</li>
</ul>
<p>接下来开始写代码，首先是图像的读取，并把这个图像转化成灰度图像，这个没啥好说的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;maliao.jpg&#x27;</span>, cv.COLOR_BGR2GRAY)</span><br><span class="line">rgb_img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度化处理图像</span></span><br><span class="line">grayImage = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br></pre></td></tr></table></figure>
<p>然后是使用 Numpy 构建卷积核，并对灰度图像在 x 和 y 的方向上做一次卷积运算：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Roberts 算子</span></span><br><span class="line">kernelx = np.array([[-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]], dtype=<span class="built_in">int</span>)</span><br><span class="line">kernely = np.array([[<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]], dtype=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">x = cv.filter2D(grayImage, cv.CV_16S, kernelx)</span><br><span class="line">y = cv.filter2D(grayImage, cv.CV_16S, kernely)</span><br></pre></td></tr></table></figure>
<p>注意：在进行了 Roberts 算子处理之后，还需要调用convertScaleAbs()函数计算绝对值，并将图像转换为8位图进行显示，然后才能进行图像融合：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转 uint8 ,图像融合</span></span><br><span class="line">absX = cv.convertScaleAbs(x)</span><br><span class="line">absY = cv.convertScaleAbs(y)</span><br><span class="line">Roberts = cv.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>最后是通过 pyplot 将图像显示出来：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">titles = [<span class="string">&#x27;原始图像&#x27;</span>, <span class="string">&#x27;Roberts算子&#x27;</span>]</span><br><span class="line">images = [rgb_img, Roberts]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i + <span class="number">1</span>), plt.imshow(images[i], <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>最终结果如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="39.png" style="zoom: 80%;" />
<h2 id="Prewitt-算子"><strong>Prewitt 算子</strong></h2>
<p>Prewitt 算子是一种一阶微分算子的边缘检测，利用像素点上下、左右邻点的灰度差，在边缘处达到极值检测边缘，去掉部分伪边缘，对噪声具有平滑作用。</p>
<p>由于 Prewitt 算子采用 3 * 3 模板对区域内的像素值进行计算，而 Robert 算子的模板为 2 * 2 ，故 Prewitt 算子的边缘检测结果在水平方向和垂直方向均比 Robert 算子更加明显。<strong>Prewitt算子适合用来识别噪声较多、灰度渐变的图像</strong>。</p>
<p>Prewitt 算子的模版如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>d</mi><mi>x</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.1600em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">dx =  \left[\begin{matrix}1 &amp; 0 &amp; -1 \\1 &amp; 0 &amp; -1 \\ 1 &amp; 0 &amp; -1\end{matrix}\right] \tag{3}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V16 H319z M319 0 H403 V16 H319z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V16 H263z M263 0 H347 V16 H263z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>d</mi><mi>y</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.1600em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">dy =  \left[\begin{matrix}-1 &amp; -1 &amp; -1 \\0 &amp; 0 &amp; 0 \\ 1 &amp; 1 &amp; 1\end{matrix}\right] \tag{3}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V16 H319z M319 0 H403 V16 H319z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V16 H263z M263 0 H347 V16 H263z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>在代码实现上， Prewitt 算子的实现过程与 Roberts 算子比较相似，我就不多介绍，直接贴代码了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;maliao.jpg&#x27;</span>, cv.COLOR_BGR2GRAY)</span><br><span class="line">rgb_img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度化处理图像</span></span><br><span class="line">grayImage = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prewitt 算子</span></span><br><span class="line">kernelx = np.array([[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>],[-<span class="number">1</span>,-<span class="number">1</span>,-<span class="number">1</span>]],dtype=<span class="built_in">int</span>)</span><br><span class="line">kernely = np.array([[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>],[-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>]],dtype=<span class="built_in">int</span>)</span><br><span class="line"></span><br><span class="line">x = cv.filter2D(grayImage, cv.CV_16S, kernelx)</span><br><span class="line">y = cv.filter2D(grayImage, cv.CV_16S, kernely)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转 uint8 ,图像融合</span></span><br><span class="line">absX = cv.convertScaleAbs(x)</span><br><span class="line">absY = cv.convertScaleAbs(y)</span><br><span class="line">Prewitt = cv.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">titles = [<span class="string">&#x27;原始图像&#x27;</span>, <span class="string">&#x27;Prewitt 算子&#x27;</span>]</span><br><span class="line">images = [rgb_img, Prewitt]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i + <span class="number">1</span>), plt.imshow(images[i], <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="40.png" style="zoom: 80%;" />
<p>从结果上来看， Prewitt 算子图像锐化提取的边缘轮廓，其效果图的边缘检测结果比 Robert 算子更加明显。</p>
<h2 id="Sobel-算子"><strong>Sobel 算子</strong></h2>
<p>Sobel 算子的中文名称是索贝尔算子，是一种用于边缘检测的离散微分算子，它结合了高斯平滑和微分求导。</p>
<p><strong>Sobel 算子在 Prewitt 算子的基础上增加了权重的概念，认为相邻点的距离远近对当前像素点的影响是不同的，距离越近的像素点对应当前像素的影响越大，从而实现图像锐化并突出边缘轮廓</strong>。</p>
<p>算法模版如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>d</mi><mi>x</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.1600em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>2</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">dx =  \left[\begin{matrix}1 &amp; 0 &amp; -1 \\2 &amp; 0 &amp; -2 \\ 1 &amp; 0 &amp; -1\end{matrix}\right] \tag{3}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V16 H319z M319 0 H403 V16 H319z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">2</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V16 H263z M263 0 H347 V16 H263z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>d</mi><mi>y</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.1600em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>2</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>2</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>1</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">dy =  \left[\begin{matrix}-1 &amp; -2 &amp; -1 \\0 &amp; 0 &amp; 0 \\ 1 &amp; 2 &amp; 1\end{matrix}\right] \tag{3}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V16 H319z M319 0 H403 V16 H319z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">2</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V16 H263z M263 0 H347 V16 H263z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>Sobel 算子根据像素点上下、左右邻点灰度加权差，在边缘处达到极值这一现象检测边缘。对噪声具有平滑作用，提供较为精确的边缘方向信息。因为 Sobel 算子结合了高斯平滑和微分求导（分化），因此结果会具有更多的抗噪性，当对精度要求不是很高时， Sobel 算子是一种较为常用的边缘检测方法。</p>
<p>Sobel 算子近似梯度的大小的计算公式如下：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>G</mi><mo>=</mo><msqrt><mrow><msubsup><mi>d</mi><mi>x</mi><mn>2</mn></msubsup><mo>+</mo><msubsup><mi>d</mi><mi>y</mi><mn>2</mn></msubsup></mrow></msqrt><mrow></mrow></mrow><annotation encoding="application/x-tex">G=\sqrt{d_x^2+d_y^2}{}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">G</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.84em;vertical-align:-0.6765000000000001em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.1635em;"><span class="svg-align" style="top:-3.8em;"><span class="pstrut" style="height:3.8em;"></span><span class="mord" style="padding-left:1em;"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.740108em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">x</span></span></span><span style="top:-2.9890000000000003em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.247em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7401079999999999em;"><span style="top:-2.4530000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">y</span></span></span><span style="top:-2.989em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.383108em;"><span></span></span></span></span></span></span></span></span><span style="top:-3.1235em;"><span class="pstrut" style="height:3.8em;"></span><span class="hide-tail" style="min-width:1.02em;height:1.8800000000000001em;"><svg xmlns="http://www.w3.org/2000/svg" width='400em' height='1.8800000000000001em' viewBox='0 0 400000 1944' preserveAspectRatio='xMinYMin slice'><path d='M983 90
l0 -0
c4,-6.7,10,-10,18,-10 H400000v40
H1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7
s-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744
c-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30
c26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722
c56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5
c53.7,-170.3,84.5,-266.8,92.5,-289.5z
M1001 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.6765000000000001em;"><span></span></span></span></span></span><span class="mord"></span></span></span></span></p>
<p>梯度方向的计算公式如下：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi><mo>=</mo><msup><mrow><mi>tan</mi><mo>⁡</mo></mrow><mrow><mo>−</mo><mn>1</mn></mrow></msup><mrow><mo stretchy="false">(</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mrow><mi>d</mi><mi>y</mi></mrow><mrow><mi>d</mi><mi>x</mi></mrow></mfrac></mstyle><mo stretchy="false">)</mo></mrow></mrow><annotation encoding="application/x-tex">\theta=\tan^{-1}{(\dfrac{dy}{dx})}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.0574399999999997em;vertical-align:-0.686em;"></span><span class="mop"><span class="mop">tan</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8190879999999999em;"><span style="top:-3.06798em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">−</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.3714399999999998em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal">x</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></span></p>
<p>如果以上的角度 θ 等于零，即代表图像该处拥有纵向边缘，左方较右方暗。</p>
<p>在 Python 中，为我们提供了 <code>Sobel()</code> 函数进行运算，整体处理过程和前面的类似，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;maliao.jpg&#x27;</span>, cv.COLOR_BGR2GRAY)</span><br><span class="line">rgb_img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度化处理图像</span></span><br><span class="line">grayImage = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sobel 算子</span></span><br><span class="line">x = cv.Sobel(grayImage, cv.CV_16S, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">y = cv.Sobel(grayImage, cv.CV_16S, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转 uint8 ,图像融合</span></span><br><span class="line">absX = cv.convertScaleAbs(x)</span><br><span class="line">absY = cv.convertScaleAbs(y)</span><br><span class="line">Sobel = cv.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">titles = [<span class="string">&#x27;原始图像&#x27;</span>, <span class="string">&#x27;Sobel 算子&#x27;</span>]</span><br><span class="line">images = [rgb_img, Sobel]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i + <span class="number">1</span>), plt.imshow(images[i], <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="41.png" style="zoom: 80%;" />
<h2 id="Laplacian-算子"><strong>Laplacian 算子</strong></h2>
<p>拉普拉斯（ Laplacian ）算子是 n 维欧几里德空间中的一个二阶微分算子，常用于图像增强领域和边缘提取。</p>
<p><strong>Laplacian 算子的核心思想：判断图像中心像素灰度值与它周围其他像素的灰度值，如果中心像素的灰度更高，则提升中心像素的灰度；反之降低中心像素的灰度，从而实现图像锐化操作</strong>。</p>
<p>在实现过程中， Laplacian 算子通过对邻域中心像素的四方向或八方向求梯度，再将梯度相加起来判断中心像素灰度与邻域内其他像素灰度的关系，最后通过梯度运算的结果对像素灰度进行调整。</p>
<p>Laplacian 算子分为四邻域和八邻域，四邻域是对邻域中心像素的四方向求梯度，八邻域是对八方向求梯度。</p>
<p>四邻域模板如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>H</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.1600em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>0</mn></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">H =  \left[\begin{matrix}0 &amp; -1 &amp; 0 \\-1 &amp; 4 &amp; -1 \\ 0 &amp; -1 &amp; 0\end{matrix}\right] \tag{3}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V16 H319z M319 0 H403 V16 H319z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V16 H263z M263 0 H347 V16 H263z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>八邻域模板如下：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mtable width="100%"><mtr><mtd width="50%"></mtd><mtd><mrow><mi>H</mi><mo>=</mo><mrow><mo fence="true">[</mo><mtable rowspacing="0.1600em" columnalign="center center center" columnspacing="1em"><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mn>4</mn></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mo>−</mo><mn>1</mn></mrow></mstyle></mtd></mtr></mtable><mo fence="true">]</mo></mrow></mrow></mtd><mtd width="50%"></mtd><mtd><mtext>(3)</mtext></mtd></mtr></mtable><annotation encoding="application/x-tex">H =  \left[\begin{matrix}-1 &amp; -1 &amp; -1 \\-1 &amp; 4 &amp; -1 \\ -1 &amp; -1 &amp; -1\end{matrix}\right] \tag{3}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.08125em;">H</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎣</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V16 H319z M319 0 H403 V16 H319z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎡</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">4</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:0.5em;"></span><span class="arraycolsep" style="width:0.5em;"></span><span class="col-align-c"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05em;"><span style="top:-4.21em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-3.0099999999999993em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span><span style="top:-1.8099999999999994em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">−</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.5500000000000007em;"><span></span></span></span></span></span></span></span><span class="mclose"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.05002em;"><span style="top:-2.2500000000000004em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎦</span></span></span><span style="top:-3.3970000000000002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span style="height:0.016em;width:0.667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.667em' height='0.016em' style='width:0.667em' viewBox='0 0 667 16' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V16 H263z M263 0 H347 V16 H263z'/></svg></span></span><span style="top:-4.05002em;"><span class="pstrut" style="height:3.1550000000000002em;"></span><span class="delimsizinginner delim-size4"><span>⎤</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.55002em;"><span></span></span></span></span></span></span></span></span><span class="tag"><span class="strut" style="height:3.60004em;vertical-align:-1.55002em;"></span><span class="mord text"><span class="mord">(</span><span class="mord"><span class="mord">3</span></span><span class="mord">)</span></span></span></span></span></span></p>
<p>通过模板可以发现，当邻域内像素灰度相同时，模板的卷积运算结果为0；当中心像素灰度高于邻域内其他像素的平均灰度时，模板的卷积运算结果为正数；当中心像素的灰度低于邻域内其他像素的平均灰度时，模板的卷积为负数。对卷积运算的结果用适当的衰弱因子处理并加在原中心像素上，就可以实现图像的锐化处理。</p>
<p>在 OpenCV 中， Laplacian 算子被封装在 <code>Laplacian()</code> 函数中，其主要是利用Sobel算子的运算，通过加上 Sobel 算子运算出的图像 x 方向和 y 方向上的导数，得到输入图像的图像锐化结果。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;maliao.jpg&#x27;</span>, cv.COLOR_BGR2GRAY)</span><br><span class="line">rgb_img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度化处理图像</span></span><br><span class="line">grayImage = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Laplacian</span></span><br><span class="line">dst = cv.Laplacian(grayImage, cv.CV_16S, ksize = <span class="number">3</span>)</span><br><span class="line">Laplacian = cv.convertScaleAbs(dst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用来正常显示中文标签</span></span><br><span class="line">plt.rcParams[<span class="string">&#x27;font.sans-serif&#x27;</span>] = [<span class="string">&#x27;SimHei&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 显示图形</span></span><br><span class="line">titles = [<span class="string">&#x27;原始图像&#x27;</span>, <span class="string">&#x27;Laplacian 算子&#x27;</span>]</span><br><span class="line">images = [rgb_img, Laplacian]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, i + <span class="number">1</span>), plt.imshow(images[i], <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(titles[i])</span><br><span class="line">    plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="42.png" style="zoom: 80%;" />
<h2 id="最后"><strong>最后</strong></h2>
<p><strong>边缘检测算法主要是基于图像强度的一阶和二阶导数，但导数通常对噪声很敏感，因此需要采用滤波器来过滤噪声，并调用图像增强或阈值化算法进行处理，最后再进行边缘检测</strong>。</p>
<p>最后我先使用高斯滤波去噪之后，再进行边缘检测：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="comment"># 读取图像</span></span><br><span class="line">img = cv.imread(<span class="string">&#x27;maliao.jpg&#x27;</span>)</span><br><span class="line">rgb_img = cv.cvtColor(img, cv.COLOR_BGR2RGB)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 灰度化处理图像</span></span><br><span class="line">gray_image = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 高斯滤波</span></span><br><span class="line">gaussian_blur = cv.GaussianBlur(gray_image, (<span class="number">3</span>, <span class="number">3</span>), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Roberts 算子</span></span><br><span class="line">kernelx = np.array([[-<span class="number">1</span>, <span class="number">0</span>], [<span class="number">0</span>, <span class="number">1</span>]], dtype = <span class="built_in">int</span>)</span><br><span class="line">kernely = np.array([[<span class="number">0</span>, -<span class="number">1</span>], [<span class="number">1</span>, <span class="number">0</span>]], dtype = <span class="built_in">int</span>)</span><br><span class="line">x = cv.filter2D(gaussian_blur, cv.CV_16S, kernelx)</span><br><span class="line">y = cv.filter2D(gaussian_blur, cv.CV_16S, kernely)</span><br><span class="line">absX = cv.convertScaleAbs(x)</span><br><span class="line">absY = cv.convertScaleAbs(y)</span><br><span class="line">Roberts = cv.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prewitt 算子</span></span><br><span class="line">kernelx = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>], [-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>]], dtype=<span class="built_in">int</span>)</span><br><span class="line">kernely = np.array([[-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>], [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]], dtype=<span class="built_in">int</span>)</span><br><span class="line">x = cv.filter2D(gaussian_blur, cv.CV_16S, kernelx)</span><br><span class="line">y = cv.filter2D(gaussian_blur, cv.CV_16S, kernely)</span><br><span class="line">absX = cv.convertScaleAbs(x)</span><br><span class="line">absY = cv.convertScaleAbs(y)</span><br><span class="line">Prewitt = cv.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Sobel 算子</span></span><br><span class="line">x = cv.Sobel(gaussian_blur, cv.CV_16S, <span class="number">1</span>, <span class="number">0</span>)</span><br><span class="line">y = cv.Sobel(gaussian_blur, cv.CV_16S, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">absX = cv.convertScaleAbs(x)</span><br><span class="line">absY = cv.convertScaleAbs(y)</span><br><span class="line">Sobel = cv.addWeighted(absX, <span class="number">0.5</span>, absY, <span class="number">0.5</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 拉普拉斯算法</span></span><br><span class="line">dst = cv.Laplacian(gaussian_blur, cv.CV_16S, ksize = <span class="number">3</span>)</span><br><span class="line">Laplacian = cv.convertScaleAbs(dst)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 展示图像</span></span><br><span class="line">titles = [<span class="string">&#x27;Source Image&#x27;</span>, <span class="string">&#x27;Gaussian Image&#x27;</span>, <span class="string">&#x27;Roberts Image&#x27;</span>,</span><br><span class="line">          <span class="string">&#x27;Prewitt Image&#x27;</span>,<span class="string">&#x27;Sobel Image&#x27;</span>, <span class="string">&#x27;Laplacian Image&#x27;</span>]</span><br><span class="line">images = [rgb_img, gaussian_blur, Roberts, Prewitt, Sobel, Laplacian]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">6</span>):</span><br><span class="line">   plt.subplot(<span class="number">2</span>, <span class="number">3</span>, i+<span class="number">1</span>), plt.imshow(images[i], <span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">   plt.title(titles[i])</span><br><span class="line">   plt.xticks([]), plt.yticks([])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="43.png" style="zoom: 80%;" />
<h1>canny边缘检测</h1>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="44.png" style="zoom: 100%;" />
<h2 id="非极大抑制">非极大抑制</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="45.png" style="zoom: 100%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="46.png" style="zoom: 100%;" />
<h2 id="双阈值确定边缘">双阈值确定边缘</h2>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="47.png" style="zoom: 100%;" />
<h2 id="函数-9">函数</h2>
<p>以上几步操作都封装好了，可以直接调用。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="48.png" style="zoom: 100%;" />
<p>样例：threshold两个值较小时精度较高</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = cv2.imread(<span class="string">&quot;image\\0.png&quot;</span>, -<span class="number">1</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;src&quot;</span>, src)</span><br><span class="line">    dst1 = cv2.Canny(src,<span class="number">128</span>,<span class="number">255</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;dst1&quot;</span>, dst1)</span><br><span class="line">    dst = cv2.Canny(src, <span class="number">32</span>, <span class="number">128</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;dst2&quot;</span>, dst)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="61.png" style="zoom: 60%;" />
<h1>图像金字塔</h1>
<p>图像金字塔是图像多尺度表达的一种，是一种以多分辨率来解释图像的有效但概念简单的结构。一幅图像的金字塔是一系列以金字塔形状排列的分辨率逐步降低，且来源于同一张原始图的图像集合。其通过梯次向下采样获得，直到达到某个终止条件才停止采样。我们将一层一层的图像比喻成金字塔，层级越高，则图像越小，分辨率越低。</p>
<h2 id="高斯金字塔">高斯金字塔</h2>
<p>高斯金字塔是由底部的最大分辨率图像逐次向下采样得到的一系列图像。最下面的图像分辨率最高，越往上图像分辨率越低。</p>
<p><strong>这个过程实际上就是一个重复高斯平滑并重新对图像采样的过程</strong>。</p>
<ol>
<li>对于原始图像先进行一次高斯平滑处理，使用高斯核（<code>5 * 5</code>）进行一次卷积处理。下面是 <code>5 * 5</code> 的高斯核。</li>
</ol>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="49.png" style="zoom: 100%;" />
<ol>
<li>接下来是对图像进行采样，这一步会去除图像中的偶数行和奇数列，从而得到一张图像。</li>
<li>再然后是重复上面两步，直到得到最终的目标图像为止。</li>
</ol>
<p>从上面的步骤可以看出，再每次循环中，得到的结果图像只有原图像的 1/4 大小（横纵向均做隔行采样）。</p>
<blockquote>
<p>注意：向下采样会逐渐丢失图像信息，属于非线性的处理，此过程不可逆，属于有损处理。</p>
</blockquote>
<p>高斯金字塔向上采样：</p>
<ol>
<li>将图像在每个方向扩大为原来的两倍，新增的行和列以 0 填充。</li>
<li>使用高斯核（<code>5 * 5</code>）对得到的图像进行一次高斯平滑处理，获得 「新增像素」的近似值。</li>
</ol>
<blockquote>
<p>注意：此过程与向下采样的过程一样，属于非线性处理，无法逆转，属于有损处理。</p>
</blockquote>
<p>此过程得到的图像为放大后的图像，与原图相比会比较模糊，因为在缩放的过程中丢失了一些图像信息，如果想在缩小和放大整个过程中减少信息的丢失。</p>
<p>如果在缩放过程中想要减少图像信息的丢失，这就引出了第二个图像金字塔 —— 「拉普拉斯金字塔」 。</p>
<h2 id="拉普拉斯金字塔">拉普拉斯金字塔</h2>
<p>拉普拉斯金字塔可以认为是残差金字塔，用来存储下采样后图片与原始图片的差异。</p>
<p>上面我们介绍了基于高斯金字塔，一个原始图像 <code>Gi</code> ，先进行向下采样得到 <code>G(i-1)</code> ，再对 <code>G(i-1)</code> 进行向上采样得到 <code>Up(Down(Gi))</code> ，最终得到的 <code>Up(Down(Gi))</code> 与原始的 <code>Gi</code> 是存在差异的。</p>
<p>这是因为向下采样丢失的信息并不能由向上采样来进行恢复，高斯金字塔是一种有损的采样方式。</p>
<p>如果我们想要完全恢复原始图像，那么我们在进行采样的时候就需要保留差异信息。</p>
<p>这就是拉普拉斯金字塔的核心思想，<strong>每次向下采样后，将再次向上采样，得到向上采样的 <code>Up(Down(Gi))</code> 后，记录 <code>Up(Down(Gi))</code> 与 <code>Gi</code> 的差异信息</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="50.png" style="zoom: 100%;" />
<h2 id="函数-10">函数</h2>
<p>OpenCV 为向上采样和向下采样提供了两个函数：<code>pyrDown()</code> 和 <code>pyrUp()</code> 。</p>
<p><code>pyrDown()</code> 的原函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def pyrDown(src, dst=None, dstsize=None, borderType=None)</span><br></pre></td></tr></table></figure>
<ul>
<li>src: 表示输入图像。</li>
<li>dst: 表示输出图像，它与src类型、大小相同。</li>
<li>dstsize: 表示降采样之后的目标图像的大小。</li>
<li>borderType: 表示表示图像边界的处理方式。</li>
</ul>
<blockquote>
<p>注意：dstsize 参数是有默认值的，调用函数的时候不指定第三个参数，那么这个值是按照 Size((src.cols+1)/2, (src.rows+1)/2) 计算的。而且不管如何指定这个参数，一定必须保证满足以下关系式：|dstsize.width * 2 - src.cols| ≤ 2;  |dstsize.height * 2 - src.rows| ≤ 2。也就是说降采样的意思其实是把图像的尺寸缩减一半，行和列同时缩减一半。</p>
</blockquote>
<p><code>pyrUp()</code> 的原函数如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">def pyrUp(src, dst=None, dstsize=None, borderType=None)</span><br></pre></td></tr></table></figure>
<ul>
<li>src: 表示输入图像。</li>
<li>dst: 表示输出图像，它与src类型、大小相同。</li>
<li>dstsize: 表示降采样之后的目标图像的大小。</li>
<li>borderType: 表示表示图像边界的处理方式。</li>
</ul>
<p>参数释义和上面的 <code>pyrDown()</code> 保持一致。</p>
<p>下面是高斯金字塔和拉普拉斯金字塔的代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="comment">#高斯金字塔</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian_pyramid</span>(<span class="params">image</span>):</span></span><br><span class="line">    level = <span class="number">3</span><span class="comment">#设置金字塔的层数为3</span></span><br><span class="line">    temp = image.copy()  <span class="comment">#拷贝图像</span></span><br><span class="line">    gaussian_images = []  <span class="comment">#建立一个空列表</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level):</span><br><span class="line">        dst = cv.pyrDown(temp)   <span class="comment">#先对图像进行高斯平滑，然后再进行降采样（将图像尺寸行和列方向缩减一半）</span></span><br><span class="line">        gaussian_images.append(dst)  <span class="comment">#在列表末尾添加新的对象</span></span><br><span class="line">        cv.imshow(<span class="string">&quot;gaussian&quot;</span>+<span class="built_in">str</span>(i), dst)</span><br><span class="line">        temp = dst.copy()</span><br><span class="line">    <span class="keyword">return</span> gaussian_images</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#拉普拉斯金字塔</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">laplacian_pyramid</span>(<span class="params">image</span>):</span></span><br><span class="line">    gaussian_images = gaussian_pyramid(image)    <span class="comment">#做拉普拉斯金字塔必须用到高斯金字塔的结果</span></span><br><span class="line">    level = <span class="built_in">len</span>(gaussian_images)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(level-<span class="number">1</span>, -<span class="number">1</span>, -<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">if</span> (i-<span class="number">1</span>) &lt; <span class="number">0</span>:</span><br><span class="line">            expand = cv.pyrUp(gaussian_images[i], dstsize = image.shape[:<span class="number">2</span>])</span><br><span class="line">            laplacian = cv.subtract(image, expand)</span><br><span class="line">            <span class="comment"># 展示差值图像</span></span><br><span class="line">            cv.imshow(<span class="string">&quot;laplacian_down_&quot;</span>+<span class="built_in">str</span>(i), laplacian)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            expand = cv.pyrUp(gaussian_images[i], dstsize = gaussian_images[i-<span class="number">1</span>].shape[:<span class="number">2</span>])</span><br><span class="line">            laplacian = cv.subtract(gaussian_images[i-<span class="number">1</span>], expand)</span><br><span class="line">            <span class="comment"># 展示差值图像</span></span><br><span class="line">            cv.imshow(<span class="string">&quot;laplacian_down_&quot;</span>+<span class="built_in">str</span>(i), laplacian)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">src = cv.imread(<span class="string">&#x27;maliao.jpg&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(src.shape)</span><br><span class="line"><span class="comment"># 先将图像转化成正方形，否则会报错</span></span><br><span class="line">input_image = cv.resize(src, (<span class="number">560</span>, <span class="number">560</span>))</span><br><span class="line"><span class="comment"># 设置为 WINDOW_NORMAL 可以任意缩放</span></span><br><span class="line">cv.namedWindow(<span class="string">&#x27;input_image&#x27;</span>, cv.WINDOW_AUTOSIZE)</span><br><span class="line">cv.imshow(<span class="string">&#x27;input_image&#x27;</span>, src)</span><br><span class="line">laplacian_pyramid(src)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h1>图像轮廓</h1>
<p>边缘检测虽然能够检测出边缘，但边缘是不连续的，检测到的边缘并不是一个整体。<strong>图像轮廓是指将边缘连接起来形成的一个整体， 用千后续的计算</strong>。<br>
OpenCV提供了查找图像轮廓的函数<code>cv2.findContours()</code>，该函数能够查找图像内的轮廓信息，而函数<code>cv2.drawContours()</code> 能够将轮廓绘制出来。<br>
图像轮廓是图像中非常重要的一个特征信息，通过对图像轮廓的操作，我们能够获取目标图像的大小 、位置 、方向等信息。</p>
<h2 id="查找与绘制">查找与绘制</h2>
<p>一个轮廓对应着<strong>一系列的点</strong>，这些点以某种方式表示图像中的一条曲线。在 OpenCV 中，函数<code>cv2.findContours()</code>用于查找图像的轮廓，并能够根据参数返回特定表示方式的轮廓（曲线）。函数<code>cv2.drawContours()</code>能够将查找到的轮廓绘制到图像上，该函数可以根据参数在图像上绘制不同样式（实心／空心点， 以及线条的不同粗细、颜色等）的轮廓，可以绘制全部轮廓也可以仅绘制指定的轮廓。</p>
<h3 id="查找轮廓">查找轮廓</h3>
<p>在 OpenCV 中，轮廓提取函数 <code>findContours()</code> 实现的是 1985 年由一名叫做 <code>Satoshi Suzuki</code> 的人发表的一篇论文中的算法，如下：</p>
<blockquote>
<p>Satoshi Suzuki and others. Topological structural analysis of digitized binary images by border following. Computer Vision, Graphics, and Image Processing, 30(1):32–46, 1985.</p>
</blockquote>
<p>对原理感兴趣的同学可以去搜搜看，不是很难理解。</p>
<p>先看一个示例代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">&quot;black.png&quot;</span>)</span><br><span class="line">gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 降噪</span></span><br><span class="line">ret, thresh = cv.threshold(gray_img, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 寻找轮廓</span></span><br><span class="line">contours, hierarchy = cv.findContours(thresh, cv.RETR_TREE, cv.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>(contours[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure>
<p>查找轮廓使用的函数为 <code>findContours()</code> ，它的原型函数如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contours, hierarchy=cv2.findContours(image, mode, method[, contours[, hierarchy[, offset ]]])  </span><br></pre></td></tr></table></figure>
<ul>
<li>contours：返回的图像轮廓，是个List，contours[i]是第i个轮廓，contours[i][j]是第i个轮廓的第j个点</li>
<li>hierarchy：图像的拓扑信息（图像层次）</li>
<li>image：源图像。</li>
<li>mode：表示轮廓检索模式。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cv2.RETR_EXTERNAL 表示只检测外轮廓。</span><br><span class="line">cv2.RETR_LIST 检测的轮廓不建立等级关系。</span><br><span class="line">cv2.RETR_CCOMP 建立两个等级的轮廓，上面的一层为外边界，里面的一层为内孔的边界信息。如果内孔内还有一个连通物体，这个物体的边界也在顶层。</span><br><span class="line">cv2.RETR_TREE 建立一个等级树结构的轮廓。</span><br></pre></td></tr></table></figure>
<ul>
<li>method：表示轮廓近似方法。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cv2.CHAIN_APPROX_NONE 存储所有的轮廓点。</span><br><span class="line">cv2.CHAIN_APPROX_SIMPLE 压缩水平方向，垂直方向，对角线方向的元素，只保留该方向的终点坐标，例如一个矩形轮廓只需4个点来保存轮廓信息。</span><br></pre></td></tr></table></figure>
<p>这里可以使用 <code>print(len(contours[0]))</code> 函数将包含的点的数量打印出来，比如在上面的示例中，使用参数 <code>cv2.CHAIN_APPROX_NONE</code> 轮廓点有 1382 个，而使用参数 <code>cv2.CHAIN_APPROX_SIMPLE</code> 则轮廓点只有 4 个。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="62.png" style="zoom: 100%;" />
<h3 id="绘制轮廓">绘制轮廓</h3>
<p>绘制轮廓使用到的 OpenCV 为我们提供的 <code>drawContours()</code> 这个函数，下面是它的三个简单的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># To draw all the contours in an image:</span><br><span class="line">cv2.drawContours(img, contours, -1, (0,255,0), 3)</span><br><span class="line"># To draw an individual contour, say 4th contour:</span><br><span class="line">cv2.drawContours(img, contours, 3, (0,255,0), 3)</span><br><span class="line"># But most of the time, below method will be useful:</span><br><span class="line">cnt = contours[4]</span><br><span class="line">cv2.drawContours(img, [cnt], 0, (0,255,0), 3)</span><br></pre></td></tr></table></figure>
<p><code>drawContours()</code> 函数中有五个参数：</p>
<ul>
<li>第一个参数是源图像。</li>
<li>第二个参数是应该包含轮廓的列表。</li>
<li>第三个参数是列表索引，用来选择要绘制的轮廓，为-1时表示绘制所有轮廓。</li>
<li>第四个参数是轮廓颜色。</li>
<li>第五个参数是轮廓线的宽度，为 -1 时表示填充。</li>
</ul>
<p>我们接着前面的示例把使用 <code>findContours()</code> 找出来的轮廓绘制出来：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">img = cv.imread(&quot;black.png&quot;)</span><br><span class="line">gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">cv.imshow(&quot;img&quot;, img)</span><br><span class="line"># 降噪</span><br><span class="line">ret, thresh = cv.threshold(gray_img, 127, 255, 0)</span><br><span class="line"># 寻找轮廓</span><br><span class="line">contours, hierarchy = cv.findContours(gray_img, cv.RETR_TREE, cv.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line">print(len(contours[0]))</span><br><span class="line"></span><br><span class="line"># 绘制绿色轮廓</span><br><span class="line">cv.drawContours(img, contours, -1, (0,255,0), 3)</span><br><span class="line"></span><br><span class="line">cv.imshow(&quot;draw&quot;, img)</span><br><span class="line"></span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="63.png" style="zoom: 100%;" />
<h3 id="使用：提取前景">使用：提取前景</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    src = cv2.imread(<span class="string">&quot;image\\0.png&quot;</span>)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;src&quot;</span>, src)</span><br><span class="line">    grey = cv2.cvtColor(src, cv2.COLOR_BGR2GRAY)  <span class="comment"># 灰度图</span></span><br><span class="line">    ret, binary = cv2.threshold(grey, <span class="number">127</span>, <span class="number">255</span>, cv2.THRESH_BINARY)  <span class="comment"># 二值化</span></span><br><span class="line">    counters, hierarchy = cv2.findContours(binary, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)  <span class="comment"># 获取轮廓</span></span><br><span class="line">    mask = np.zeros(src.shape, np.uint8)  <span class="comment"># 按照原图大小创建掩模</span></span><br><span class="line">    mask = cv2.drawContours(mask, counters, -<span class="number">1</span>, (<span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>), -<span class="number">1</span>)  <span class="comment"># 给掩模赋值为前景图的实心轮廓</span></span><br><span class="line">    cv2.imshow(<span class="string">&quot;mask&quot;</span>, mask)</span><br><span class="line">    loc = cv2.bitwise_and(src, mask)</span><br><span class="line">    cv2.imshow(<span class="string">&quot;result&quot;</span>, loc)</span><br><span class="line">    cv2.waitKey()</span><br><span class="line">    cv2.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="64.png" style="zoom: 100%;" />
<p><strong>以上的代码只针对样例图像，并不普适</strong></p>
<h2 id="矩特征">矩特征</h2>
<h3 id="矩的计算：moments">矩的计算：<code>moments()</code></h3>
<p><code>moments()</code> 函数会将计算得到的矩以字典形式返回。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">&quot;number.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 降噪</span></span><br><span class="line">ret, thresh = cv.threshold(gray_img, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 寻找轮廓</span></span><br><span class="line">contours, hierarchy = cv.findContours(gray_img, cv.RETR_TREE, cv.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 获取图像矩</span></span><br><span class="line">M = cv.moments(cnt)</span><br><span class="line"><span class="built_in">print</span>(M)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 质心</span></span><br><span class="line">cx = <span class="built_in">int</span>(M[<span class="string">&#x27;m10&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>])</span><br><span class="line">cy = <span class="built_in">int</span>(M[<span class="string">&#x27;m01&#x27;</span>] / M[<span class="string">&#x27;m00&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&#x27;质心为：[<span class="subst">&#123;cx&#125;</span>, <span class="subst">&#123;cy&#125;</span>]&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>这时，我们取得了这个图像的矩，矩 M 中包含了很多轮廓的特征信息，除了示例中展示的质心的计算，还有如 M[‘m00’] 表示轮廓面积。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="65.png" style="zoom: 100%;" />
<p>​        在位置发生变化时，虽然轮廓的面积、周长等特征不变，但是更高阶的特征会随着位置的变化而发生变化。在很多情况下，我们希望比较不同位置的两个对象的一致性。解决这一问题的方法是引入<strong>中心矩</strong>。中心矩通过城去均值而获取平移不变性，因而能够比较不同位置的两个对象是否一致。很明显，<strong>中心矩具有的平移不变性，使它能够忽略两个对象的位置关系，帮助我们比较不同位置上两个对象的一致性</strong>。</p>
<p>​        除了考虑平移不变性外，我们还会考虑经过缩放后大小不一致的对象的一致性。也就是说，我们希望图像在缩放前后能够拥有一个稳定的特征值。也就是说 ，让图像在缩放前后具有同样的特征值。显然，中心矩不具有这个属性。例如，两个形状一致、大小不一的对象，其中心矩是有差异的。</p>
<p>​        <strong>归一化中心矩通过除以物体总尺寸而获得缩放不变性</strong>。它通过上述计算提取对象的归一化中心矩属性值，该属性值不仅具有平移不变性， 还具有缩放不变性。在OpenCV中， 函数<code>cv2.moments()</code>会同时计算上述空间矩、中心矩和归一化中心矩。</p>
<h3 id="Hu矩">Hu矩</h3>
<p>​        Hu矩是归一化中心矩的线性组合。Hu矩在图像旋转、缩放 、平移等操作后，仍能保持矩的不变性，所以经常会使用Hu距来识别图像的特征。<br>
​        在OpenCV中，使用函数<code>cv2.HuMoments() </code>可以得到Hu距。该函数使用<code>cv2.moments()</code>函 数的返回值作为参数，返回7个Hu矩值。</p>
<p>​        函数cv2.HuMoments(）的语法格式为：<br>
<code>hu=cv2.HuMoments (m) </code><br>
​         式中返回值hu, 表示返回的Hu矩值；参数m, 是由函数<code>cv2.moments()</code>计算得到矩特征值。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="66.png" style="zoom: 100%;" />
<p>最后一个参数直接置0即可。</p>
<h2 id="轮廓拟合">轮廓拟合</h2>
<h3 id="正矩形和最小矩形">正矩形和最小矩形</h3>
<p>轮廓外接矩形分为正矩形和最小矩形。使用 <code>cv2.boundingRect(cnt)</code> 来获取轮廓的外接正矩形，它不考虑物体的旋转，所以该矩形的面积一般不会最小；使用 <code>cv.minAreaRect(cnt)</code> 可以获取轮廓的外接最小矩形。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="67.png" style="zoom: 100%;" />
<p>两者的区别如上图，绿线代表的是外接正矩形，红线代表的是外接最小矩形，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">&quot;number.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"><span class="comment"># 降噪</span></span><br><span class="line">ret, thresh = cv.threshold(gray_img, <span class="number">127</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"><span class="comment"># 寻找轮廓</span></span><br><span class="line">contours, hierarchy = cv.findContours(gray_img, cv.RETR_TREE, cv.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line">cnt = contours[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外接正矩形</span></span><br><span class="line">x, y, w, h = cv.boundingRect(cnt)</span><br><span class="line">cv.rectangle(img, (x, y), (x + w, y + h), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 外接最小矩形</span></span><br><span class="line">min_rect = cv.minAreaRect(cnt)</span><br><span class="line"><span class="built_in">print</span>(min_rect)</span><br><span class="line"></span><br><span class="line">box = cv.boxPoints(min_rect)</span><br><span class="line">box = np.int0(box)</span><br><span class="line">cv.drawContours(img, [box], <span class="number">0</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&quot;draw&quot;</span>, img)</span><br><span class="line"></span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p><code>boundingRect(cnt)</code> 函数的返回值包含四个值，矩形框左上角的坐标 (x, y) 、宽度 w 和高度 h 。</p>
<p><code>minAreaRect(cnt)</code> 函数的返回值中还包含旋转信息，返回值信息为包括中心点坐标 (x,y)，宽高 (w, h) 和旋转角度。</p>
<p>参数<code>cnt</code>可以是灰度图或者轮廓。</p>
<h3 id="最小包围圆">最小包围圆</h3>
<p><code>center,radius = cv2.minEnclosingCircle(points)</code></p>
<ul>
<li>center是最小包围圆的中心</li>
<li>radius是半径</li>
<li>points是轮廓</li>
</ul>
<h3 id="最优拟合椭圆">最优拟合椭圆</h3>
<p><code>retval = cv2.fitEllipse(points)</code></p>
<p>众所周知每个椭圆都有相应的外接矩形，返回值<code>retval</code>包含外接矩形的质心、宽、高、旋转角度等参数信息。</p>
<h3 id="最优拟合直线">最优拟合直线</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="68.png" style="zoom: 100%;" />
<h3 id="最小外包三角形">最小外包三角形</h3>
<p><code>retval,triangle = cv2.minEnclosingTriangle(points)</code></p>
<ul>
<li>retval：最小外包三角形的面积</li>
<li>triangle：最小外包三角形的三个顶点的集合</li>
</ul>
<h3 id="轮廓近似（逼近多边形）">轮廓近似（逼近多边形）</h3>
<p>根据我们指定的精度，它可以将轮廓形状近似为顶点数量较少的其他形状。它是由 Douglas-Peucker 算法实现的。</p>
<p>OpenCV 提供的函数是 <code>approxPolyDP(cnt, epsilon, close)</code></p>
<ul>
<li>
<p>第一个参数是轮廓。</p>
</li>
<li>
<p>第二个参数 epsilon 用于轮廓近似的精度，表示原始轮廓与其近似轮廓的最大距离，值越小，近似轮廓越拟合原轮廓。</p>
</li>
<li>
<p>第三个参数指定近似轮廓是否是闭合的，布尔类型。</p>
</li>
</ul>
<p>具体用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">img = cv.imread(&quot;number.png&quot;)</span><br><span class="line"></span><br><span class="line">gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"># 降噪</span><br><span class="line">ret, thresh = cv.threshold(gray_img, 127, 255, 0)</span><br><span class="line"># 寻找轮廓</span><br><span class="line">contours, hierarchy = cv.findContours(gray_img, cv.RETR_TREE, cv.CHAIN_APPROX_NONE)</span><br><span class="line"></span><br><span class="line">cnt = contours[0]</span><br><span class="line"></span><br><span class="line"># 计算 epsilon ，按照周长百分比进行计算，分别取周长 1% 和 10%</span><br><span class="line">epsilon_1 = 0.1 * cv.arcLength(cnt, True)</span><br><span class="line">epsilon_2 = 0.01 * cv.arcLength(cnt, True)</span><br><span class="line"></span><br><span class="line"># 进行多边形逼近</span><br><span class="line">approx_1 = cv.approxPolyDP(cnt, epsilon_1, True)</span><br><span class="line">approx_2 = cv.approxPolyDP(cnt, epsilon_2, True)</span><br><span class="line"></span><br><span class="line"># 画出多边形</span><br><span class="line">image_1 = cv.cvtColor(gray_img, cv.COLOR_GRAY2BGR)</span><br><span class="line">image_2 = cv.cvtColor(gray_img, cv.COLOR_GRAY2BGR)</span><br><span class="line"></span><br><span class="line">cv.polylines(image_1, [approx_1], True, (0, 0, 255), 2)</span><br><span class="line">cv.polylines(image_2, [approx_2], True, (0, 0, 255), 2)</span><br><span class="line">#这里的绘制函数会在后面讲到</span><br><span class="line">#可以用drawContours()代替</span><br><span class="line"></span><br><span class="line">cv.imshow(&quot;image_1&quot;, image_1)</span><br><span class="line">cv.imshow(&quot;image_2&quot;, image_2)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="69.png" style="zoom: 100%;" />
<p>第一张图是 epsilon 为原始轮廓周长的 10% 时的近似轮廓，第二张图中绿线就是 epsilon 为原始轮廓周长的 1% 时的近似轮廓。</p>
<p><strong>现在使用的图像都是仅有一个轮廓的图像，处理的轮廓都是contours[0]。如果处理的原图像中有多个轮廓，则需要注意控制轮廓的索引，即 contours[i]中的 i 值，使其指向特定的轮廓</strong>。</p>
<h3 id="凸包">凸包</h3>
<p>凸包外观看起来与轮廓逼近相似，只不过它是物体最外层的「凸」多边形。</p>
<p>如下图，红色的部分为手掌的凸包，双箭头部分表示凸缺陷(Convexity Defects)，凸缺陷常用来进行手势识别等。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="70.png" style="zoom: 100%;" />
<p>函数：</p>
<p><code>hull = cv2.convexHull(points[,clockwise[,returnPoints]])</code></p>
<ul>
<li>clockwise:布尔型值。 该值为True时，凸包角点将按顺时针方向排列；该值为False时， 则以逆时针方向排列凸包角点。</li>
<li>returnPoints:布尔型值。 默认值是True, 函数返回凸包角点的x/y轴坐标；当为 False时函数返回轮廓中凸包角点的索引。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import cv2 as cv</span><br><span class="line"></span><br><span class="line">img = cv.imread(&quot;number.png&quot;)</span><br><span class="line">gray_img = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"># 降噪</span><br><span class="line">ret, thresh = cv.threshold(gray_img, 127, 255, 0)</span><br><span class="line"># 寻找轮廓</span><br><span class="line">contours, hierarchy = cv.findContours(gray_img, cv.RETR_TREE, cv.CHAIN_APPROX_NONE)</span><br><span class="line">cnt = contours[0]</span><br><span class="line"># 绘制轮廓</span><br><span class="line">image = cv.cvtColor(gray_img, cv.COLOR_GRAY2BGR)</span><br><span class="line">cv.drawContours(image, contours, -1, (0, 0 , 255), 2)</span><br><span class="line"></span><br><span class="line"># 寻找凸包，得到凸包的角点</span><br><span class="line">hull = cv.convexHull(cnt)</span><br><span class="line"></span><br><span class="line"># 绘制凸包</span><br><span class="line">cv.polylines(image, [hull], True, (0, 255, 0), 2)</span><br><span class="line"></span><br><span class="line">cv.imshow(&quot;image&quot;, image)</span><br><span class="line">cv.waitKey(0)</span><br><span class="line">cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="71.png" style="zoom: 100%;" />
<p>还有一个函数，是可以用来判断图形是否凸形的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(cv.isContourConvex(hull)) # True</span><br></pre></td></tr></table></figure>
<p>它的返回值是 True 或者 False 。</p>
<h4 id="凸缺陷">凸缺陷</h4>
<p><code>convexityDefects = cv2.convexityDefects(contour,convexhull)</code></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="72.png" style="zoom: 100%;" />
<h2 id="形状场景算法比较轮廓">形状场景算法比较轮廓</h2>
<p>作为归一化中心矩的替代算法。</p>
<h3 id="计算形状场景距离">计算形状场景距离</h3>
<p>​        OpenCV提供了使用“距离”作为形状比较的度量标准。 这是因为形状之间的差异值和距离有相似之处， 比如二者都只能是零或者正数， 又比如当两个形状一模一样时距离值和差值都等于零。</p>
<p>​        OpenCV提供了函数<code>cv2.createShapeContextDistanceExtractor () </code>， 用于计算形状场景距离。其使用的”形状上下文算法”在计算距离时， 在每个点上附加一个“形状上下文“描述符， 让每个点都能够捕获剩余点相对于它的分布特征， 从而提供全局鉴别特征。</p>
<p>​        有关该函数的更多理论知识， 可以参考学者 Belongie 等人 2002 年在IEEE Transactions on Pattern Analysis &amp; Machine Intelligence上发表的论文Shape Matching and Object Recognition Using Shape Contexts。</p>
<p>函数<code>cv2.createShapeContextDistanceExtractor() </code>的语法格式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">retval = cv2.createShapeContextDistanceExtractor ( </span><br><span class="line">[,nAngularBins[, </span><br><span class="line">nRadialBins[, </span><br><span class="line">innerRadius[, </span><br><span class="line">outerRadius[, </span><br><span class="line">iterations[, </span><br><span class="line">comparer[, </span><br><span class="line">transf armer]]]]]]])</span><br></pre></td></tr></table></figure>
<p>式中的返回值为<code>retval</code>, 返回结果是<code>ShapeDistanceExtractor</code>类型的变量<br>
该结果可以通过函数<code>cv2.ShapeDistanceExtractor.computeDistance()</code>计算两个不同形状之间的距离。 此函数的语法格式为：</p>
<p><code>d = cv2.ShapeDistanceExtractor.computeDistance (contour1,contour2)</code> 式中， coutour1和coutour2是不同的轮廓。<br>
函数<code>cv2.createShapeContextDistanceExtractor() </code>的参数都是可选参数：</p>
<ul>
<li>
<p><code>nAngularBins</code>: 为形状匹配中使用的形状上下文描述符建立的角容器的数星。</p>
</li>
<li>
<p><code>nRadialBins</code>: 为形状匹配中使用的形状上下文描述符建立的径向容器的数星。</p>
</li>
<li>
<p><code>innerRadius</code>：形状上下文描述符的内半径。</p>
</li>
<li>
<p><code>outerRadius</code>：形状上下文描述符的外半径。</p>
</li>
<li>
<p><code>iterations</code>: 迭代次数。</p>
</li>
<li>
<p><code>comparer</code>：直方图代价提取算子。 该函数使用了直方图代价提取仿函数， 可以直接采用直方图代价提取仿函数的算子作为参数。</p>
</li>
<li>
<p><code>transformer</code>: 形状变换参数。</p>
</li>
</ul>
<h3 id="计算Hausdorff距离">计算Hausdorff距离</h3>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="73.png" style="zoom: 100%;" />
<h1>直方图处理</h1>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzUyNzY5OTE5Mw==&amp;mid=2247490728&amp;idx=1&amp;sn=7d891e12db0fb896702c58bd7c4f05e8&amp;chksm=fa7ac13ecd0d4828f46613a645df8706dba72b83e07e46b3f68fa4ecffec0b7bdef8c86c73fc&amp;scene=178&amp;cur_album_id=1343718009222905856#rd">参考</a></p>
<p>图像灰度直方图是什么鬼？直方图是都是由横纵坐标组成的，而图像直方图的横坐标 X 轴上表示的是像素点的灰度值（不总是从 0 到 255 的范围），在纵坐标 Y 轴上表示的相应像素数。所以，直方图是可以对整幅图的灰度分布进行整体了解的图示，通过直方图我们可以对图像的对比度、亮度和灰度分布等有一个直观了解。从统计的角度讲，直方图是图像内灰度值的统计特性与图像灰度值之间的函数。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="74.png" style="zoom: 100%;" />
<p>上面这张图来自官方网站，在这张图中，我们可以得到如下信息：</p>
<ul>
<li>左侧区域显示图像中较暗像素的数量（左侧的灰度级更趋近于 0 ）。</li>
<li>右侧区域则显示明亮像素的数量（右侧的灰度级更趋近于 255）。</li>
<li>暗区域多于亮区域，而中间调的数量（中间值的像素值，例如127附近）则非常少。</li>
</ul>
<h2 id="直方图的绘制">直方图的绘制</h2>
<p>我们需要了解一些与直方图有关的术语。</p>
<p><strong>BINS</strong>：如果我们不需要分别找到所有像素值的像素数，而是找到像素值间隔中的像素数怎么办？ 例如，您需要找到介于0到15之间的像素数，然后找到16到31之间，…，240到255之间的像素数。只需要16个值即可表示直方图。这就是在OpenCV教程中有关直方图的示例中显示的内容。</p>
<p>因此，我们要做的就是将整个直方图分成16个子部分，每个子部分的值就是其中所有像素数的总和。 每个子部分都称为“ BIN”。在第一种情况下，bin的数量为256个（每个像素一个），而在第二种情况下，bin的数量仅为16个。BINS由OpenCV文档中的<code>histSize</code>术语表示。</p>
<p><strong>DIMS</strong>：这是我们为其收集数据的参数的数量。在这种情况下，我们仅收集关于强度值的一件事的数据。所以这里是1。</p>
<p><strong>RANGE</strong>：这是您要测量的强度值的范围。通常，它是<code>[0,256]</code>，即所有强度值。</p>
<h3 id="使用-Matplotlib-绘图">使用 Matplotlib 绘图</h3>
<p>Matplotlib 带有一个强大的直方图绘图功能：<code>matplotlib.pyplot.hist()</code> ，这个方法可以直接找到直方图进行绘制。</p>
<p>在看示例代码之前，有两个参数需要先介绍下：</p>
<ul>
<li>数据源：数据源必须是一维数组，通常需要通过函数 <code>ravel()</code> 拉直图像，而函数 <code>ravel()</code> 的作用是将多维数组降为一维数组。</li>
<li>像素级：一般是 256 ，表示 [0, 255] 。</li>
</ul>
<p>代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">&quot;maliao.jpg&quot;</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br><span class="line">plt.hist(img.ravel(), <span class="number">256</span>, [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="75.png" style="zoom: 70%;" />
<p>当然，我们除了可以绘制灰度直方图以外，还可以绘制出 <code>r,g,b</code> 不同通道的直方图，可以看下面的代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">img = cv.imread(<span class="string">&quot;tiankong.jpg&quot;</span>)</span><br><span class="line">color = (<span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;g&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line"></span><br><span class="line">cv.imshow(<span class="string">&quot;img&quot;</span>, img)</span><br><span class="line">cv.waitKey(<span class="number">0</span>)</span><br><span class="line">cv.destroyAllWindows()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, col <span class="keyword">in</span> <span class="built_in">enumerate</span>(color):</span><br><span class="line">    histr = cv.calcHist([img], [i], <span class="literal">None</span>, [<span class="number">256</span>], [<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    plt.plot(histr, color = col)</span><br><span class="line">    plt.xlim([<span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="76.png" style="zoom: 60%;" />
<h3 id="使用opencv绘制">使用opencv绘制</h3>
<p>略</p>
<h2 id="直方图均衡化">直方图均衡化</h2>
<p>一副效果好的图像通常在直方图上的分布比较均匀，直方图均衡化就是用来改善图像的全局亮度和对比度。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="78.png" style="zoom: 100%;" />
<p>函数<code>    resultImg= cv.equalizeHist(src)</code>，src必须是单通道图像，所以：</p>
<ul>
<li>灰度图均衡，直接使用 <code>equalizeHist()</code> 函数。</li>
<li>彩色图均衡，分别在不同的通道均衡后合并。</li>
</ul>
<p>示例代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&quot;image\\0.png&quot;</span>)</span><br><span class="line">    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 灰度图均衡化</span></span><br><span class="line">    equ = cv.equalizeHist(gray)</span><br><span class="line">    <span class="comment"># 竖直拼接原图和均衡图</span></span><br><span class="line">    result1 = np.vstack((gray, equ))</span><br><span class="line">    cv.imshow(<span class="string">&quot;grey&quot;</span>,result1)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 彩色图像均衡化,需要分解通道 对每一个通道均衡化</span></span><br><span class="line">    (b, g, r) = cv.split(img)</span><br><span class="line">    bH = cv.equalizeHist(b)</span><br><span class="line">    gH = cv.equalizeHist(g)</span><br><span class="line">    rH = cv.equalizeHist(r)</span><br><span class="line">    <span class="comment"># 合并每一个通道</span></span><br><span class="line">    equ2 = cv.merge((bH, gH, rH))</span><br><span class="line">    <span class="comment"># 竖直拼接原图和均衡图</span></span><br><span class="line">    result2 = np.vstack((img, equ2))</span><br><span class="line">    cv.imshow(<span class="string">&quot;rgb&quot;</span>,result2)</span><br><span class="line"></span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="77.png" style="zoom: 50%;" />
<h3 id="原理-8">原理</h3>
<p>直方图均衡化的算法主要包括两个步骤：</p>
<p>(1)	计算累计直方图。<br>
(2)	对累计直方图进行区间转换</p>
<p>在此基础上， 再利用人眼视觉达到直方图均衡化的目的。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="79.png" style="zoom: 70%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="80.png" style="zoom: 73%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="81.png" style="zoom: 70%;" />
<h2 id="自适应直方图均衡化">自适应直方图均衡化</h2>
<p>是指在每一个小区域内（默认 8×8 ）进行直方图均衡化。当然，如果有噪点的话，噪点会被放大，需要对小区域内的对比度进行了限制。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&quot;image\\0.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 全局直方图均衡</span></span><br><span class="line">    equ = cv.equalizeHist(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 自适应直方图均衡</span></span><br><span class="line">    clahe = cv.createCLAHE(clipLimit=<span class="number">2.0</span>, tileGridSize=(<span class="number">8</span>, <span class="number">8</span>))</span><br><span class="line">    cl1 = clahe.apply(img)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 水平拼接三张图像</span></span><br><span class="line">    result = np.vstack((img, equ, cl1))</span><br><span class="line">    cv.imshow(<span class="string">&quot;result&quot;</span>,result)</span><br><span class="line"></span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="82.png" style="zoom: 60%;" />
<h2 id="二维直方图">二维直方图</h2>
<p>对于一维直方图，我们从BGR转换为灰度，绘制的是灰度的比例关系（占比关系），对于二维直方图，我们需要将图像从BGR转换为HSV。我们计算并绘制的一维直方图，之所以称为一维，是因为我们仅考虑一个特征，即像素的灰度强度值。 但是在二维直方图中，我们要考虑两个特征。 通常，它用于颜色直方图，其中两个特征是每个<strong>像素的色相和饱和度值</strong>。</p>
<p>对于二维直方图，其参数将进行如下修改：</p>
<ul>
<li><strong>channel = [0,1]</strong>，因为我们需要同时处理H和S平面。</li>
<li><strong>bins = [180,256]</strong>，对于H平面为180，对于S平面为256。</li>
<li><strong>range = [0,180,0,256]</strong> ，色相值介于0和180之间，饱和度介于0和256之间。</li>
</ul>
<p>也就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line">img = cv.imread(<span class="string">&#x27;home.jpg&#x27;</span>)</span><br><span class="line">hsv = cv.cvtColor(img,cv.COLOR_BGR2HSV)</span><br><span class="line">hist = cv.calcHist([hsv], [<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br></pre></td></tr></table></figure>
<p>X轴显示S值，Y轴显示色相。代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&quot;image\\2.png&quot;</span>)</span><br><span class="line"></span><br><span class="line">    hsv = cv.cvtColor(img, cv.COLOR_BGR2HSV)</span><br><span class="line">    hist = cv.calcHist([hsv], [<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    plt.imshow(hist, interpolation=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="83.png" style="zoom: 70%;" />
<h2 id="直方图反投影">直方图反投影</h2>
<h3 id="理论">理论</h3>
<p>这是由<strong>Michael J. Swain</strong>和<strong>Dana H. Ballard</strong>在他们的论文《<strong>通过颜色直方图索引</strong>》中提出的。</p>
<p><strong>用简单的话说是什么意思</strong>？<strong>它用于图像分割或在图像中查找感兴趣的对象</strong>。简而言之，它创建的图像大小与输入图像相同（但只有一个通道），其中每个像素对应于该像素属于我们物体的概率。用更简单的话来说，与其余部分相比，输出图像将在可能有对象的区域具有更多的白色值。好吧，这是一个直观的解释。（我无法使其更简单）。直方图反投影与camshift算法等配合使用。</p>
<p><strong>我们该怎么做呢</strong>？我们创建一个图像的直方图，其中包含我们感兴趣的对象（在我们的示例中是背景，离开播放器等）。对象应尽可能填充图像以获得更好的效果。而且颜色直方图比灰度直方图更可取，因为对象的颜色对比灰度强度是定义对象的好方法。然后，我们将该直方图“反投影”到需要找到对象的测试图像上，换句话说，我们计算出属于背景的每个像素的概率并将其显示出来。在适当的阈值下产生的输出使我们仅获得背景。</p>
<h3 id="Numpy中的算法">Numpy中的算法</h3>
<ol>
<li>首先，我们需要计算我们要查找的对象（使其为“ M”）和要搜索的图像（使其为“ I”）的颜色直方图。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="comment">#roi是我们需要找到的对象或对象区域</span></span><br><span class="line">roi = cv.imread(<span class="string">&#x27;rose_red.png&#x27;</span>)</span><br><span class="line">hsv = cv.cvtColor(roi,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="comment">#目标是我们搜索的图像</span></span><br><span class="line">target = cv.imread(<span class="string">&#x27;rose.png&#x27;</span>)</span><br><span class="line">hsvt = cv.cvtColor(target,cv.COLOR_BGR2HSV)</span><br><span class="line"><span class="comment"># 使用calcHist查找直方图。也可以使用np.histogram2d完成</span></span><br><span class="line">M = cv.calcHist([hsv],[<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>] )</span><br><span class="line">I = cv.calcHist([hsvt],[<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>] )</span><br></pre></td></tr></table></figure>
<ol>
<li>求出比值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>M</mi><mi>I</mi></mfrac></mstyle></mrow><annotation encoding="application/x-tex">R = \dfrac{M}{I}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.07847em;">I</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">M</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。然后反向投影R，<strong>即使用R作为调色板，并以每个像素作为其对应的目标概率创建一个新图像</strong>。即<code>B(x,y) = R[h(x,y),s(x,y)]</code> 其中h是色调，s是像素在(x，y)的饱和度。之后，应用条件<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">[</mo><mi>B</mi><mo stretchy="false">(</mo><mi>x</mi><mo separator="true">,</mo><mi>y</mi><mo stretchy="false">)</mo><mo separator="true">,</mo><mn>1</mn><mo stretchy="false">]</mo></mrow><annotation encoding="application/x-tex">B(x,y)=min[B(x,y),1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">[</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h,s,v = cv.split(hsvt)</span><br><span class="line">B = R[h.ravel(),s.ravel()]</span><br><span class="line">B = np.minimum(B,<span class="number">1</span>)</span><br><span class="line">B = B.reshape(hsvt.shape[:<span class="number">2</span>])</span><br></pre></td></tr></table></figure>
<ol>
<li>现在对圆盘应用卷积，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mi>D</mi><mo>∗</mo><mi>B</mi></mrow><annotation encoding="application/x-tex">B=D*B</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">D</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span>，其中D是圆盘内核。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">disc = cv.getStructuringElement(cv.MORPH_ELLIPSE,(<span class="number">5</span>,<span class="number">5</span>))</span><br><span class="line">cv.filter2D(B,-<span class="number">1</span>,disc,B)</span><br><span class="line">B = np.uint8(B)</span><br><span class="line">cv.normalize(B,B,<span class="number">0</span>,<span class="number">255</span>,cv.NORM_MINMAX)</span><br></pre></td></tr></table></figure>
<ol>
<li>现在最大强度的位置给了我们物体的位置。如果我们期望图像中有一个区域，则对合适的值进行阈值处理将获得不错的结果。</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ret,thresh = cv.threshold(B,<span class="number">50</span>,<span class="number">255</span>,<span class="number">0</span>) </span><br></pre></td></tr></table></figure>
<p>比如，我通过一个天空的图像片段查找图像中所有的天空：（图中红框是我提供的ROI）</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="84.png" style="zoom: 40%;" />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment">#查找样例</span></span><br><span class="line">    roi = cv.imread(<span class="string">&quot;image\\1-1.png&quot;</span>)</span><br><span class="line">    hsv = cv.cvtColor(roi, cv.COLOR_BGR2HSV)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#全图</span></span><br><span class="line">    target = cv.imread(<span class="string">&quot;image\\1.png&quot;</span>)</span><br><span class="line">    hsvt = cv.cvtColor(target, cv.COLOR_BGR2HSV)</span><br><span class="line">    M = cv.calcHist([hsv], [<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    I = cv.calcHist([hsvt], [<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    R = M/I</span><br><span class="line">    </span><br><span class="line">    h, s, v = cv.split(hsvt)</span><br><span class="line">    B = R[h.ravel(), s.ravel()]</span><br><span class="line">    B = np.minimum(B, <span class="number">1</span>)</span><br><span class="line">    B = B.reshape(hsvt.shape[:<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">    disc = cv.getStructuringElement(cv.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">    cv.filter2D(B, -<span class="number">1</span>, disc, B)</span><br><span class="line">    B = np.uint8(B)</span><br><span class="line">    cv.normalize(B, B, <span class="number">0</span>, <span class="number">255</span>, cv.NORM_MINMAX)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#阈值处理</span></span><br><span class="line">    ret, thresh = cv.threshold(B, <span class="number">50</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">#构造掩模</span></span><br><span class="line">    thresh = cv.merge((thresh, thresh, thresh))</span><br><span class="line">    res = cv.bitwise_and(target, thresh)</span><br><span class="line">    res = np.vstack((target, thresh, res))</span><br><span class="line">    cv.imshow(<span class="string">&quot;result&quot;</span>,res)</span><br><span class="line">    </span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="OpenCV的反投影">OpenCV的反投影</h3>
<p>OpenCV提供了一个内建的函数<strong>cv.calcBackProject</strong>()。它的参数几乎与<strong>cv.calchist</strong>()函数相同。它的一个参数是直方图，也就是物体的直方图，我们必须找到它。另外，在传递给backproject函数之前，应该对对象直方图进行归一化。它返回概率图像。然后我们用圆盘内核对图像进行卷积并应用阈值。下面是我的代码和结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    roi = cv.imread(<span class="string">&quot;image\\1-1.png&quot;</span>)</span><br><span class="line">    hsv = cv.cvtColor(roi, cv.COLOR_BGR2HSV)</span><br><span class="line"></span><br><span class="line">    target = cv.imread(<span class="string">&quot;image\\1.png&quot;</span>)</span><br><span class="line">    hsvt = cv.cvtColor(target, cv.COLOR_BGR2HSV)</span><br><span class="line">    <span class="comment"># 计算对象的直方图</span></span><br><span class="line">    roihist = cv.calcHist([hsv], [<span class="number">0</span>, <span class="number">1</span>], <span class="literal">None</span>, [<span class="number">180</span>, <span class="number">256</span>], [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>])</span><br><span class="line">    <span class="comment"># 直方图归一化并利用反传算法</span></span><br><span class="line">    cv.normalize(roihist, roihist, <span class="number">0</span>, <span class="number">255</span>, cv.NORM_MINMAX)</span><br><span class="line">    dst = cv.calcBackProject([hsvt], [<span class="number">0</span>, <span class="number">1</span>], roihist, [<span class="number">0</span>, <span class="number">180</span>, <span class="number">0</span>, <span class="number">256</span>], <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 用圆盘进行卷积</span></span><br><span class="line">    disc = cv.getStructuringElement(cv.MORPH_ELLIPSE, (<span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">    cv.filter2D(dst, -<span class="number">1</span>, disc, dst)</span><br><span class="line">    <span class="comment"># 应用阈值作与操作</span></span><br><span class="line">    ret, thresh = cv.threshold(dst, <span class="number">50</span>, <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">    thresh = cv.merge((thresh, thresh, thresh))</span><br><span class="line">    res = cv.bitwise_and(target, thresh)</span><br><span class="line">    res = np.vstack((target, thresh, res))</span><br><span class="line">    cv.imshow(<span class="string">&quot;result&quot;</span>,res)</span><br><span class="line"></span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="85.png" style="zoom: 40%;" />
<h2 id="补充：pyplot-subplot">补充：pyplot.subplot()</h2>
<p>模块 <code>matplotlib.pyplot</code> 提供了函数<code>matplotlib.pyplot.subplot()</code>用来向当前窗口内添加一个子窗口对象。 该函数的语法格式为：</p>
<p><code>matplotlib. pyplot.subplot (nrows,ncols,index)</code></p>
<p>式中：</p>
<ul>
<li>nrows为行数。</li>
<li>ncols为列数。</li>
<li>index为窗口序号。</li>
</ul>
<p>例如，subplot(2,3,4)表示在当前的两行三列的窗口的第4个位置上，添加1个子窗口</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="86.png" style="zoom: 80%;" />
<h1>傅里叶变换</h1>
<h2 id="原理-9">原理</h2>
<p>​        图像处理一般分为<strong>空间域</strong>处理和<strong>频率域</strong>处理。</p>
<p>​        <strong>空间域处理是直接对图像内的像素进行处理</strong>。 空间域处理主要划分为灰度变换和空间滤波两种形式。 灰度变换是对图像内的单个像素进行处理， 比如调节对比度和处理闯值等。空间滤波涉及图像质星的改变， 例如图像平滑处理。 空间域处理的计算简单方便，运算速度更快。<br>
​        <strong>频率域处理是先将图像变换到频率域， 然后在频率域对图像进行处理， 最后再通过反变换将图像从频率域变换到空间域</strong>。 傅里叶变换是应用最广泛的一种频域变换， 它能够将图像从空间域变换到频率域， 而逆傅里叶变换能够将频率域信息变换到空间域内。 傅里叶变换在图像处理领域内有着非常重要的作用。</p>
<p>​        在图像处理过程中，<strong>傅里叶变换就是将图像分解为正弦分量和余弦分量两部分，即将图像从空间域转换到频率域（以下简称频域）</strong>。数字图像经过傅里叶变换后，得到的频域值是复数。因此，显示傅里叶变换的结果需要使用实数图像 (real image) 加虚数图像 (complex image)或者幅度图像(magnitude image) 加相位图像 (phase image) 的形式。</p>
<p>​        因为幅度图像包含了原图像中我们所需要的大部分信息，所以在图像处理过程中，通常仅使用幅度图像。当然，如果希望先在频域内对图像进行处理，再通过逆傅里叶变换得到修改后的空域图像，就必须同时保留幅度图像和相位图像。</p>
<p>​        对图像进行傅里叶变换后，我们会得到图像中的低频和高频信息。<strong>低频信息对应图像内变化缓慢的灰度分量。 高频信息对应图像内变化越来越快的灰度分量，是由灰度的尖锐过渡造成的</strong>。例如，在一幅大草原的图像中有一头狮子，低频信息就对应着广袤的颜色趋于一致的草原等细节信息，而高频信息则对应着狮子的轮廓等各种边缘及噪声信息。</p>
<p>​        对于不同频段的信息，滤波器能够允许一定频率的分量通过或者拒绝其通过，按照其作用方式可以划分为低通滤波器和高通滤波器。</p>
<ul>
<li>
<p><strong>允许低频信号通过的滤波器称为低通滤波器</strong>。低通滤波器使高频信号衰减而对低频信号放行，会使图像变模糊。</p>
</li>
<li>
<p><strong>允许高频信号通过的滤波器称为高通滤波器</strong>。高通滤波器使低频信号衰减而让高频信号通过，将增强图像中尖锐的细节， 但是会导致图像的对比度降低。</p>
</li>
</ul>
<p>傅里叶变换可以将图像的高频信号和低频信号分离。那么就可以对傅里叶变换得到的高频信号和低频信号分别进行处理，例如高通滤波或者低通滤波。在对图像的高频或低频信号进行处理后，再进行逆傅里叶变换返回空域，就完成了对图像的频域处理。通过对图像的频域处理，可以实现图像增强、图像去噪、边缘检测、特征提取、压缩和加密等操作。</p>
<h3 id="PS-什么是时域（空间域），什么是频域">PS.什么是时域（空间域），什么是频域</h3>
<p>从我们出生，我们看到的世界都以时间贯穿，股票的走势、人的身高、汽车的轨迹都会随着时间发生改变。这种以时间作为参照来观察动态世界的方法我们称其为时域分析。而我们也想当然的认为，世间万物都在随着时间不停的改变，并且永远不会静止下来。但如果我告诉你，用另一种方法来观察世界的话，你会发现<strong>世界是永恒不变的</strong>，你会不会觉得我疯了？我没有疯，这个静止的世界就叫做<strong>频域</strong>。</p>
<p>先举一个<strong>公式上并非很恰当</strong>，但意义上再贴切不过的例子：</p>
<p>在你的理解中，一段音乐是什么呢？是其在时域内的表现</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="88.png" style="zoom: 100%;" />
<p>这是我们对音乐最普遍的理解，一个随着时间变化的震动。但我相信对于乐器小能手们来说，音乐更直观的理解是这样的：是其在频域内的表现</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="89.png" style="zoom: 100%;" />
<p>在时域，我们观察到钢琴的琴弦一会上一会下的摆动，就如同一支股票的走势；而在频域，只有那一个永恒的音符。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="87.png" style="zoom: 80%;" />
<p>从信号的角度来讲，时间方向是时域，因为信号是随时间变化的。但从图像的角度讲，这个方向应该称作空间的方向，也就是空间域，因为图像在空间的不同位置的表示是不一样的。</p>
<blockquote>
<p>But what does frequency spectrum means in case of images?</p>
</blockquote>
<p>The “mathematical equations” are important, so don’t skip them entirely. But the 2d FFT has an intuitive interpretation, too. For illustration, I’ve calculated the inverse FFT of a few sample images:</p>
<p>“数学方程式”很重要，所以不要完全跳过它们。但是2d FFT 也有一个直观的解释。为了说明，我已经计算了一些样本图像的反 FFT:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="93.png" style="zoom: 80%;" />
<p>As you can see, only one pixel is set in the frequency domain. The result in the image domain (I’ve only displayed the real part) is a “rotated cosine pattern” (the imaginary part would be the corresponding sine).</p>
<p>If I set a different pixel in the frequency domain (at the left border):</p>
<p>正如你所看到的，只有一个像素是设置在频率域。图像域中的结果(我只显示了实部)是一个“旋转余弦图案”(虚部将是对应的正弦)。</p>
<p>如果我在频率域(左边框)设置不同的像素:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="94.png" style="zoom: 80%;" />
<p>I get a different 2d frequency pattern.</p>
<p>If I set more than one pixel in the frequency domain:</p>
<p>我得到了一个不同的二维频率模式。</p>
<p>如果我在频率域设置多于一个像素:</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="95.png" style="zoom: 80%;" />
<p>you get the sum of two cosines.</p>
<p>So like a 1d wave, that can be represented as a sum of sines and cosines, any 2d image can be represented (loosely speaking) as a sum of “rotated sines and cosines”, as shown above.</p>
<blockquote>
<p>when we take fft of a image in opencv, we get weird picture. What does this image denote?</p>
</blockquote>
<p>It denotes the amplitudes and frequencies of the sines/cosines that, when added up, will give you the original image.</p>
<blockquote>
<p>And what is its application?</p>
</blockquote>
<p>There are really too many to name them all. Correlation and convolution can be calculated very efficiently using an FFT, but that’s more of an optimization, you don’t “look” at the FFT result for that. It’s used for image compression, because the high frequency components are usually just noise.</p>
<p>你会得到两个余弦的和。</p>
<p>就像一维波，可以表示为正弦和余弦的和，任何二维图像都可以表示为“旋转正弦和余弦”的和，如上所示。</p>
<p>当我们在 opencv 中对一幅图像进行傅立叶变换时，我们得到了一幅奇怪的图像，这幅图像代表了什么？</p>
<p>它表示正弦/余弦的振幅和频率，加起来就是原始图像。</p>
<p>它的应用是什么？</p>
<p>实在是太多了，无法一一列举。使用 FFT，相关性和卷积可以非常有效地计算，但这是一个更优化，FFT的结果并不以此为目的。因为高频部分通常只是噪音，所以它被用于图像压缩。</p>
<h2 id="Numpy中的傅里叶变换">Numpy中的傅里叶变换</h2>
<p>首先，我们将看到如何使用Numpy查找傅立叶变换。Numpy具有FFT软件包来执行此操作。<strong>np.fft.fft2</strong>()为我们提供了频率转换，它将是一个复杂的数组。它的第一个参数是输入图像，即灰度图像。第二个参数是可选的，它决定输出数组的大小。如果它大于输入图像的大小，则在计算FFT之前用零填充输入图像。如果小于输入图像，将裁切输入图像。如果未传递任何参数，则输出数组的大小将与输入的大小相同。</p>
<p>现在，一旦获得结果，零频率分量（DC分量）将位于左上角。如果要使其居中，则需要在两个方向上将结果都移动<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mstyle displaystyle="true" scriptlevel="0"><mfrac><mi>N</mi><mn>2</mn></mfrac></mstyle></mrow><annotation encoding="application/x-tex">\dfrac{N}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">2</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>。只需通过函数<strong>np.fft.fftshift</strong>()即可完成。（它更容易分析）。找到频率变换后，就可以找到幅度谱。</p>
<p>那么，对于这张图，<strong>越靠近中心，频率越低</strong>。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&quot;image\\1.png&quot;</span>,<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    f = np.fft.fft2(img)</span><br><span class="line">    fshift = np.fft.fftshift(f)</span><br><span class="line">    <span class="comment">#对图像进行傅里叶变换后，得到的是一个复数数组。为了显示为图像，需要将它们的值调整到[0,255]的灰度空间内</span></span><br><span class="line">    magnitude_spectrum = <span class="number">20</span> * np.log(np.<span class="built_in">abs</span>(fshift))</span><br><span class="line">    plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">122</span>), plt.imshow(magnitude_spectrum, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="90.png" style="zoom: 80%;" />
<h3 id="高通滤波">高通滤波</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&quot;image\\1.png&quot;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    f = np.fft.fft2(img)</span><br><span class="line">    fshift = np.fft.fftshift(f)</span><br><span class="line">    rows, cols = img.shape</span><br><span class="line">    crow, ccol = <span class="built_in">int</span>(rows / <span class="number">2</span>), <span class="built_in">int</span>(cols / <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 中间30*30的像素置为0</span></span><br><span class="line">    fshift[crow - <span class="number">30</span>:crow + <span class="number">30</span>, ccol - <span class="number">30</span>:ccol + <span class="number">30</span>] = <span class="number">0</span></span><br><span class="line">    ishift = np.fft.ifft2(fshift)</span><br><span class="line">    iimg = np.<span class="built_in">abs</span>(ishift)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">122</span>), plt.imshow(iimg, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;iimg&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="91.png" style="zoom: 80%;" />
<p>但这样的高通滤波在图像中会显示出一些波纹状结构，称为<strong>振铃效应</strong>。这是由我们用于遮罩的矩形窗口引起的。此掩码转换为正弦形状，从而导致此问题。因此，矩形窗口不用于过滤。更好的选择是高斯窗口。</p>
<h2 id="OpenCV中的傅里叶变换">OpenCV中的傅里叶变换</h2>
<p>OpenCV为此提供了<strong>cv.dft</strong>()和<strong>cv.idft</strong>()函数。它返回与前一个相同的结果，但是有两个通道。第一个通道是结果的实部，第二个通道是结果的虚部。输入图像首先应转换为<code>np.float32</code>。我们来看看怎么做。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&quot;image\\1.png&quot;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    dft = cv.dft(np.float32(img), flags=cv.DFT_COMPLEX_OUTPUT)</span><br><span class="line">    dft_shift = np.fft.fftshift(dft)</span><br><span class="line">    magnitude_spectrum = <span class="number">20</span> * np.log(cv.magnitude(dft_shift[:, :, <span class="number">0</span>], dft_shift[:, :, <span class="number">1</span>]))</span><br><span class="line">    plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">122</span>), plt.imshow(magnitude_spectrum, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<h3 id="低通滤波">低通滤波</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&quot;image\\1.png&quot;</span>, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    dft = cv.dft(np.float32(img), flags=cv.DFT_COMPLEX_OUTPUT)</span><br><span class="line">    dft_shift = np.fft.fftshift(dft)</span><br><span class="line">    magnitude_spectrum = <span class="number">20</span> * np.log(cv.magnitude(dft_shift[:, :, <span class="number">0</span>], dft_shift[:, :, <span class="number">1</span>]))</span><br><span class="line"></span><br><span class="line">    rows, cols = img.shape</span><br><span class="line">    crow, ccol = <span class="built_in">int</span>(rows / <span class="number">2</span>), <span class="built_in">int</span>(cols / <span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 首先创建一个掩码，中心正方形为1，其余全为零</span></span><br><span class="line">    mask = np.zeros((rows, cols, <span class="number">2</span>), np.uint8)</span><br><span class="line">    mask[crow - <span class="number">30</span>:crow + <span class="number">30</span>, ccol - <span class="number">30</span>:ccol + <span class="number">30</span>] = <span class="number">1</span></span><br><span class="line">    <span class="comment"># 应用掩码和逆DFT</span></span><br><span class="line">    fshift = dft_shift * mask</span><br><span class="line">    f_ishift = np.fft.ifftshift(fshift)</span><br><span class="line">    img_back = cv.idft(f_ishift)</span><br><span class="line">    img_back = cv.magnitude(img_back[:, :, <span class="number">0</span>], img_back[:, :, <span class="number">1</span>])</span><br><span class="line">    plt.subplot(<span class="number">121</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Input Image&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.subplot(<span class="number">122</span>), plt.imshow(img_back, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Magnitude Spectrum&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="92.png" style="zoom: 80%;" />
<h3 id="踩坑">踩坑</h3>
<p>滤波时，<code>  crow, ccol = int(rows / 2), int(cols / 2)</code>而不能用<code>  crow, ccol = rows / 2, cols / 2</code>，后者会报错<code>slice indices must be integers or None or have an __index__ method</code>，因为除法返回的是浮点值，不能直接用于二维数组索引。</p>
<p>或者将<code>/</code>改为<code>//</code>。</p>
<h2 id="DFT的性能优化">DFT的性能优化</h2>
<p>对于某些数组尺寸，DFT的计算性能较好。当数组大小为2的幂时，速度最快。对于大小为2、3和5的乘积的数组，也可以非常有效地进行处理。因此，如果您担心代码的性能，可以在找到DFT之前将数组的大小修改为任何最佳大小(通过填充零)。对于OpenCV，您必须手动填充零。但是对于Numpy，您指定FFT计算的新大小，它将自动为您填充零。</p>
<p>那么如何找到最优的大小呢?OpenCV为此提供了一个函数，<strong>cv.getOptimalDFTSize</strong>()。它同时适用于<strong>cv.dft</strong>()和<strong>np.fft.fft2</strong>()。让我们使用IPython魔术命令timeit来检查它们的性能。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">16</span>]: img = cv.imread(<span class="string">&#x27;messi5.jpg&#x27;</span>,<span class="number">0</span>)</span><br><span class="line">In [<span class="number">17</span>]: rows,cols = img.shape</span><br><span class="line">In [<span class="number">18</span>]: <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(rows,cols))</span><br><span class="line"><span class="number">342</span> <span class="number">548</span></span><br><span class="line">In [<span class="number">19</span>]: nrows = cv.getOptimalDFTSize(rows)</span><br><span class="line">In [<span class="number">20</span>]: ncols = cv.getOptimalDFTSize(cols)</span><br><span class="line">In [<span class="number">21</span>]: <span class="built_in">print</span>(<span class="string">&quot;&#123;&#125; &#123;&#125;&quot;</span>.<span class="built_in">format</span>(nrows,ncols))</span><br><span class="line"><span class="number">360</span> <span class="number">576</span></span><br></pre></td></tr></table></figure>
<p>参见，将大小<code>(342,548)</code>修改为<code>(360，576)</code>。现在让我们用零填充（对于OpenCV），并找到其DFT计算性能。您可以通过创建一个新的零数组并将数据复制到其中来完成此操作，或者使用<strong>cv.copyMakeBorder</strong>()。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nimg = np.zeros((nrows,ncols))</span><br><span class="line">nimg[:rows,:cols] = img</span><br></pre></td></tr></table></figure>
<p>或者:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">right = ncols - cols</span><br><span class="line">bottom = nrows - rows</span><br><span class="line">bordertype = cv.BORDER_CONSTANT ＃只是为了避免PDF文件中的行中断</span><br><span class="line">nimg = cv.copyMakeBorder(img,<span class="number">0</span>,bottom,<span class="number">0</span>,right,bordertype, value = <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>现在，我们计算Numpy函数的DFT性能比较：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">22</span>]: %timeit fft1 = np.fft.fft2(img)</span><br><span class="line"><span class="number">10</span> loops, best of <span class="number">3</span>: <span class="number">40.9</span> ms per loop</span><br><span class="line">In [<span class="number">23</span>]: %timeit fft2 = np.fft.fft2(img,[nrows,ncols])</span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">10.4</span> ms per loop</span><br></pre></td></tr></table></figure>
<p>它显示了4倍的加速。现在，我们将尝试使用OpenCV函数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">In [<span class="number">24</span>]: %timeit dft1= cv.dft(np.float32(img),flags=cv.DFT_COMPLEX_OUTPUT)</span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">13.5</span> ms per loop</span><br><span class="line">In [<span class="number">27</span>]: %timeit dft2= cv.dft(np.float32(nimg),flags=cv.DFT_COMPLEX_OUTPUT)</span><br><span class="line"><span class="number">100</span> loops, best of <span class="number">3</span>: <span class="number">3.11</span> ms per loop</span><br></pre></td></tr></table></figure>
<p>它还显示了4倍的加速。您还可以看到OpenCV函数比Numpy函数快3倍左右。也可以对逆FFT进行测试，这留给您练习。</p>
<h1>模板匹配</h1>
<p>模板匹配是一种用于在较大图像中搜索和查找模板图像位置的方法。为此，OpenCV带有一个函数<code>cv.matchTemplate()</code>。 它只是将模板图像滑动到输入图像上（就像在2D卷积中一样），然后在模板图像下比较模板和输入图像的拼图。 OpenCV中实现了几种比较方法。（您可以检查文档以了解更多详细信息）。<strong>它返回一个灰度图像，其中每个像素表示该像素的邻域与模板匹配的程度</strong>。</p>
<blockquote>
<p><strong>注意</strong> 如果使用<strong>cv.TM_SQDIFF</strong>作为比较方法，则最小值提供最佳匹配。</p>
</blockquote>
<h2 id="函数-11">函数</h2>
<p>在OpenCV内， 模板匹配是使用函数cv2.matchTemplate(）实现的。 该函数的语法格式为：<code>result=cv2.matchTemplate (image,templ,method[,mask]) </code><br>
其中：</p>
<ul>
<li>image为原始图像， 必须是8位或者32位的浮点型图像。</li>
<li>templ为模板图像。 <strong>它的尺寸必须小于或等于原始图像， 并且与原始图像具有同样的类型</strong>。</li>
<li>method为匹配方法。 该参数通过 <code>TemplateMatchModes</code>实现， 有6种可能的值。</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="96.png" style="zoom: 80%;" />
<ul>
<li>mask 为模板图像掩模。它必须和模板图像 tempi 具有相同的类型和大小。通常情况下该值使用默认值即可。当前，该参数仅支持TM_SQDIFF和TM_CCORR_NORMED两个值。</li>
</ul>
<p>如果输入图像的大小为<code>(WxH)</code>，而模板图像的大小为<code>(wxh)</code>，<strong>则输出图像的大小将为<code>(W - w + 1，H - h + 1)</code></strong>。</p>
<p>这是因为，在进行模板匹配时， 模板在原始图像内遍历。 在水平方向上：</p>
<ul>
<li>
<p>遍历的起始坐标是原始图像左数第1个像素值（序号从1开始）。</p>
</li>
<li>
<p>最后一次比较是当模板图像位于原始图像的最右侧时， 此时其左上角像素点所在的位置是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>−</mo><mi>w</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">W-w+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p>
</li>
</ul>
<p>因此， 返回值result在水平方向上的大小是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>W</mi><mo>−</mo><mi>w</mi><mo>+</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">W-w+1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">W</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.66666em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>（水平方向上的比较次数）。竖直方向同理。</p>
<hr>
<p>得到结果后，可以使用<code>cv.minMaxLoc()</code>函数查找最大/最小值在哪。将其作为矩形的左上角，并以<code>(w，h)</code>作为矩形的宽度和高度。该矩形是您模板的区域。</p>
<p>这里需要注意的是 ， <strong>函数<code>cv2.matchTemplate()</code>通过参数method来决定使用不同的查找方法。对千不同的查找方法， 返回值result具有不同的含义</strong>。 例如：</p>
<ul>
<li>
<p>method的值为<code>cv2.TM_SQDIFF</code>和<code>cv2.TM_SQDIFF_NORMED</code>时 ， result值为0表示匹配度最小，值越大 ， 表示匹配度越差。</p>
</li>
<li>
<p>method 的值为 <code>cv2.TM_CCORR </code>、<code>cv2.TM_CCORR_NORMED</code>、<code>cv2.TM_CCOEFF </code>和<code>cv2.TM_CCOEFF _NORMED</code>时， result的值越小表示匹配度越差， 值越大表示匹配度越好。</p>
</li>
</ul>
<p>从上述分析可以看出 ， 查找方法不同， 结果的判定方式也不同。 <strong>在查找最佳匹配时 ， 首先要确定使用的是何种method, 然后再确定到底是查找最大值， 还是查找最小值</strong>。</p>
<p>查找最值（极值）与最值所在的位置， 可以使用<code> cv2.minMaxLoc()</code> 函数实现。 该函数语法格式如下：</p>
<p><code>minVal,maxVal,minLoc,maxLoc=cv2.minMaxLoc (src[,mask])</code></p>
<p>其中：</p>
<ul>
<li><code>src</code>为<strong>单通道数组</strong>。</li>
<li><code>minVal</code>为返回的最小值， 如果没有最小值， 则可以是NULL（空值）。</li>
<li><code>maxVal</code>为返回的最大值， 如果没有最小值， 则可以是NULL。</li>
<li><code>minLoc</code>为最大值的位置， 如果没有最大值， 则可以是NULL。</li>
<li><code>maxLoc</code>为最大值的位置， 如果没有最大值， 则可以是NULL。</li>
</ul>
<h2 id="单模板匹配">单模板匹配</h2>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&quot;image\\0.png&quot;</span>, <span class="number">0</span>)</span><br><span class="line">    img2 = img.copy()</span><br><span class="line">    target = cv.imread(<span class="string">&#x27;image\\target-0.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    w, h = target.shape[::-<span class="number">1</span>]</span><br><span class="line">    <span class="comment"># 列表中所有的6种比较方法</span></span><br><span class="line">    methods = [<span class="string">&#x27;cv.TM_CCOEFF&#x27;</span>, <span class="string">&#x27;cv.TM_CCOEFF_NORMED&#x27;</span>, <span class="string">&#x27;cv.TM_CCORR&#x27;</span>,</span><br><span class="line">               <span class="string">&#x27;cv.TM_CCORR_NORMED&#x27;</span>, <span class="string">&#x27;cv.TM_SQDIFF&#x27;</span>, <span class="string">&#x27;cv.TM_SQDIFF_NORMED&#x27;</span>]</span><br><span class="line">    l = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> meth <span class="keyword">in</span> methods:</span><br><span class="line">        img = img2.copy()</span><br><span class="line">        method = <span class="built_in">eval</span>(meth)</span><br><span class="line">        <span class="comment"># 应用模板匹配</span></span><br><span class="line">        res = cv.matchTemplate(img, target, method)</span><br><span class="line">        min_val, max_val, min_loc, max_loc = cv.minMaxLoc(res)</span><br><span class="line">        <span class="comment"># 如果方法是TM_SQDIFF或TM_SQDIFF_NORMED，则取最小值</span></span><br><span class="line">        <span class="keyword">if</span> method <span class="keyword">in</span> [cv.TM_SQDIFF, cv.TM_SQDIFF_NORMED]:</span><br><span class="line">            top_left = min_loc</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            top_left = max_loc</span><br><span class="line">        bottom_right = (top_left[<span class="number">0</span>] + w, top_left[<span class="number">1</span>] + h)</span><br><span class="line">        cv.rectangle(img, top_left, bottom_right, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">        plt.subplot(<span class="number">6</span>, <span class="number">2</span>, l), plt.imshow(res, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;Matching Result&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">        plt.subplot(<span class="number">6</span>, <span class="number">2</span>, l + <span class="number">1</span>), plt.imshow(img, cmap=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line">        plt.title(meth), plt.xticks([]), plt.yticks([])</span><br><span class="line">        l = l + <span class="number">2</span></span><br><span class="line">   </span><br><span class="line">    plt.show()</span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>但显然，相关系数匹配在这张图片中出了问题，而且其他图片也有类似的问题</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="97.png" style="zoom: 80%;" />
<h2 id="多模板匹配">多模板匹配</h2>
<p>在前面的例子中，我们搜索的子图在整个输入图像内仅出现了一次。但是，有些情况下，要搜索的模板图像很可能在输入图像内出现了多次，这时就需要找出多个匹配结果。而函数<code>cv2.minMaxLoc()</code>仅仅能够找出最值，无法给出所有匹配区域的位置信息。所以，要想匹配多个结果，使用函数<code>cv2.minMaxLoc()</code>是无法实现的需要利用阈值进行处理。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img_rgb = cv.imread(<span class="string">&#x27;image\\4.png&#x27;</span>)</span><br><span class="line">    img_gray = cv.cvtColor(img_rgb, cv.COLOR_BGR2GRAY)</span><br><span class="line">    target = cv.imread(<span class="string">&#x27;image\\target-4.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    w, h = target.shape[::-<span class="number">1</span>]</span><br><span class="line">    res = cv.matchTemplate(img_gray, target, cv.TM_CCOEFF_NORMED)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#这里的阈值是自己定的</span></span><br><span class="line">    threshold = <span class="number">0.8</span></span><br><span class="line">    loc = np.where(res &gt;= threshold)</span><br><span class="line">    <span class="comment">#函数zip(）用可迭代的对象作为参数，将对象中对应的元素打包成一个个元组，然后返回由这些元组组成的列表。</span></span><br><span class="line">    <span class="keyword">for</span> pt <span class="keyword">in</span> <span class="built_in">zip</span>(*loc[::-<span class="number">1</span>]):</span><br><span class="line">        cv.rectangle(img_rgb, pt, (pt[<span class="number">0</span>] + w, pt[<span class="number">1</span>] + h), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">    cv.imwrite(<span class="string">&#x27;res.png&#x27;</span>, img_rgb)</span><br><span class="line"></span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<p>注意使用函数<code>numpy.where()</code>在函数<code>cv2.matchTemplate()</code>的输出值中查找指定值， 得到的形式&quot;（行号， 列号）＂的位置索引。但是，函数<code>cv2.rectangle()</code>中用于指定顶点的参数所使用的是形式为&quot;（列号， 行号）&quot;的位置索引。所以，在使用函数<code>cv2.rectangle() </code>绘制矩形前 ， 要先将函数<code> numpy.where()</code>得到的位置索引做“行列互换＂。可以使用如下语句实现loc内行列位置的互换：</p>
<p><code>loc[::-1] </code>，结果如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="98.png" style="zoom: 120%;" />
<p>注意到， 本来在函数<code>cv2.rectangle()</code>中设置的边界宽度为2, 但实际上标记出来的宽度远远大于2。这是因为在当前的区域内， 存在多个大于当前指定阈值0.8的情况，所以将它们都做了标记。这样，多个宽度为2的矩形就合在了一起，显得边界比较粗。可以尝试修改阈值，调整宽度，观察不同的演示效果。</p>
<h1>特征匹配</h1>
<p>本部分可以认为是上一部分地进阶。</p>
<p>​        大多数人都会玩拼图游戏。你会得到很多小图像，需要正确组装它们以形成大的真实图像。问题是，你怎么做？将相同的理论投影到计算机程序上，以便计算机可以玩拼图游戏呢？如果计算机可以玩拼图游戏，为什么我们不能给计算机提供很多自然风光的真实图像，并告诉计算机将所有这些图像拼接成一个大图像呢？如果计算机可以将多个自然图像缝合在一起，那么如何给建筑物或任何结构提供大量图片并告诉计算机从中创建3D模型呢？</p>
<p>​        好了，问题和想象力还在继续。但这全都取决于最基本的问题：你如何玩拼图游戏？你如何将许多被扰的图像片段排列成一个大的单张图像？你如何将许多自然图像拼接到一张图像上？</p>
<p>​        答案是，我们正在寻找<strong>独特的，易于跟踪和比较的特定模板或特定特征</strong>。如果我们对这种特征进行定义，可能会发现很难用语言来表达它，但是我们知道它们是什么。如果有人要求你指出一项可以在多张图像中进行比较的良好特征，则可以指出其中一项。这就是为什么即使是小孩也可以玩这些游戏的原因。我们在图像中搜索这些特征，找到它们，在其他图像中寻找相同的特征并将它们对齐。仅此而已。（在拼图游戏中，我们更多地研究了不同图像的连续性）。所有这些属性都是我们固有的。</p>
<p>​        因此，我们的一个基本问题扩展到更多，但变得更加具体。这些特征是什么？（答案对于计算机也应该是可以理解的。）</p>
<p>​        很难说人类如何发现这些特征。这已经在我们的大脑中进行了编码。但是，如果我们深入研究某些图片并搜索不同的模板，我们会发现一些有趣的东西。例如，看以下的图片：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="125.png" style="zoom: 80%;" />
<p>​        图像非常简单。在图像的顶部，给出了六个小图像块。你的问题是在原始图像中找到这些补丁的确切位置。你可以找到多少正确的结果？</p>
<p>​        A和B是平坦的表面，它们散布在很多区域上。很难找到这些补丁的确切位置。</p>
<p>​        C和D更简单。它们是建筑物的边缘。你可以找到一个大概的位置，但是准确的位置仍然很困难。这是因为沿着边缘的每个地方的图案都是相同的。但是，在边缘，情况有所不同。因此，与平坦区域相比，边缘是更好的特征，但不够好（在拼图游戏中比较边缘的连续性很好）。</p>
<p>​        最后，E和F是建筑物的某些角落。而且很容易找到它们。因为在拐角处，无论将此修补程序移动到何处，它的外观都将有所不同。因此，它们可以被视为很好的特征。因此，现在我们进入更简单（且被广泛使用的图像）以更好地理解。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="126.png" style="zoom: 80%;" />
<p>​        就像上面一样，蓝色补丁是平坦区域，很难找到和跟踪。无论你将蓝色补丁移到何处，它看起来都一样。黑色补丁有一个边缘。如果你沿垂直方向（即沿渐变）移动它，则它会发生变化。沿着边缘（平行于边缘）移动，看起来相同。对于红色补丁，这是一个角落。无论你将补丁移动到何处，它看起来都不同，这意味着它是<strong>唯一的</strong>。因此，基本上，拐点被认为是图像中的良好特征。（不仅是角落，在某些情况下，斑点也被认为是不错的功能）。</p>
<p>​        因此，现在我们回答了我们的问题，“这些特征是什么？”。但是出现了下一个问题。我们如何找到它们？还是我们如何找到角落？我们以一种直观的方式回答了这一问题，即寻找图像中在其周围所有区域中移动（少量）变化最大的区域。在接下来的章节中，这将被投影到计算机语言中。因此，找到这些图像特征称为特征检测。</p>
<p>​        我们在图像中找到了特征。找到它之后，你应该能够在其他图像中找到相同的图像。怎么做？我们围绕该特征采取一个区域，我们用自己的语言解释它，例如“上部是蓝天，下部是建筑物的区域，在建筑物上有玻璃等”，而你在另一个建筑物中搜索相同的区域图片。基本上，你是在描述特征。同样，计算机还应该描述特征周围的区域，以便可以在其他图像中找到它。所谓的描述称为<strong>特征描述</strong>。获得特征及其描述后，你可以在所有图像中找到相同的功能并将它们对齐，缝合在一起或进行所需的操作。</p>
<p>​        因此，在此模块中，我们正在寻找OpenCV中的不同算法来查找功能，对其进行描述，进行匹配等。</p>
<h2 id="哈里斯角检测">哈里斯角检测</h2>
<h3 id="原理-10">原理</h3>
<p>[论文原文](<a href="https://zwn2001.github.io/2022/02/26/opencv-basic/A">https://zwn2001.github.io/2022/02/26/opencv-basic/A</a> Combined Corner and Edge Detector.pdf)</p>
<p>在上一部分中，我们看到角是图像中各个方向上强度变化很大的区域。<strong>Chris Harris和Mike Stephens在1988年的论文《组合式拐角和边缘检测器</strong>》中做了一次尝试找到这些拐角的尝试，所以现在将其称为哈里斯拐角检测器。他把这个简单的想法变成了数学形式。它基本上找到了<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>u</mi><mtext>，</mtext><mi>v</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(u，v)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">u</span><span class="mord cjk_fallback">，</span><span class="mord mathnormal" style="margin-right:0.03588em;">v</span><span class="mclose">)</span></span></span></span>在所有方向上位移的强度差异。表示如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="127.png" style="zoom: 100%;" />
<p>可以用如下图来表示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="128.png" style="zoom: 100%;" />
<h3 id="函数-12">函数</h3>
<p><code>cv.cornerHarris(img,blockSize,ksize,k)</code></p>
<p>其参数为：</p>
<ul>
<li>img 输入图像，应为<strong>灰度和float32类型</strong>。</li>
<li>blockSize 是拐角检测考虑的<strong>邻域大小</strong></li>
<li>ksize 使用的Sobel导数的光圈参数。</li>
<li>k 等式中的哈里斯检测器自由参数。</li>
<li>dst 返回值，灰度图像</li>
</ul>
<p><code>corners = cv2.cornerSubPix(gray, np.float32(centroids), (5, 5), (-1, -1), criteria)</code><br>
具有亚像素精度的角点：有时可能需要以最大的精度找到角点。OpenCV附带了一个函数cv2.cornerSubPix（），它可以进一步细化以亚像素精度检测到的角点。</p>
<h3 id="样例">样例</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&#x27;image\\0.jpg&#x27;</span>)</span><br><span class="line">    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    <span class="comment"># 寻找哈里斯角</span></span><br><span class="line">    gray = np.float32(gray)</span><br><span class="line">    dst = cv.cornerHarris(gray, <span class="number">2</span>, <span class="number">3</span>, <span class="number">0.04</span>)</span><br><span class="line">    dst = cv.dilate(dst, <span class="literal">None</span>)<span class="comment">#膨胀</span></span><br><span class="line">    ret, dst = cv.threshold(dst, <span class="number">0.01</span> * dst.<span class="built_in">max</span>(), <span class="number">255</span>, <span class="number">0</span>)</span><br><span class="line">    cv.imshow(<span class="string">&quot;dst&quot;</span>, dst)</span><br><span class="line">    dst = np.uint8(dst)</span><br><span class="line">    <span class="comment"># 寻找质心</span></span><br><span class="line">    ret1, labels, stats, centroids = cv.connectedComponentsWithStats(dst)</span><br><span class="line">    <span class="comment"># 定义停止和完善拐角的条件</span></span><br><span class="line">    criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, <span class="number">100</span>, <span class="number">0.001</span>)</span><br><span class="line">    corners = cv.cornerSubPix(gray, np.float32(centroids), (<span class="number">5</span>, <span class="number">5</span>), (-<span class="number">1</span>, -<span class="number">1</span>), criteria)</span><br><span class="line">    <span class="comment"># 绘制角点和细化的亚像素点</span></span><br><span class="line">    res = np.hstack((centroids, corners))</span><br><span class="line">    res = np.int0(res)</span><br><span class="line">    <span class="comment"># Harris角点用红色像素标记，精细角点用绿色像素标记</span></span><br><span class="line">    img[res[:, <span class="number">1</span>], res[:, <span class="number">0</span>]] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]</span><br><span class="line">    img[res[:, <span class="number">3</span>], res[:, <span class="number">2</span>]] = [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    gray = cv.cvtColor(gray, cv.COLOR_GRAY2BGR)</span><br><span class="line">    gray[res[:, <span class="number">1</span>], res[:, <span class="number">0</span>]] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]</span><br><span class="line">    gray[res[:, <span class="number">3</span>], res[:, <span class="number">2</span>]] = [<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>]</span><br><span class="line">    cv.imshow(<span class="string">&quot;gray&quot;</span>, gray)</span><br><span class="line">    cv.imshow(<span class="string">&#x27;cornerSubPix res&#x27;</span>, img)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="129.png" style="zoom: 100%;" />
<h2 id="Shi-tomas拐角检测器和益于跟踪的特征">Shi-tomas拐角检测器和益于跟踪的特征</h2>
<h3 id="原理-11">原理</h3>
<p>在上一章中，我们看到了Harris Corner Detector。1994年下半年，J。Shi和C. Tomasi在他们的论文《<strong>有益于跟踪的特征</strong>》中做了一个小修改，与Harris Harris Detector相比，显示了更好的结果。哈里斯角落探测器的计分功能由下式给出：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><msub><mi>λ</mi><mn>1</mn></msub><msub><mi>λ</mi><mn>2</mn></msub><mo>−</mo><mi>k</mi><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo>+</mo><msub><mi>λ</mi><mn>2</mn></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">R=λ_1λ_2−k(λ_1+λ_2)^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span></p>
<p>取而代之的是，史托马西提出：</p>
<p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo stretchy="false">(</mo><msub><mi>λ</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>λ</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">R=min(λ_1,λ_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span></p>
<p>如果大于阈值，则将其视为拐角。如果像在Harris Corner Detector中那样在<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub><mo>−</mo><msub><mi>λ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">λ_1−λ_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>空间中绘制它，则会得到如下图像：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="130.png" style="zoom: 100%;" />
<p>从图中可以看到，只有当<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">λ_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">λ_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>大于最小值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>λ</mi><mrow><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></mrow><annotation encoding="application/x-tex">λ_{min}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">λ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">min</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>时，才将其视为拐角（绿色区域）。</p>
<h3 id="样例-2">样例</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&#x27;image\\5.png&#x27;</span>)</span><br><span class="line">    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    corners = cv.goodFeaturesToTrack(gray, <span class="number">25</span>, <span class="number">0.01</span>, <span class="number">10</span>)</span><br><span class="line">    corners = np.int0(corners)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> corners:</span><br><span class="line">        x, y = i.ravel()</span><br><span class="line">        cv.circle(img, (x, y), <span class="number">3</span>, <span class="number">255</span>, -<span class="number">1</span>)</span><br><span class="line">    plt.imshow(img), plt.show()</span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="131.png" style="zoom: 40%;" />
<p>此功能更适合跟踪。我们将看到使用它的时机。</p>
<h2 id="SIFT尺度不变特征变换">SIFT尺度不变特征变换</h2>
<p>[论文原文](<a href="https://zwn2001.github.io/2022/02/26/opencv-basic/Distinctive">https://zwn2001.github.io/2022/02/26/opencv-basic/Distinctive</a> Image Features from Scale-Invariant Keypoints.pdf)</p>
<p>在前两章中，我们看到了一些像Harris这样的拐角检测器。它们是旋转不变的，这意味着即使图像旋转了，我们也可以找到相同的角。很明显，因为转角在旋转的图像中也仍然是转角。但是缩放呢？如果缩放图像，则拐角可能不是角。例如，检查下面的简单图像。在同一窗口中放大小窗口中小图像中的拐角时，该角是平坦的。因此，Harris拐角不是尺度不变的。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="132.png" style="zoom: 120%;" />
<p>因此，在2004年，不列颠哥伦比亚大学的D.Lowe在他的论文《尺度不变关键点中的独特图像特征》中提出了一种新算法，即尺度不变特征变换(SIFT)，该算法提取关键点并计算其描述算符。SIFT算法主要包括四个步骤。 我们将一一看到它们。</p>
<h1>霍夫变换</h1>
<p>霍夫变换是一种在图像中寻找直线、圆形以及其他简单形状的方法。霍夫变换采用类似于<strong>投票</strong>的方式来获取当前图像内的形状集合，该变换由 Paul Hough（霍夫）于1962年首次提出。最初的霍夫变换只能用于检测直线，经过发展后，霍夫变换不仅能够识别直线，还能识别其他简单的图形结构，常见的有圆、椭圆等。<br>
本章主要介绍霍夫直线变换和霍夫圆变换。霍夫直线变换用来在图像内寻找直线，霍夫圆变换用来在图像内寻找圆。在 OpenCV 中，前者可以用函数<code> cv2.HoughLines()</code>和函数<code>cv2.HoughLinesP()</code>实现， 后者可以用函数<code>cv2.HoughCircles()</code>实现。</p>
<h2 id="霍夫线变换">霍夫线变换</h2>
<h3 id="原理-12">原理</h3>
<p>一条直线可由两个点<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>1</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>1</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">A=(x_1,y_1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>=</mo><mo stretchy="false">(</mo><msub><mi>x</mi><mn>2</mn></msub><mo separator="true">,</mo><msub><mi>y</mi><mn>2</mn></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">B=(x_2,y_2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>确定(笛卡尔坐标)</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="99.png" style="zoom: 120%;" />
<p>另一方面，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mi>k</mi><mi>x</mi><mo>+</mo><mi>q</mi></mrow><annotation encoding="application/x-tex">y = kx + q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span></span></span></span>，也可以写成关于（k,q）的函数表达式（霍夫空间）：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="100.png" style="zoom: 100%;" />
<p>对应的变换可以通过图形直观表示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="101.png" style="zoom: 100%;" />
<p>变换后的空间成为<strong>霍夫空间</strong>。即：<strong>笛卡尔坐标系中一条直线，对应霍夫空间的一个点</strong>。</p>
<p>反过来同样成立（<strong>霍夫空间的一条直线，对应笛卡尔坐标系的一个点</strong>）：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="102.png" style="zoom: 100%;" />
<p>再来看看A、B两个点，对应霍夫空间的情形：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="103.png" style="zoom: 100%;" />
<p>一步步来，再看一下三个点共线的情况：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="104.png" style="zoom: 100%;" />
<hr>
<p><strong>根本原理：</strong></p>
<p><strong>可以看出如果笛卡尔坐标系的点共线，这些点在霍夫空间对应的直线交于一点：这也是必然，共线只有一种取值可能</strong>。那么，<strong>对于笛卡尔空间中的一条直线，直线上所有点在霍夫空间内对应的直线一定交于一点</strong>。霍夫变换的投票策略就类似于阈值处理，在某点相交的直线超过一定数量，则认为笛卡尔空间中存在这样的一条直线。</p>
<hr>
<p>如果不止一条直线呢？再看看多个点的情况（有两条直线）：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="105.png" style="zoom: 100%;" />
<p>其实（3，2）与（4，1）也可以组成直线，只不过它有两个点确定，而图中A、B两点是由三条直线汇成，这也是<strong>霍夫变换的后处理的基本方式</strong>：<strong>选择由尽可能多直线汇成的点</strong>。</p>
<p>看看，霍夫空间：选择由三条交汇直线确定的点（中间图），对应的笛卡尔坐标系的直线（右图）。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="106.png" style="zoom: 100%;" />
<p>到这里问题似乎解决了，已经完成了霍夫变换的求解，但是如果像下图这种情况呢？</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="107.png" style="zoom: 80%;" />
<p>k=∞是不方便表示的，而且q怎么取值呢，这样不是办法。因此考虑<strong>将笛卡尔坐标系换为：极坐标表示</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="108.png" style="zoom: 80%;" />
<p><strong>上图右边公式竟然是错的，极坐标公式如下，自己看的时候要修正下：</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://www.zhihu.com/equation?tex=xcos%5Ctheta+%2B+y+sin%5Ctheta%3D+%5Crho" alt="[公式]"></p>
<p>在极坐标系下，其实是一样的：<strong>极坐标的点→霍夫空间的直线，只不过霍夫空间不再是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>k</mi><mo separator="true">,</mo><mi>q</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(k,q)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">q</span><span class="mclose">)</span></span></span></span>的参数，而是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>ρ</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(\rho,\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">ρ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>的参数</strong>，给出对比图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="109.png" style="zoom: 80%;" />
<p><strong>如果线在原点下方通过，则它将具有正的ρ且角度小于180。如果线在原点上方，则将角度取为小于180，而不是大于180的角度。ρ取负值。任何垂直线将具有0度，水平线将具有90度</strong>。</p>
<p>现在，让我们看一下霍夫变换如何处理线条。任何一条线都可以用(ρ，θ)这两个术语表示。因此，首先创建2D数组或累加器（以保存两个参数的值），并将其初始设置为0。让行表示ρ，列表示θ。阵列的大小取决于所需的精度。假设您希望角度的精度为1度，则需要180列。对于ρ，最大距离可能是图像的对角线长度。因此，以一个像素精度为准，行数可以是图像的对角线长度。</p>
<p>考虑一个<code>100x100</code>的图像，中间有一条水平线。取直线的第一点。您知道它的<code>(x，y)</code>值。现在在线性方程式中，将值θ= 0,1,2，… 180放进去，然后检查得到ρ。对于每对(ρ，θ)，在累加器中对应的(ρ，θ)单元格将值增加1。所以现在在累加器中，单元格(50,90)= 1以及其他一些单元格。</p>
<p>现在，对行的第二个点。执行与上述相同的操作。递增(ρ，θ)对应的单元格中的值。这次，单元格<code>(50,90)=2</code>。实际上，您正在对(ρ，θ)值进行投票。您对线路上的每个点都继续执行此过程。在每个点上，单元格(50,90)都会增加或投票，而其他单元格可能会或可能不会投票。这样一来，最后，单元格(50,90)的投票数将最高。因此，如果您在累加器中搜索最大票数，则将获得(50,90)值，该值表示该图像中的一条线与原点的距离为50，角度为90度。在下面的动画中很好地显示了该图片(图片提供：Amos Storkey)</p>
<p>除此以外，也同样可以使用阈值对票数进行处理。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="111.gif" style="zoom: 140%;" />
<p><strong>也就是说我们遍历θ的值，从0-180°，并且同时代入（x,y）的值，求得对应的ρ。</strong></p>
<p><strong>找到0-180°中，哪个度数下的ρ值相同的数量最多。这反向说明了，在一个ρ和θ组成的函数中，符合的点数最多。</strong></p>
<h3 id="函数与示例">函数与示例</h3>
<p>函数cv2.HoughLines() 的语法格式为：<br>
<code>lines=cv2.HoughLines (image,rho,theta,threshold) </code><br>
式中：</p>
<ul>
<li>
<p>image是输入图像 ， 即源图像， <strong>必须是8位的单通道二值图像</strong>。 如果是其他类型的图像， 在进行霍夫变换之前， 需要将其修改为指定格式。</p>
<ul>
<li><strong>输入图像应该是二进制图像，因此在应用霍夫变换之前，建议应用阈值二值化或使用Canny边缘检测</strong>。</li>
</ul>
</li>
<li>
<p>rho为以像素为单位的距离ρ的精度，一般为1。</p>
</li>
<li>
<p>theta为角度θ的精度。 一般情况下， 使用的精度是<code>np.pi/180</code> ， 表示要搜索所有可能的角度。</p>
</li>
<li>
<p>threshold是阈值。 <strong>该值越小， 判定出的直线就越多</strong>。 通过上一节的分析可知，识别直线时，要判定有多少个点位千该直线上。在判定直线是否存在时，对直线所穿过的点的数星进行评估，如果直线所穿过的点的数量小于阈值，则认为这些点恰好（偶然）在算法上构成直线， 但是在源图像中该直线并不存在；如果大于阈值，则认为直线存在。所以，如果阈值较小，就会得到较多的直线；阈值较大，就会得到较少的直线。</p>
</li>
<li>
<p>返回值lines中的每个元素都是一对浮点数，表示检测到的直线的参数，即(ρ，θ)，<code>numpy.ndarray</code>类型。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&#x27;image\\hflines.png&#x27;</span>)</span><br><span class="line">    img2 = img.copy()</span><br><span class="line">    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    edges = cv.Canny(gray, <span class="number">50</span>, <span class="number">150</span>, apertureSize=<span class="number">3</span>)</span><br><span class="line">    lines = cv.HoughLines(edges, <span class="number">1</span>, np.pi / <span class="number">180</span>, <span class="number">200</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        rho, theta = line[<span class="number">0</span>]</span><br><span class="line">        a = np.cos(theta)</span><br><span class="line">        b = np.sin(theta)</span><br><span class="line">        x0 = a * rho</span><br><span class="line">        y0 = b * rho</span><br><span class="line">        x1 = <span class="built_in">int</span>(x0 + <span class="number">1000</span> * (-b))</span><br><span class="line">        y1 = <span class="built_in">int</span>(y0 + <span class="number">1000</span> * (a))</span><br><span class="line">        x2 = <span class="built_in">int</span>(x0 - <span class="number">1000</span> * (-b))</span><br><span class="line">        y2 = <span class="built_in">int</span>(y0 - <span class="number">1000</span> * (a))</span><br><span class="line">        cv.line(img, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">2</span>)</span><br><span class="line">    res = np.vstack((img2, img))</span><br><span class="line">    cv.imshow(<span class="string">&quot;res&quot;</span>,res)</span><br><span class="line"></span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="112.png" style="zoom: 60%;" />
<p>较粗的直线是因为有多条直线靠近在一起 ， 即检测出了重复的结果。 在一些情况下， 使用霍夫变换可能将图像中有限个点碰巧对齐的非直线关系检测为直线， 而导致误检测， 尤其是一些复杂背景的图像， 误检测会很明显。 此图中该间题虽然并不是特别明显， 但是如果将阈值 threshold的值设置得稍小些， 仍然会出现较多重复的检测结果。</p>
<h3 id="概率霍夫变换">概率霍夫变换</h3>
<p>概率霍夫变换对基本霍夫变换算法进行了一些修正，是霍夫变换算法的优化。它没有考虑所有的点。相反，它只需要一个足以进行线检测的随机点子集即可。</p>
<p>为了更好地判断直线（线段），概率霍夫变换算法还对选取直线的方法作了两点改进：</p>
<ul>
<li>
<p><strong>所接受直线的最小长度</strong>。如果有超过阈值个数的像素点构成了一条直线，但是这条直线很短，那么就不会接受该直线作为判断结果，而认为这条直线仅仅是图像中的若干个像素点恰好随机构成了一种算法上的直线关系而已，实际上原图中并不存在这条直线。</p>
</li>
<li>
<p><strong>接受直线时允许的最大像素点间距</strong>。如果有超过阈值个数的像素点构成了一条直线，但是这组像素点之间的距离都很远，就不会接受该直线作为判断结果，而认为这条直线仅仅是图像中的若干个像素点恰好随机构成了一种算法上的直线关系而已，实际上原始图像中并不存在这条直线。</p>
</li>
</ul>
<p>概率霍夫变换是我们看到的霍夫变换的优化。它没有考虑所有要点。取而代之的是，<strong>它仅采用随机的点子集，足以进行线检测。只是我们必须降低阈值</strong>。</p>
<h4 id="函数与示例-2">函数与示例</h4>
<p><code>lines = cv2.HoughLinesP(image, rho, theta, threshold, minLineLength,maxLineGap)</code></p>
<ul>
<li>
<p>image是输入图像，即源图像，必须为8位的单通道二值图像。对千其他类型的图像，在进行霍夫变换之前，需要将其修改为这个指定的格式。</p>
</li>
<li>
<p>rho为以像素为单位的距离ρ的精度，一般为1。</p>
</li>
<li>
<p>theta为角度θ的精度。 一般情况下， 使用的精度是<code>np.pi/180</code> ， 表示要搜索所有可能的角度。</p>
</li>
<li>
<p>threshold是阈值。 <strong>该值越小， 判定出的直线就越多</strong>。</p>
</li>
<li>
<p>minLineLength用来控制接受直线的最小长度，默认为0。</p>
</li>
<li>
<p>maxLineGap用来控制接受共线线段之间的最小间隔，即一条线中两点的最大间隔，默认为0。</p>
</li>
<li>
<p>返回值lines中的每个元素都是一对浮点数，表示检测到的直线的参数，即(ρ，θ)，<code>numpy.ndarray</code>类型。</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&#x27;image\\hflines.png&#x27;</span>)</span><br><span class="line">    img2 = img.copy()</span><br><span class="line">    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    edges = cv.Canny(gray, <span class="number">50</span>, <span class="number">150</span>, apertureSize=<span class="number">3</span>)</span><br><span class="line">    lines = cv.HoughLinesP(edges, <span class="number">1</span>, np.pi / <span class="number">180</span>, <span class="number">100</span>, minLineLength=<span class="number">100</span>, maxLineGap=<span class="number">10</span>)</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> lines:</span><br><span class="line">        x1, y1, x2, y2 = line[<span class="number">0</span>]</span><br><span class="line">        cv.line(img, (x1, y1), (x2, y2), (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">    res = np.vstack((img2, img))</span><br><span class="line">    cv.imshow(<span class="string">&quot;res&quot;</span>, res)</span><br><span class="line"></span><br><span class="line">    cv.waitKey()</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="113.png" style="zoom: 60%;" />
<p>细心观察可以发现，这里画出来的是线段。</p>
<h2 id="霍夫圆变换">霍夫圆变换</h2>
<p>圆在数学上表示为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>x</mi><mo>−</mo><msub><mi>x</mi><mrow><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>+</mo><mo stretchy="false">(</mo><mi>y</mi><mo>−</mo><msub><mi>y</mi><mrow><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow></msub><msup><mo stretchy="false">)</mo><mn>2</mn></msup><mo>=</mo><msup><mi>r</mi><mn>2</mn></msup></mrow><annotation encoding="application/x-tex">(x−x_{center})^2+(y−y_{center})^2=r^2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ce</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ce</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8141079999999999em;vertical-align:0em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span></span></span></span>，其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><msub><mi>x</mi><mrow><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow></msub><mo separator="true">,</mo><msub><mi>y</mi><mrow><mi>c</mi><mi>e</mi><mi>n</mi><mi>t</mi><mi>e</mi><mi>r</mi></mrow></msub><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(x_{center},y_{center})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ce</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.2805559999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">ce</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">er</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>是圆的中心，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span>是圆的半径。从等式中，我们可以看到我们有3个参数，因此我们需要3D累加器进行霍夫变换，这将非常低效。因此，OpenCV使用更加技巧性的方法，即使用边缘的梯度信息的<strong>Hough梯度方法</strong>。</p>
<p>这种方法采用的策略是两轮筛选。 <strong>第1轮筛选找出可能存在圆的位置（圆心）；第2轮再根据第1轮的结果筛选出半径大小</strong>。</p>
<p>与用来决定是否接受直线的两个参数”接受直线的最小长度 (<code>minLineLength</code>) ”和“接受直线时允许的最大像素点间距 (<code>MaxLineGap</code>) ”类似， 霍夫圆变换也有几个用于决定是否接受圆的参数：圆心间的最小距离、 圆的最小半径、 圆的最大半径。</p>
<h3 id="函数-13">函数</h3>
<p>在OpenCV中 ， 实现霍夫圆变换的是函数<code>cv2.HoughCircles ()</code>， <strong>该函数将Canny边缘检测和霍夫变换结合</strong>。 其语法格式为：</p>
<p><code>circles=cv2.HoughCircles (image, method, dp, minDist, param1, param2, minRadius, maxRadius) </code></p>
<ul>
<li>
<p><code>image</code>：输入图像， 即源图像， 类型为<strong>8位的单通道灰度图像</strong>。</p>
</li>
<li>
<p><code>method</code>: 检测方法。 截止到OpenCV 4.0.0-pre版本 ， HOUGH_GRADIENT是唯一可用的参数值。 该参数代表的是霍夫圆检测中两轮检测所使用的方法。</p>
</li>
<li>
<p><code>dp</code> ：<strong>累计器分辨率， 它是一个分割比率， 用来指定图像分辨率与圆心累加器分辨率的比例</strong>。 例如， 如果<code>dp=1</code>, 则输入图像和累加器具有相同的分辨率。</p>
</li>
<li>
<p><code>minDist</code>：<strong>圆心间的最小间距</strong>。 该值被作为阈值使用， 如果存在圆心间距离小于该值的多个圆，则仅有一个会被检测出来。 因此， 如果该值太小， 则会有多个临近的圆被检测出来；如果该值太大， 则可能会在检测时漏掉一些圆。</p>
</li>
<li>
<p><code>param1</code>: 该参数是缺省的 ， 在缺省时默认值为100。 它对应的是Canny边缘检测器的高阈值（<strong>低阈值是高阈值的二分之一</strong>）。</p>
</li>
<li>
<p><code>param2</code>: <strong>圆心位置必须收到的投票数</strong>。 只有在第1轮筛选过程中，投票数超过该值的圆，才有资格进入第2轮的筛选。 因此，该值越大，检测到的圆越少；该值越小，检测到的圆越多。这个参数是缺省的，在缺省时具有默认值100。</p>
</li>
<li>
<p><code>minRadius</code>：<strong>圆半径的最小值，小于该值的圆不会被检测出来</strong>。 该参数是缺省的，在缺省时具有默认值0，此时该参数不起作用。</p>
</li>
<li>
<p><code>maxRadius</code>：<strong>圆半径的最大值，大于该值的圆不会被检测出来</strong>。该参数是缺省的，在缺省时具有默认值0，此时该参数不起作用。</p>
</li>
<li>
<p><code>circles</code>: 返回值，由圆心坐标和半径构成的<code>numpy.ndarray</code>。</p>
</li>
</ul>
<p>​         需要特别注意，在调用函数 <code>cv2.HoughLinesCircles()</code>之前，要对源图像进行平滑操作，以减少图像中的噪声，避免发生误判。</p>
<h3 id="样例-3">样例</h3>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&#x27;image\\6.png&#x27;</span>, <span class="number">0</span>)</span><br><span class="line">    img = cv.medianBlur(img, <span class="number">5</span>)<span class="comment">#中值滤波</span></span><br><span class="line">    cimg = cv.cvtColor(img, cv.COLOR_GRAY2BGR)</span><br><span class="line">    circles = cv.HoughCircles(img, cv.HOUGH_GRADIENT, <span class="number">1</span>, <span class="number">20</span>,</span><br><span class="line">                              param1=<span class="number">50</span>, param2=<span class="number">50</span>, minRadius=<span class="number">0</span>, maxRadius=<span class="number">0</span>)</span><br><span class="line">    circles = np.uint16(np.around(circles))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> circles[<span class="number">0</span>, :]:</span><br><span class="line">        <span class="comment"># 绘制外圆</span></span><br><span class="line">        cv.circle(cimg, (i[<span class="number">0</span>], i[<span class="number">1</span>]), i[<span class="number">2</span>], (<span class="number">0</span>, <span class="number">255</span>, <span class="number">0</span>), <span class="number">2</span>)</span><br><span class="line">        <span class="comment"># 绘制圆心</span></span><br><span class="line">        cv.circle(cimg, (i[<span class="number">0</span>], i[<span class="number">1</span>]), <span class="number">2</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), <span class="number">3</span>)</span><br><span class="line">    img = cv.cvtColor(img, cv.COLOR_GRAY2BGR)</span><br><span class="line">    res = np.hstack((img, cimg))</span><br><span class="line">    cv.imshow(<span class="string">&#x27;detected circles&#x27;</span>, res)</span><br><span class="line">    cv.imwrite(<span class="string">&#x27;res.png&#x27;</span>, res)</span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="114.png" style="zoom: 100%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="116.png" style="zoom: 100%;" />
<p>注：不同图像间的检测需要调参，尤其是<code>parm2</code>，第二张图要调成32</p>
<h1>图像分割与提取</h1>
<h2 id="分水岭算法">分水岭算法</h2>
<h3 id="原理-13">原理</h3>
<p>​           任何灰度图像都可以看作是一个地形表面，其中高强度表示山峰，低强度表示山谷。你开始用不同颜色的水(标签)填充每个孤立的山谷(局部最小值)。随着水位的上升，根据附近的山峰(坡度)，来自不同山谷的水明显会开始合并，颜色也不同。为了避免这种情况，你要<strong>在水融合的地方建造屏障</strong>。你继续填满水，建造障碍，<strong>直到所有的山峰都在水下。然后你创建的屏障将返回你的分割结果</strong>。这就是Watershed背后的“思想”。</p>
<p>​        但是这种方法会由于图像中的噪声或其他不规则性而产生过度分割的结果。因此OpenCV实现了一个<strong>基于标记的分水岭算法</strong>，你可以指定哪些是要合并的山谷点，哪些不是。这是一个<strong>交互式的图像分割</strong>。我们所做的是给我们知道的对象赋予不同的标签。<strong>用一种颜色(或强度)标记我们确定为前景或对象的区域，用另一种颜色标记我们确定为背景或非对象的区域，最后用<code>0</code>标记我们不确定的区域</strong>。这是我们的标记。然后应用分水岭算法。然后我们的标记将使用我们给出的标签进行更新，对象的边界值将为<code>-1</code>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="115.gif" style="zoom: 120%;" />
<h3 id="使用">使用</h3>
<p>直接使用分水岭算法有时效果并不好，这是图像中的噪声、边界相交、模糊等原因导致的。</p>
<p>我们先从寻找硬币的近似估计开始。因此，我们可以使用Otsu二值化。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="117.png" style="zoom: 100%;" />
<p>现在我们需要去除图像中的任何白点噪声。为此，我们可以使用形态学扩张。要去除对象中的任何小孔，我们可以使用形态学侵蚀（开运算）。对于前景区域，我们可以使用距离变换函数找到。因此，现在我们可以确定，靠近对象中心的区域是前景，而离对象中心很远的区域是背景。<strong>我们不确定的唯一区域是硬币的边界区域</strong>。</p>
<p>因此，我们需要提取我们可确定为硬币的区域。侵蚀会去除边界像素。因此，无论剩余多少，我们都可以肯定它是硬币。如果物体彼此不接触，那将起作用。但是，由于它们彼此接触，因此另一个好选择是找到距离变换并应用适当的阈值。接下来，<strong>我们需要找到我们确定它们不是硬币的区域。为此，我们扩张了结果。膨胀将对象边界增加到背景。这样，由于边界区域已删除，因此我们可以确保结果中背景中的任何区域实际上都是背景</strong>。参见下图。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="119.png" alt="左侧为前景，右侧是确定的背景"></p>
<p>剩下的区域是我们不知道的区域，无论是硬币还是背景。分水岭算法应该找到它。这些区域通常位于前景和背景相遇（甚至两个不同的硬币相遇）的硬币边界附近。我们称之为<strong>边界</strong>。可以通过从确定的背景区域中减去确定的前景区域来获得。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="120.png" alt="边界"></p>
<p>查看结果。在阈值图像中，我们得到了一些硬币区域，我们确定它们是硬币，并且现在已分离它们。（在某些情况下，你可能只对前景分割感兴趣，而不对分离相互接触的对象感兴趣。在那种情况下，你无需使用距离变换，只需侵蚀就足够了。侵蚀只是提取确定前景区域的另一种方法。）</p>
<p>现在我们可以确定哪些是硬币的区域，哪些是背景。因此，我们创建了标记（它的大小与原始图像的大小相同，但具有int32数据类型），并标记其中的区域。<strong>我们肯定知道的区域（无论是前景还是背景）都标有任何正整数，但是带有不同的整数，而我们不确定的区域则保留为零</strong>。为此，我们使用<code>cv.connectedComponents()</code>。它用0标记图像的背景，然后其他对象用从1开始的整数标记。</p>
<p>但是我们知道，<strong>如果背景标记为0，则分水岭会将其视为未知区域。所以我们想用不同的整数来标记它。相反，我们将未知定义的未知区域标记为0</strong>。</p>
<p>现在我们的标记已准备就绪。现在是最后一步的时候了，使用分水岭算法。然后标记图像将被修改。边界区域将标记为-1。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"><span class="keyword">from</span> matplotlib <span class="keyword">import</span> pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&#x27;image\\0.jpg&#x27;</span>)</span><br><span class="line">    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    ret, thresh = cv.threshold(gray, <span class="number">0</span>, <span class="number">255</span>, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)</span><br><span class="line">    <span class="comment"># 噪声去除</span></span><br><span class="line">    kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">    <span class="comment">#这里进行了迭代，其实不迭代也还好</span></span><br><span class="line">    opening = cv.morphologyEx(thresh, cv.MORPH_OPEN, kernel, iterations=<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 确定背景区域</span></span><br><span class="line">    sure_bg = cv.dilate(opening, kernel, iterations=<span class="number">3</span>)</span><br><span class="line">    <span class="comment"># 寻找前景区域</span></span><br><span class="line">    dist_transform = cv.distanceTransform(opening, cv.DIST_L2, <span class="number">5</span>)</span><br><span class="line">    ret2, sure_fg = cv.threshold(dist_transform, <span class="number">0.7</span> * dist_transform.<span class="built_in">max</span>(), <span class="number">255</span>, cv.THRESH_BINARY)</span><br><span class="line">    <span class="comment"># 找到未知区域</span></span><br><span class="line">    sure_fg = np.uint8(sure_fg)</span><br><span class="line">    unknown = cv.subtract(sure_bg, sure_fg)</span><br><span class="line">    <span class="comment"># 类别标记</span></span><br><span class="line">    ret3, markers = cv.connectedComponents(sure_fg)</span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">131</span>)</span><br><span class="line">    plt.imshow(markers)</span><br><span class="line">    plt.title(<span class="string">&#x27;mark&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 为所有的标记加1，保证背景是1而不是0</span></span><br><span class="line">    markers = markers + <span class="number">1</span></span><br><span class="line">    <span class="comment"># 现在让所有的未知区域为0</span></span><br><span class="line">    markers[unknown == <span class="number">255</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    plt.subplot(<span class="number">132</span>)</span><br><span class="line">    plt.imshow(markers)</span><br><span class="line">    plt.title(<span class="string">&#x27;mark unknown&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line"></span><br><span class="line">    markers = cv.watershed(img, markers)</span><br><span class="line">    img[markers == -<span class="number">1</span>] = [<span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">    plt.subplot(<span class="number">133</span>)</span><br><span class="line">    plt.imshow(img)</span><br><span class="line">    plt.title(<span class="string">&#x27;watershed result&#x27;</span>), plt.xticks([]), plt.yticks([])</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="122.png" style="zoom: 100%;" />
<h3 id="距离变换函数distanceTransform">距离变换函数<code>distanceTransform()</code></h3>
<p>当图像内的各个子图没有连接时， 可以直接使用形态学的腐蚀操作确定前景对象， 但是如果图像内的子图连接在一起时，就很难确定前景对象了。此时，借助于距离变换函数<code>cv2.distanceTransform()</code>可以方便地将<strong>前景对象</strong>提取出来。</p>
<p><strong>距离变换函数<code>cv2.distanceTransform()</code>计算二值图像内任意点到最近背景点的距离</strong>。一般情况下，该函数计算的是图像内非零值像素点到最近的零值像素点的距离， 即计算二值图像中所有像素点距离其最近的值为0的像素点的距离。 当然， 如果像素点本身的值为0, 则这个距离也为0。</p>
<p>距离变换函数<code>cv2.distanceTransform()</code>的计算结果反映了各个像素与背景（值为0的像素点）的距离关系。 通常情况下：</p>
<ul>
<li>
<p>如果前景对象的中心（质心）距离值为0的像素点距离较远， 会得到一个较大的值。</p>
</li>
<li>
<p>如果前景对象的边缘距离值为0的像素点较近， 会得到一个较小的值。<br>
<strong>如果对上述计算结果进行阈值化， 就可以得到图像内子图的中心、 骨架等信息</strong>。 距离变换函数<code>cv2.distanceTransform()</code>可以用于计算对象的中心，还能细化轮廓、获取图像前景等，有多种功能。</p>
<ul>
<li>
<p>如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dist_transform = cv.distanceTransform(img, cv.DIST_L2, <span class="number">5</span>)</span><br><span class="line">ret2, sure_fg = cv.threshold(dist_transform, <span class="number">0.7</span> * dist_transform.<span class="built_in">max</span>(), <span class="number">255</span>, cv.THRESH_BINARY)</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>距离变换函数cv2.distanceTransform(）的语法格式为：<br>
<code>dst=cv2.distanceTransform(src,distanceType,maskSize[,dstType]])</code></p>
<p>式中：</p>
<ul>
<li>src是8位单通道的二值图像。</li>
<li><code>distanceType</code>为距离类型参数，其具体值和含义如表所示</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="118.png" style="zoom: 100%;" />
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> cv2 <span class="keyword">as</span> cv</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    img = cv.imread(<span class="string">&#x27;image\\0.jpg&#x27;</span>)</span><br><span class="line">    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)</span><br><span class="line">    ret, thresh = cv.threshold(gray, <span class="number">0</span>, <span class="number">255</span>, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)</span><br><span class="line">    kernel = np.ones((<span class="number">3</span>, <span class="number">3</span>), np.uint8)</span><br><span class="line">    opening = cv.morphologyEx(thresh, cv.MORPH_OPEN, kernel, iterations=<span class="number">2</span>)</span><br><span class="line">    sure_bg = cv.dilate(opening, kernel, iterations=<span class="number">3</span>)</span><br><span class="line">    dist_transform = cv.distanceTransform(opening, cv.DIST_L2, <span class="number">5</span>)</span><br><span class="line">    res = np.hstack((gray, dist_transform))</span><br><span class="line">    cv.imwrite(<span class="string">&#x27;res.png&#x27;</span>, res)</span><br><span class="line"></span><br><span class="line">    cv.waitKey(<span class="number">0</span>)</span><br><span class="line">    cv.destroyAllWindows()</span><br></pre></td></tr></table></figure>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="121.png" style="zoom: 80%;" />
<h3 id="函数connectedComponents">函数<code>connectedComponents()</code></h3>
<p>明确了确定前景后，就可以对确定前景图像进行标注了。在OpenCV中，可以使用函数<code>cv2.connectedComponents()</code>进行标注。该函数会将背景标注为0, 将其他的对象使用从1开始的正整数标注。</p>
<p>函数<code>cv2.connectedComponents()</code>的语法格式为：</p>
<p><code>retval,labels=cv2.connectedComponents (image)</code></p>
<p>式中：</p>
<ul>
<li>image为<strong>8位单通道</strong>的待标注图像。</li>
<li>retval为返回的标注的数量。</li>
<li>labels为标注的结果图像。</li>
</ul>
<h2 id="交互式前景提取">交互式前景提取</h2>
<h3 id="GrabCut算法的具体实施过程"><code>GrabCut</code>算法的具体实施过程</h3>
<ul>
<li>
<p>将前景所在的大致位置使用矩形框标注出来。值得注意的是，<strong>此时矩形框框出的仅仅是前景的大致位置，其中既包含前景又包含背景，所以该区域实际上是未确定区域。但是，该区域以外的区域被认为是 &quot;确定背景”</strong>。</p>
</li>
<li>
<p>根据矩形框外部的 &quot;确定背景“ 数据来区分<strong>矩形框区域内</strong>的前景和背景。</p>
</li>
<li>
<p>用高斯混合模型 (Gaussians Mixture Model,GMM) 对前景和背景建模。GMM会根据用户的输入学习并创建新的像素分布，对未分类的像素（可能是背景也可能是前景），根据其与已知分类像素（前景和背景）的关系进行分类。</p>
</li>
<li>
<p>根据像素分布情况生成一幅图，图中的节点就是各个像素点。除了像素点之外，还有两个节点：<strong>前景节点和背景节点</strong>。<strong>所有的前景像素都和前景节点相连，所有的背景像素都和背景节点相连</strong>。每个像素连接到前景节点或背景节点的边的权重由像素是前景或背景的概率来决定。</p>
</li>
<li>
<p>图中的每个像素除了与前景节点或背景节点相连外，彼此之间还存在着连接。<strong>两个像素连接的边的权重值由它们的相似性决定，两个像素的颜色越接近，边的权重值越大</strong>。</p>
</li>
<li>
<p><strong>完成节点连接后，需要解决的问题变成了一幅连通的图。在该图上根据各自边的权重关系进行切割，将不同的点划分为前景节点和背景节点</strong>。</p>
</li>
<li>
<p>不断重复上述过程， 直至分类收敛为止。</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="124.png" style="zoom: 80%;" />
<h3 id="函数-14">函数</h3>
<p>在OpenCV中， 实现交互式前景提取的函数是<code>cv2.grabCut ()</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mask,bgdModel,fgdModel=cv2.grabCut(img,mask,rect,bgdModel,fgdModel,iterCount[,mode ])</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>img为输入图像，要求是<strong>8位3通道</strong>的。</p>
</li>
<li>
<p>mask为掩模图像，要求是<strong>8位单通道</strong>的。该参数用于确定前景区域、背景区域和不确定区域可以设置为4种形式</p>
<ul>
<li>cv2.GC_BGD：表示确定背景， 也可以用数值0表示。</li>
<li>cv2.GC_FGD: 表示确定前景， 也可以用数值1表示。</li>
<li>cv2.GC_PR_BGD: 表示可能的背景， 也可以用数值2表示。</li>
<li>cv2.GC_PR_FGD: 表示可能的前景， 也可以用数值3表示。</li>
</ul>
</li>
</ul>
<p>​        <strong>在最后使用模板提取前景时，会将参数值0和2合并为背景（均当作0处理），将参数值1和3合并为前景（均当作1处理）</strong>。在通常情况下，我们可以使用白色笔刷和黑色笔刷在掩模图像上做标记，再通过转换将其中的白色像素设置为0，黑色像素设置为1。</p>
<ul>
<li>
<p>rect 指包含前景对象的区域，该区域外的部分被认为是“确定背景”。因此，在选取时务必确保让前景包含在rect指定的范围内；否则，rect外的前景部分是不会被提取出来的。只有当参数<code>mode</code>的值被设置为矩形模式<code>cv2.GC_INIT_ WITH_RECT</code>时 ，参数<code>rect</code>才有意义。其格式为<code>(x,y,w,h)</code>，分别表示区域左上角像素的x轴和y轴坐标以及区域的宽度和高度。如果前景位于右下方，又不想判断原始图像的大小，对于w 和h可以直接用一个很大的值。使用掩模模式时，将该值设置为<code>none</code>即可。</p>
</li>
<li>
<p>bgdModel为算法内部使用的数组，只需要创建大小为(1,65)的<code>numpy.float64</code>数组。</p>
</li>
<li>
<p>fgdModel为算法内部使用的数组， 只需要创建大小为(1,65)的<code>numpy.float64</code>数组。</p>
</li>
<li>
<p>iterCount表示迭代的次数。</p>
</li>
<li>
<p>mode表示迭代模式。</p>
</li>
</ul>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="123.png" style="zoom: 100%;" />
<h1>参考</h1>
<blockquote>
<p>《OpenCV轻松入门面向Python》</p>
<p><a target="_blank" rel="noopener" href="https://docs.opencv.org/4.1.2/d6/d00/tutorial_py_root.html">OpenCV官方文档</a></p>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/mp/appmsgalbum?action=getalbum&amp;album_id=1343718009222905856&amp;__biz=MzUyNzY5OTE5Mw==#wechat_redirect">python图像处理</a></p>
<p><a target="_blank" rel="noopener" href="http://daily.zhihu.com/story/3935067">傅里叶变换</a></p>
<p><a target="_blank" rel="noopener" href="http://daily.zhihu.com/story/3935067">频域与时域</a></p>
<p><a target="_blank" rel="noopener" href="https://dsp.stackexchange.com/questions/1637/what-does-frequency-domain-denote-in-case-of-images">什么是图片的频域</a></p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/203292567">霍夫线变换</a></p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ZWN2001.github.io">ZWN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwn2001.github.io/2022/02/26/opencv-basic/">https://zwn2001.github.io/2022/02/26/opencv-basic/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ZWN2001.github.io" target="_blank">ZWN's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Python/">Python</a><a class="post-meta__tags" href="/tags/opencv/">opencv</a></div><div class="post_share"><div class="social-share" data-image="/img/cover1/35.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/02/26/2022-sdu-online-core-member-interview/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/15-min.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2022_sdu_online_core_member_interview</div></div></a></div><div class="next-post pull-right"><a href="/2022/03/10/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%BC%80%E5%8F%91-WIFI-DIRECT/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/19-min.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">移动互联网开发-WIFI-DIRECT</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/15/%E6%89%8B%E6%8E%A7%E9%BC%A0%E6%A0%87/" title="手控鼠标"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/19-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-15</div><div class="title">手控鼠标</div></div></a></div><div><a href="/2022/07/06/Python%E5%B0%8F%E6%8A%84/" title="Python小抄"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/7-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-06</div><div class="title">Python小抄</div></div></a></div><div><a href="/2022/07/11/Python%E7%88%AC12306%E4%BD%99%E7%A5%A8/" title="Python爬12306余票"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/18.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-11</div><div class="title">Python爬12306余票</div></div></a></div><div><a href="/2022/07/05/Python%E7%88%AC%E8%99%AB%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%B0%8F%E9%BB%91%E5%B1%8B/" title="Python爬虫从入门到小黑屋"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/17-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-05</div><div class="title">Python爬虫从入门到小黑屋</div></div></a></div><div><a href="/2022/01/13/advanced-Python/" title="Python进阶语法记录-OOP、IO、网络"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/10-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-13</div><div class="title">Python进阶语法记录-OOP、IO、网络</div></div></a></div><div><a href="/2022/01/11/basic-Python/" title="Python基础语法记录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/8-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">Python基础语法记录</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZWN</div><div class="author-info__description">我虽无意逐鹿，却知苍生苦楚</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">96</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">12</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZWN2001"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZWN2001" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">建议使用无痕模式以更快地得到更新，或者访问新站https://zwn-2001-github-io.vercel.app/而非github page,github page将在九月停止运营</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">图像基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%8F%96%E5%9B%BE%E5%83%8F"><span class="toc-number">1.1.</span> <span class="toc-text">读取图像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%98%BE%E7%A4%BA%E5%9B%BE%E5%83%8F"><span class="toc-number">1.2.</span> <span class="toc-text">显示图像</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E5%AD%98%E5%9B%BE%E5%83%8F"><span class="toc-number">1.3.</span> <span class="toc-text">保存图像</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">图像处理基础</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%9B%BE%E5%83%8F"><span class="toc-number">2.1.</span> <span class="toc-text">基本图像</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%80%BC%E5%9B%BE"><span class="toc-number">2.1.1.</span> <span class="toc-text">二值图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%81%B0%E5%BA%A6%E5%9B%BE"><span class="toc-number">2.1.2.</span> <span class="toc-text">灰度图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%A9%E5%9B%BE%EF%BC%88%E4%BB%A5RGB%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%B8%BA%E4%BE%8B%EF%BC%89"><span class="toc-number">2.1.3.</span> <span class="toc-text">彩图（以RGB色彩空间为例）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%83%8F%E7%B4%A0%E5%A4%84%E7%90%86"><span class="toc-number">2.2.</span> <span class="toc-text">像素处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%93%8D%E4%BD%9C%EF%BC%88%E5%9F%BA%E4%BA%8ERGB%EF%BC%89"><span class="toc-number">2.3.</span> <span class="toc-text">通道操作（基于RGB）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E6%8B%86%E5%88%86"><span class="toc-number">2.3.1.</span> <span class="toc-text">通道拆分</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E7%B4%A2%E5%BC%95%E6%8B%86%E5%88%86-numpy"><span class="toc-number">2.3.1.1.</span> <span class="toc-text">通过索引拆分(numpy)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%9A%E8%BF%87%E5%87%BD%E6%95%B0%E6%8B%86%E5%88%86"><span class="toc-number">2.3.1.2.</span> <span class="toc-text">通过函数拆分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93%E5%90%88%E5%B9%B6"><span class="toc-number">2.3.2.</span> <span class="toc-text">通道合并</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E5%B1%9E%E6%80%A7"><span class="toc-number">2.4.</span> <span class="toc-text">图像属性</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">图像运算</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A0%E6%B3%95"><span class="toc-number">3.1.</span> <span class="toc-text">加法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E5%8F%B7%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">3.1.1.</span> <span class="toc-text">加号运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#add-%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.2.</span> <span class="toc-text">add()函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A0%E6%9D%83%E5%92%8C"><span class="toc-number">3.1.3.</span> <span class="toc-text">加权和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E9%80%BB%E8%BE%91"><span class="toc-number">3.2.</span> <span class="toc-text">按位逻辑</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E4%B8%8E"><span class="toc-number">3.2.1.</span> <span class="toc-text">按位与</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%89%E4%BD%8D%E6%88%96%E4%B8%8E%E6%8C%89%E4%BD%8D%E9%9D%9E%E3%80%81%E6%8C%89%E4%BD%8D%E5%BC%82%E6%88%96"><span class="toc-number">3.2.2.</span> <span class="toc-text">按位或与按位非、按位异或</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8E%A9%E6%A8%A1"><span class="toc-number">3.2.3.</span> <span class="toc-text">掩模</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E5%83%8F%E4%B8%8E%E6%95%B0%E5%80%BC%E7%9A%84%E8%BF%90%E7%AE%97"><span class="toc-number">3.3.</span> <span class="toc-text">图像与数值的运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E5%B9%B3%E9%9D%A2%E5%88%86%E8%A7%A3%E4%B8%8E%E5%85%B6%E5%BA%94%E7%94%A8"><span class="toc-number">3.4.</span> <span class="toc-text">位平面分解与其应用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A0%E8%A7%A3%E5%AF%86%E4%B8%8E%E6%95%B0%E5%AD%97%E6%B0%B4%E5%8D%B0"><span class="toc-number">3.4.1.</span> <span class="toc-text">应用：加解密与数字水印</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">色彩空间</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E4%B8%BE%E4%BE%8B"><span class="toc-number">4.1.</span> <span class="toc-text">色彩空间举例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4%E8%BD%AC%E6%8D%A2"><span class="toc-number">4.2.</span> <span class="toc-text">色彩空间转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#alpha%E9%80%9A%E9%81%93"><span class="toc-number">4.3.</span> <span class="toc-text">alpha通道</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">几何变换</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">阈值处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%88%E5%80%BC%E5%8C%96%E5%A4%84%E7%90%86"><span class="toc-number">6.1.</span> <span class="toc-text">阈值化处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E9%98%88%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-number">6.2.</span> <span class="toc-text">自适应阈值处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E9%98%88%E5%80%BC%E5%87%BD%E6%95%B0"><span class="toc-number">6.3.</span> <span class="toc-text">最优阈值函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">图像平滑处理（滤波）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9D%87%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">7.1.</span> <span class="toc-text">均值滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86"><span class="toc-number">7.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.2.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%B9%E6%A1%86%E6%BB%A4%E6%B3%A2"><span class="toc-number">7.2.</span> <span class="toc-text">方框滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-2"><span class="toc-number">7.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-2"><span class="toc-number">7.2.2.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E6%BB%A4%E6%B3%A2"><span class="toc-number">7.3.</span> <span class="toc-text">高斯滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-3"><span class="toc-number">7.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-3"><span class="toc-number">7.3.2.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%80%BC%E6%BB%A4%E6%B3%A2"><span class="toc-number">7.4.</span> <span class="toc-text">中值滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-4"><span class="toc-number">7.4.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-4"><span class="toc-number">7.4.2.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E8%BE%B9%E6%BB%A4%E6%B3%A2"><span class="toc-number">7.5.</span> <span class="toc-text">双边滤波</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-5"><span class="toc-number">7.5.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-5"><span class="toc-number">7.5.2.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2D%E5%8D%B7%E7%A7%AF"><span class="toc-number">7.6.</span> <span class="toc-text">2D卷积</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">形态学操作</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%85%90%E8%9A%80"><span class="toc-number">8.1.</span> <span class="toc-text">腐蚀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-6"><span class="toc-number">8.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-6"><span class="toc-number">8.1.2.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%86%A8%E8%83%80"><span class="toc-number">8.2.</span> <span class="toc-text">膨胀</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-7"><span class="toc-number">8.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-7"><span class="toc-number">8.2.2.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%BD%A2%E6%80%81%E5%AD%A6%E5%87%BD%E6%95%B0"><span class="toc-number">8.3.</span> <span class="toc-text">通用形态学函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-8"><span class="toc-number">8.3.1.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%B8%E5%87%BD%E6%95%B0"><span class="toc-number">8.4.</span> <span class="toc-text">核函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">图像梯度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Roberts-%E7%AE%97%E5%AD%90"><span class="toc-number">9.1.</span> <span class="toc-text">Roberts 算子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Prewitt-%E7%AE%97%E5%AD%90"><span class="toc-number">9.2.</span> <span class="toc-text">Prewitt 算子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Sobel-%E7%AE%97%E5%AD%90"><span class="toc-number">9.3.</span> <span class="toc-text">Sobel 算子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Laplacian-%E7%AE%97%E5%AD%90"><span class="toc-number">9.4.</span> <span class="toc-text">Laplacian 算子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E"><span class="toc-number">9.5.</span> <span class="toc-text">最后</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">canny边缘检测</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E6%9E%81%E5%A4%A7%E6%8A%91%E5%88%B6"><span class="toc-number">10.1.</span> <span class="toc-text">非极大抑制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8C%E9%98%88%E5%80%BC%E7%A1%AE%E5%AE%9A%E8%BE%B9%E7%BC%98"><span class="toc-number">10.2.</span> <span class="toc-text">双阈值确定边缘</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-9"><span class="toc-number">10.3.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">图像金字塔</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94"><span class="toc-number">11.1.</span> <span class="toc-text">高斯金字塔</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%89%E6%99%AE%E6%8B%89%E6%96%AF%E9%87%91%E5%AD%97%E5%A1%94"><span class="toc-number">11.2.</span> <span class="toc-text">拉普拉斯金字塔</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-10"><span class="toc-number">11.3.</span> <span class="toc-text">函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">图像轮廓</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E4%B8%8E%E7%BB%98%E5%88%B6"><span class="toc-number">12.1.</span> <span class="toc-text">查找与绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E8%BD%AE%E5%BB%93"><span class="toc-number">12.1.1.</span> <span class="toc-text">查找轮廓</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%98%E5%88%B6%E8%BD%AE%E5%BB%93"><span class="toc-number">12.1.2.</span> <span class="toc-text">绘制轮廓</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%EF%BC%9A%E6%8F%90%E5%8F%96%E5%89%8D%E6%99%AF"><span class="toc-number">12.1.3.</span> <span class="toc-text">使用：提取前景</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9F%A9%E7%89%B9%E5%BE%81"><span class="toc-number">12.2.</span> <span class="toc-text">矩特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9F%A9%E7%9A%84%E8%AE%A1%E7%AE%97%EF%BC%9Amoments"><span class="toc-number">12.2.1.</span> <span class="toc-text">矩的计算：moments()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Hu%E7%9F%A9"><span class="toc-number">12.2.2.</span> <span class="toc-text">Hu矩</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AE%E5%BB%93%E6%8B%9F%E5%90%88"><span class="toc-number">12.3.</span> <span class="toc-text">轮廓拟合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AD%A3%E7%9F%A9%E5%BD%A2%E5%92%8C%E6%9C%80%E5%B0%8F%E7%9F%A9%E5%BD%A2"><span class="toc-number">12.3.1.</span> <span class="toc-text">正矩形和最小矩形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%8C%85%E5%9B%B4%E5%9C%86"><span class="toc-number">12.3.2.</span> <span class="toc-text">最小包围圆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E6%8B%9F%E5%90%88%E6%A4%AD%E5%9C%86"><span class="toc-number">12.3.3.</span> <span class="toc-text">最优拟合椭圆</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E4%BC%98%E6%8B%9F%E5%90%88%E7%9B%B4%E7%BA%BF"><span class="toc-number">12.3.4.</span> <span class="toc-text">最优拟合直线</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E5%A4%96%E5%8C%85%E4%B8%89%E8%A7%92%E5%BD%A2"><span class="toc-number">12.3.5.</span> <span class="toc-text">最小外包三角形</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E5%BB%93%E8%BF%91%E4%BC%BC%EF%BC%88%E9%80%BC%E8%BF%91%E5%A4%9A%E8%BE%B9%E5%BD%A2%EF%BC%89"><span class="toc-number">12.3.6.</span> <span class="toc-text">轮廓近似（逼近多边形）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%B8%E5%8C%85"><span class="toc-number">12.3.7.</span> <span class="toc-text">凸包</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%B8%E7%BC%BA%E9%99%B7"><span class="toc-number">12.3.7.1.</span> <span class="toc-text">凸缺陷</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%A2%E7%8A%B6%E5%9C%BA%E6%99%AF%E7%AE%97%E6%B3%95%E6%AF%94%E8%BE%83%E8%BD%AE%E5%BB%93"><span class="toc-number">12.4.</span> <span class="toc-text">形状场景算法比较轮廓</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%BD%A2%E7%8A%B6%E5%9C%BA%E6%99%AF%E8%B7%9D%E7%A6%BB"><span class="toc-number">12.4.1.</span> <span class="toc-text">计算形状场景距离</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97Hausdorff%E8%B7%9D%E7%A6%BB"><span class="toc-number">12.4.2.</span> <span class="toc-text">计算Hausdorff距离</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">直方图处理</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E7%9A%84%E7%BB%98%E5%88%B6"><span class="toc-number">13.1.</span> <span class="toc-text">直方图的绘制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-Matplotlib-%E7%BB%98%E5%9B%BE"><span class="toc-number">13.1.1.</span> <span class="toc-text">使用 Matplotlib 绘图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8opencv%E7%BB%98%E5%88%B6"><span class="toc-number">13.1.2.</span> <span class="toc-text">使用opencv绘制</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96"><span class="toc-number">13.2.</span> <span class="toc-text">直方图均衡化</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-8"><span class="toc-number">13.2.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E9%80%82%E5%BA%94%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%9D%87%E8%A1%A1%E5%8C%96"><span class="toc-number">13.3.</span> <span class="toc-text">自适应直方图均衡化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E7%BB%B4%E7%9B%B4%E6%96%B9%E5%9B%BE"><span class="toc-number">13.4.</span> <span class="toc-text">二维直方图</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%9B%B4%E6%96%B9%E5%9B%BE%E5%8F%8D%E6%8A%95%E5%BD%B1"><span class="toc-number">13.5.</span> <span class="toc-text">直方图反投影</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E8%AE%BA"><span class="toc-number">13.5.1.</span> <span class="toc-text">理论</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Numpy%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-number">13.5.2.</span> <span class="toc-text">Numpy中的算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OpenCV%E7%9A%84%E5%8F%8D%E6%8A%95%E5%BD%B1"><span class="toc-number">13.5.3.</span> <span class="toc-text">OpenCV的反投影</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85%EF%BC%9Apyplot-subplot"><span class="toc-number">13.6.</span> <span class="toc-text">补充：pyplot.subplot()</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">傅里叶变换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-9"><span class="toc-number">14.1.</span> <span class="toc-text">原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PS-%E4%BB%80%E4%B9%88%E6%98%AF%E6%97%B6%E5%9F%9F%EF%BC%88%E7%A9%BA%E9%97%B4%E5%9F%9F%EF%BC%89%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E9%A2%91%E5%9F%9F"><span class="toc-number">14.1.1.</span> <span class="toc-text">PS.什么是时域（空间域），什么是频域</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Numpy%E4%B8%AD%E7%9A%84%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-number">14.2.</span> <span class="toc-text">Numpy中的傅里叶变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9A%E6%BB%A4%E6%B3%A2"><span class="toc-number">14.2.1.</span> <span class="toc-text">高通滤波</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OpenCV%E4%B8%AD%E7%9A%84%E5%82%85%E9%87%8C%E5%8F%B6%E5%8F%98%E6%8D%A2"><span class="toc-number">14.3.</span> <span class="toc-text">OpenCV中的傅里叶变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%8E%E9%80%9A%E6%BB%A4%E6%B3%A2"><span class="toc-number">14.3.1.</span> <span class="toc-text">低通滤波</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B8%A9%E5%9D%91"><span class="toc-number">14.3.2.</span> <span class="toc-text">踩坑</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DFT%E7%9A%84%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96"><span class="toc-number">14.4.</span> <span class="toc-text">DFT的性能优化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">模板匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-11"><span class="toc-number">15.1.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D"><span class="toc-number">15.2.</span> <span class="toc-text">单模板匹配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E6%A8%A1%E6%9D%BF%E5%8C%B9%E9%85%8D"><span class="toc-number">15.3.</span> <span class="toc-text">多模板匹配</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">特征匹配</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E9%87%8C%E6%96%AF%E8%A7%92%E6%A3%80%E6%B5%8B"><span class="toc-number">16.1.</span> <span class="toc-text">哈里斯角检测</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-10"><span class="toc-number">16.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-12"><span class="toc-number">16.1.2.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B"><span class="toc-number">16.1.3.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Shi-tomas%E6%8B%90%E8%A7%92%E6%A3%80%E6%B5%8B%E5%99%A8%E5%92%8C%E7%9B%8A%E4%BA%8E%E8%B7%9F%E8%B8%AA%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">16.2.</span> <span class="toc-text">Shi-tomas拐角检测器和益于跟踪的特征</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-11"><span class="toc-number">16.2.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-2"><span class="toc-number">16.2.2.</span> <span class="toc-text">样例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SIFT%E5%B0%BA%E5%BA%A6%E4%B8%8D%E5%8F%98%E7%89%B9%E5%BE%81%E5%8F%98%E6%8D%A2"><span class="toc-number">16.3.</span> <span class="toc-text">SIFT尺度不变特征变换</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">霍夫变换</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E7%BA%BF%E5%8F%98%E6%8D%A2"><span class="toc-number">17.1.</span> <span class="toc-text">霍夫线变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-12"><span class="toc-number">17.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A4%BA%E4%BE%8B"><span class="toc-number">17.1.2.</span> <span class="toc-text">函数与示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A6%82%E7%8E%87%E9%9C%8D%E5%A4%AB%E5%8F%98%E6%8D%A2"><span class="toc-number">17.1.3.</span> <span class="toc-text">概率霍夫变换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E4%B8%8E%E7%A4%BA%E4%BE%8B-2"><span class="toc-number">17.1.3.1.</span> <span class="toc-text">函数与示例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9C%8D%E5%A4%AB%E5%9C%86%E5%8F%98%E6%8D%A2"><span class="toc-number">17.2.</span> <span class="toc-text">霍夫圆变换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-13"><span class="toc-number">17.2.1.</span> <span class="toc-text">函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%B7%E4%BE%8B-3"><span class="toc-number">17.2.2.</span> <span class="toc-text">样例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">18.</span> <span class="toc-text">图像分割与提取</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%B0%B4%E5%B2%AD%E7%AE%97%E6%B3%95"><span class="toc-number">18.1.</span> <span class="toc-text">分水岭算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8E%9F%E7%90%86-13"><span class="toc-number">18.1.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8"><span class="toc-number">18.1.2.</span> <span class="toc-text">使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E5%8F%98%E6%8D%A2%E5%87%BD%E6%95%B0distanceTransform"><span class="toc-number">18.1.3.</span> <span class="toc-text">距离变换函数distanceTransform()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0connectedComponents"><span class="toc-number">18.1.4.</span> <span class="toc-text">函数connectedComponents()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E5%BC%8F%E5%89%8D%E6%99%AF%E6%8F%90%E5%8F%96"><span class="toc-number">18.2.</span> <span class="toc-text">交互式前景提取</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GrabCut%E7%AE%97%E6%B3%95%E7%9A%84%E5%85%B7%E4%BD%93%E5%AE%9E%E6%96%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">18.2.1.</span> <span class="toc-text">GrabCut算法的具体实施过程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0-14"><span class="toc-number">18.2.2.</span> <span class="toc-text">函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">19.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/27/%E6%9A%91%E6%9C%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BC%95%E8%AE%BA/" title="暑期机器学习引论"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/5-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="暑期机器学习引论"/></a><div class="content"><a class="title" href="/2022/07/27/%E6%9A%91%E6%9C%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BC%95%E8%AE%BA/" title="暑期机器学习引论">暑期机器学习引论</a><time datetime="2022-07-27T07:08:05.000Z" title="发表于 2022-07-27 15:08:05">2022-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/24/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E4%BD%BF%E7%94%A8%E4%B9%8B%E8%B7%AF/" title="支付宝沙箱使用之路"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/18-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="支付宝沙箱使用之路"/></a><div class="content"><a class="title" href="/2022/07/24/%E6%94%AF%E4%BB%98%E5%AE%9D%E6%B2%99%E7%AE%B1%E4%BD%BF%E7%94%A8%E4%B9%8B%E8%B7%AF/" title="支付宝沙箱使用之路">支付宝沙箱使用之路</a><time datetime="2022-07-24T14:36:34.000Z" title="发表于 2022-07-24 22:36:34">2022-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/17/myBatis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%93/" title="myBatis+springboot从入门到删库"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/5.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="myBatis+springboot从入门到删库"/></a><div class="content"><a class="title" href="/2022/07/17/myBatis%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%88%A0%E5%BA%93/" title="myBatis+springboot从入门到删库">myBatis+springboot从入门到删库</a><time datetime="2022-07-17T12:15:52.000Z" title="发表于 2022-07-17 20:15:52">2022-07-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/11/%E5%9F%9F%E6%A8%A1%E5%9E%8B%E3%80%81DDD%E3%80%81CQRS%E4%B8%8E12306%E7%9A%84%E8%AE%BE%E8%AE%A1/" title="域模型、DDD、CQRS与12306的设计"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/21-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="域模型、DDD、CQRS与12306的设计"/></a><div class="content"><a class="title" href="/2022/07/11/%E5%9F%9F%E6%A8%A1%E5%9E%8B%E3%80%81DDD%E3%80%81CQRS%E4%B8%8E12306%E7%9A%84%E8%AE%BE%E8%AE%A1/" title="域模型、DDD、CQRS与12306的设计">域模型、DDD、CQRS与12306的设计</a><time datetime="2022-07-11T11:39:51.000Z" title="发表于 2022-07-11 19:39:51">2022-07-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/11/Python%E7%88%AC12306%E4%BD%99%E7%A5%A8/" title="Python爬12306余票"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/18.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python爬12306余票"/></a><div class="content"><a class="title" href="/2022/07/11/Python%E7%88%AC12306%E4%BD%99%E7%A5%A8/" title="Python爬12306余票">Python爬12306余票</a><time datetime="2022-07-11T03:24:04.000Z" title="发表于 2022-07-11 11:24:04">2022-07-11</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/cover1/35.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By ZWN</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">喵喵喵？</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '7MlJqmD9Ceux2bxiKqPqsMHW-gzGzoHsz',
      appKey: '3oP9XaednBAwtfMk2q28dwGP',
      avatar: 'retro',
      serverURLs: 'https://7mljqmd9.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="app-refresh" id="app-refresh"> <div class="app-refresh-wrap"> <label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" onclick="location.reload()">点击刷新</a> </div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"点击刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>