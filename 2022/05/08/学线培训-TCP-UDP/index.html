<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>学线培训：TCP-UDP | ZWN's blog</title><meta name="keywords" content="计网"><meta name="author" content="洛雪"><meta name="copyright" content="洛雪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="TCP&amp;UDP初步 基本概念 TCP：传输控制协议（Transmission Control Protocol） UDP：用户数据报协议（User Datagram Protocol） TCP跟UDP的一些基本区别：   TCP面向连接，UDP不面向连接。 TCP面向字节，不存在消息边界，所以可能存在粘包问题。UDP则面向报文。  为什么会粘包   TCP会尽力保证数据的可靠交付，而UDP">
<meta property="og:type" content="article">
<meta property="og:title" content="学线培训：TCP-UDP">
<meta property="og:url" content="https://zwn2001.github.io/2022/05/08/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD-TCP-UDP/index.html">
<meta property="og:site_name" content="ZWN&#39;s blog">
<meta property="og:description" content="TCP&amp;UDP初步 基本概念 TCP：传输控制协议（Transmission Control Protocol） UDP：用户数据报协议（User Datagram Protocol） TCP跟UDP的一些基本区别：   TCP面向连接，UDP不面向连接。 TCP面向字节，不存在消息边界，所以可能存在粘包问题。UDP则面向报文。  为什么会粘包   TCP会尽力保证数据的可靠交付，而UDP">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zwn2001.github.io/img/cover3/32.jpg">
<meta property="article:published_time" content="2022-05-08T06:10:46.000Z">
<meta property="article:modified_time" content="2022-07-01T12:46:26.425Z">
<meta property="article:author" content="洛雪">
<meta property="article:tag" content="计网">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zwn2001.github.io/img/cover3/32.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zwn2001.github.io/2022/05/08/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD-TCP-UDP/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: 洛雪","link":"链接: ","source":"来源: ZWN's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '学线培训：TCP-UDP',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-07-01 20:46:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover3/32.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZWN's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">学线培训：TCP-UDP</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-08T06:10:46.000Z" title="发表于 2022-05-08 14:10:46">2022-05-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-07-01T12:46:26.425Z" title="更新于 2022-07-01 20:46:26">2022-07-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD/">学线培训</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>21分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1><code>TCP</code>&amp;<code>UDP</code>初步</h1>
<h2 id="基本概念">基本概念</h2>
<p><code>TCP</code>：传输控制协议（<code>Transmission Control Protocol</code>）</p>
<p><code>UDP</code>：用户数据报协议（<code>User Datagram Protocol</code>）</p>
<p><strong><code>TCP</code>跟<code>UDP</code>的一些基本区别：</strong></p>
<blockquote>
<ol>
<li><code>TCP</code>面向连接，<code>UDP</code>不面向连接。</li>
<li><code>TCP</code>面向字节，不存在消息边界，所以可能存在粘包问题。<code>UDP</code>则面向报文。
<ul>
<li><a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-%60TCP%60-message-frame/">为什么会粘包</a></li>
</ul>
</li>
<li><code>TCP</code>会尽力保证数据的可靠交付，而<code>UDP</code>默认不做保证。</li>
<li><code>TCP</code>头部20字节，<code>UDP</code>头部8字节。</li>
</ol>
</blockquote>
<p><strong>编者注</strong>：如何理解1和3：</p>
<p><code>TCP</code>协议是一种可靠的通信协议，<strong>它要求传输的过程是可靠的，因此需要经过三次握手的环节，确立连接关系之后，才可以进行传输</strong>。除此之外，<code>TCP</code>还有超时重传机制，还有排序的机制，有发送的窗口，有窗口大小等等，保证接收方接收到的就是发送方发送过去的。</p>
<p><code>UDP</code>是一种不可靠的通信协议，它<strong>不需要建立连接</strong>，不需要对连接进行确认<code>ACK</code>的操作，不需要重传，不需要排序，它<strong>只管传输</strong>。</p>
<p>比如：</p>
<blockquote>
<p>“我给你讲一个关于<code>TCP</code>的笑话。”</p>
<p>“好的你给我讲一个关于<code>TCP</code>的笑话。”</p>
<p>“好的。”</p>
<p><strong>------确立连接关系，进行传输------</strong></p>
<p>“苟。这是第一个字。”</p>
<p>“第一个字收到，请发第二个字。”</p>
<p>“利。这是第二个字。”</p>
<p>“第二个字收到，请发第三个字。”</p>
<p>“国。这是第三个字。”</p>
<p><strong>------超时重传-------</strong></p>
<p>“国。这是第三个字。”</p>
<p>“第三个字收到，请发第四个字。”</p>
<p>“家……”</p>
<p>……</p>
<p>“我讲完了。”</p>
<p>“好的。我听完了。”</p>
<p>“好的。”</p>
<p><strong>------关闭连接------</strong></p>
<p>“我给你讲一个关于<code>UDP</code>的笑话。”</p>
<p>“咦我好像听见一个关笑P话的U……？咦这苟啊国家啊这什么什么之是啥玩意？我让应用层看看……应用层说应该是两句诗？”</p>
</blockquote>
<p><code>TCP</code> 最适合用于对时序不太关心的，且要求高可靠性的应用程序。</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%B8%87%E7%BB%B4%E7%BD%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1883510114%7D">万维网</a>（<code>HTTP/HTTPS</code>）</li>
<li>安全外壳（<code>SSH</code>）</li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1883510114%7D">电子邮件</a>（<code>SMTP，IMAP / POP</code>）</li>
<li>文件传输协议（<code>FTP</code>）</li>
</ul>
<p><code>UDP</code> 最适合需要速度和效率的应用程序。</p>
<ul>
<li>串流影片</li>
<li>线上游戏</li>
<li>现场直播</li>
<li>域名系统（<code>DNS</code>）</li>
<li><a target="_blank" rel="noopener" href="https://www.zhihu.com/search?q=%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1883510114%7D">互联网协议</a>语音（<code>VoIP</code>）</li>
<li>普通文件传输协议（<code>TFTP</code>）</li>
</ul>
<h3 id="一个问题：什么是协议">一个问题：什么是协议</h3>
<p>协议实际上就是一种约定。好比说，我们做一个石头剪刀布的游戏，我们约定好：石头&gt;剪刀、剪刀&gt;布、布&gt;石头，以此作为游戏规则。我们所有人都遵循这个约定，那么就不需要任何的多余的沟通便可以完成这个游戏。而这种方式形成的约定实际上就是一种协议了。</p>
<h2 id="模型">模型</h2>
<h3 id="TCP-IP模型"><code>TCP/IP</code>模型</h3>
<p><code>TCP/IP</code>其实也可以指代一个遵循<code>TCP/IP</code>的协议族，我们后面会说到，我们先来看这个模型。</p>
<p><code>TCP/IP</code>的四层模型：</p>
<ol>
<li>应用层，在这一层上的有<code>HTTP、DNS、FTP、SSH</code>等。</li>
<li>传输层，在这一层上的有<code>TCP</code>、<code>UDP</code>等。</li>
<li>网络层，在这一层上的有<code>IP</code>、<code>ARP</code>等。</li>
<li>网络接口层，在这一层上的有以太网、<code>PPP</code>等。</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="3.jpg" alt=""></p>
<p><strong>编者注</strong>:<code>TCP/IP</code>模型是由 <code>OSI</code> 模型演化而来，<code>TCP/IP</code> 模型将 <code>OSI</code> 模型由七层简化为五层（一开始为四层），应用层、表示层、会话层统一为应用层。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="8.jpg" alt=""></p>
<p>如果从客户端到来一个请求：</p>
<ol>
<li>服务器端接收到客户端的SYN报文，返回SYN+ACK报文，服务器端进入<strong>SYN_RCVD</strong>状态。</li>
<li>服务器端收到客户端返回的ACK应答后，连接建立，进入<strong>ESTABLISHED</strong>状态。</li>
<li>服务器端的数据传输完毕，给客户端发送FIN报文，进入<strong>FIN_WAIT_1</strong>状态。</li>
<li>服务器端接收到客户端返回的ACK应答后，进入<strong>FIN_WAIT_2</strong>状态。</li>
<li>服务器端接收到客户端的FIN报文，接着返回一个ACK应答，等待连接关闭，进入<strong>TIME_WAIT</strong>状态。</li>
<li>服务器端经过<strong>2MSL</strong>时间后进入<strong>CLOSED</strong>状态，此时连接关闭。</li>
</ol>
<p>至于客户端，在每个阶段也有各自的状态，下图表示了<code>TCP</code>状态迁移的过程：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2.jpg" alt="别太较真，图一乐"></p>
<hr>
<p><code>TCP/IP</code> 协议族里重要的一点就是分层。把 <code>TCP/IP</code> 层次化是有好处的。比如，如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。把各层之间的接口部分规划好之后，每个层次内部的设计就能够自由改动了。</p>
<p>值得一提的是，层次化之后，设计也变得相对简单了。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎样的、是否能确保传输送达等问题。</p>
<h4 id="数据链路层">数据链路层</h4>
<p>数据链路层是负责接收 <code>IP</code> 数据包并通过网络发送，或者从网络上接收物理帧，抽出 <code>IP</code> 数据包，交给网络层（<code>IP</code>层）。</p>
<p>常见的接口层协议有：</p>
<p>Ethernet 802.3、Token Ring 802.5、X.25、Frame relay、HDLC、PPP ATM等。</p>
<h4 id="网络层">网络层</h4>
<p>负责相邻计算机之间的通信。其功能包括三方面。</p>
<ul>
<li>
<p>处理来自传输层的分组发送请求，收到请求后，将分组装入 <code>IP</code> 数据报，填充报头，选择去往信宿机的路径，然后将数据报发往适当的网络接口。</p>
</li>
<li>
<p>处理输入数据报：首先检查其合法性，然后进行寻径–假如该数据报已到达信宿机，则去掉报头，将剩下部分交给适当的传输协议；假如该数据报尚未到达信宿，则转发该数据报。</p>
</li>
<li>
<p>处理路径、流控、拥塞等问题。</p>
</li>
</ul>
<p>网络层包括：<code>IP</code>(<code>Internet Protocol</code>) 协议、<code>ICMP</code>(<code>Internet Control Message Protocol</code>)控制报文协议、<code>ARP</code>(<code>Address Resolution Protocol</code>) 地址转换协议、<code>RARP</code>(<code>Reverse ARP</code>) 反向地址转换协议。</p>
<p><code>ARP</code> 是正向地址解析协议，通过已知的 <code>IP</code>，寻找对应主机的 <code>MAC</code> 地址。</p>
<p><code>RARP</code> 是反向地址解析协议，通过 <code>MAC</code> 地址确定 <code>IP</code> 地址。比如无盘工作站还有 <code>DHCP</code> 服务。</p>
<p><code>IP</code> 是网络层的核心，通过路由选择将下一条IP封装后交给接口层。<code>IP</code>数据报是无连接服务。</p>
<p><code>ICMP</code> 是网络层的补充，可以回送报文。用来检测网络是否通畅。</p>
<p><code>Ping</code> 命令就是发送 <code>ICMP</code> 的 <code>echo</code> 包，通过回送的 <code>echo relay</code> 进行网络测试。</p>
<h4 id="传输层">传输层</h4>
<p>提供应用程序间的通信。其功能包括：一、格式化信息流；二、提供可靠传输。</p>
<p>传输层协议主要是：传输控制协议 <code>TCP</code>(<code>Transmission Control Protocol</code>) 和用户数据报协议 <code>UDP</code>(<code>User Datagram protocol</code>)。</p>
<h4 id="应用层">应用层</h4>
<p>向用户提供一组常用的应用程序，比如电子邮件、文件传输访问、远程登录等。远程登录 TELNET 使用 TELNET 协议提供在网络其它主机上注册的接口。TELNET 会话提供了基于字符的虚拟终端。文件传输访问 FTP 使用 FTP 协议来提供网络内机器间的文件拷贝功能。</p>
<p>应用层协议主要包括如下几个：<code>FTP、TELNET、DNS、SMTP、NFS、HTTP</code>。</p>
<p><code>FTP</code>(<code>File Transfer Protocol</code>）是文件传输协议，一般上传下载用<code>FTP</code>服务，数据端口是 20H，控制端口是 21H。</p>
<p><code>Telnet</code> 服务是用户远程登录服务，使用 23H 端口，使用明码传送，保密性差、简单方便。</p>
<p><code>DNS</code>(<code>Domain Name Service</code>）是域名解析服务，提供域名到 IP 地址之间的转换，使用端口 53。</p>
<p><code>SMTP</code>(<code>Simple Mail Transfer Protocol</code>）是简单邮件传输协议，用来控制信件的发送、中转，使用端口 25。</p>
<p><code>NFS</code>()<code>Network File System</code>）是网络文件系统，用于网络中不同主机间的文件共享。</p>
<p><code>HTTP</code>(<code>Hypertext Transfer Protocol</code>）是超文本传输协议，用于实现互联网中的 WWW 服务，使用端口 80。</p>
<h3 id="TCP模型"><code>TCP</code>模型</h3>
<h4 id="TCP协议作用"><code>TCP</code>协议作用</h4>
<p><code>TCP</code>协议位于协议栈的传输层。当应用层向<code>TCP</code>层发送用于网间传输的、用8位字节表示的<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E6%B5%81">数据流</a>，<code>TCP</code>则把数据流分割成适当长度的报文段，最大传输段大小（<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/MSS/3567770">MSS</a>）通常受该计算机连接的网络的数据链路层的最大传送单元（<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/MTU">MTU</a>）限制。之后<code>TCP</code>把数据包传给IP层，由它来通过网络将包传送给接收端实体的<code>TCP</code>层。</p>
<p><code>TCP</code>为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
<ul>
<li>在数据正确性与合法性上，<code>TCP</code>用一个校验和函数来检验数据是否有错误，在发送和接收时都要计算校验和；同时可以使用md5认证对数据进行加密。</li>
<li>在保证可靠性上，采用超时重传和捎带确认机制。</li>
<li>在流量控制上，采用滑动窗口协议，协议中规定，对于窗口内未经确认的分组需要重传。</li>
</ul>
<p>在拥塞控制上，采用广受好评的<code>TCP</code>拥塞控制算法（也称AIMD算法）。 该算法主要包括三个主要部分：</p>
<ul>
<li>
<p>加性增、乘性减；</p>
</li>
<li>
<p>慢启动；</p>
</li>
<li>
<p>对超时事件做出反应。</p>
</li>
</ul>
<h4 id="TCP连接的建立"><code>TCP</code>连接的建立</h4>
<blockquote>
<p>一些常见的标志位：</p>
<p><code>URG</code>：指示报文中有紧急数据，应尽快传送（相当于高优先级的数据）。</p>
<p><code>ACK</code>：确认序号（AN）有效。</p>
<p><code>PSH</code>：接到后尽快交付给接收的应用进程。</p>
<p><code>RST</code>：<code>TCP</code>连接中出现严重差错（如主机崩溃），必须释放连接，在重新建立连接。</p>
<p><code>SYN</code>：处于<code>TCP</code>连接建立过程。</p>
<p><code>FIN</code>：发送端已完成数据传输，请求释放连接。</p>
<p>后面有更详细的解释</p>
</blockquote>
<p><code>TCP</code>是一个面向连接的协议，在每一次传输数据前，客户端和服务端需要进行连接，这个链接就是著名的三次握手。</p>
<blockquote>
<p>第一次：客户端向服务端发送一个 <code>SYN</code>（<code>SEQ=J</code> 客户端序号）报文给服务器端，进入<code>SYN_SEND</code>状态。</p>
<p>第二次：服务器端收到SYN报文，回应一个<code>SYN</code> （<code>SEQ=K</code> 服务端序号）<code>ACK</code>(<code>ACK=J+1</code> 确认号=客户端序号+1）报文，进入<a target="_blank" rel="noopener" href="https://baike.baidu.com/item/SYN_RECV">SYN_RECV</a>状态。</p>
<p>第三次：客户端收到服务器端的<code>SYN</code>报文，回应一个<code>ACK</code>(<code>ACK=K+1</code>）报文，进入<code>Established</code>状态。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="1.webp" alt=""></p>
<p>三次握手就很安全了吗？在三次握手过程中，<code>Server</code>发送<code>SYN-ACK</code>之后，收到<code>Client</code>的<code>ACK</code>之前的<code>TCP</code>连接称为半连接（<code>half-open connect</code>），此时<code>Server</code>处于<code>SYN_RCVD</code>状态，当收到<code>ACK</code>后，<code>Server</code>转入<code>ESTABLISHED</code>状态。<code>SYN</code>攻击就是<code>Client</code>在短时间内伪造大量不存在的<code>IP</code>地址，并向<code>Server</code>不断地发送<code>SYN</code>包，<code>Server</code>回复确认包，并等待<code>Client</code>的确认，由于源地址是不存在的，因此，<code>Server</code>需要不断重发直至超时，这些伪造的<code>SYN</code>包将产时间占用未连接队列，导致正常的<code>SYN</code>请求因为队列满而被丢弃，从而引起网络堵塞甚至系统瘫痪。<code>SYN</code>攻击是一种典型的<code>DDOS</code>攻击，检测<code>SYN</code>攻击的方式非常简单，即当<code>Server</code>上有大量半连接状态且源<code>IP</code>地址是随机的，则可以断定遭到<code>SYN</code>攻击了。</p>
<h4 id="能不能通过两次握手建立连接">能不能通过两次握手建立连接</h4>
<p>其实是可以的，但那同时存在一个问题，我们无法在发送方和接收方两边都建立安全、稳定的连接。</p>
<h5 id="什么是连接">什么是连接</h5>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol</a> 文档中非常清楚地定义了 <code>TCP</code> 中的连接是什么，我们简单总结一下：用于保证可靠性和流控制机制的信息，包括 Socket、序列号以及窗口大小叫做连接。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="4.png" alt="what-is-TCP-connection"></p>
<p>所以，建立 <code>TCP</code> 连接就是通信的双方需要对上述的三种信息达成共识，连接中的一对 <code>Socket</code> 是由互联网地址标志符和端口组成的，窗口大小主要用来做流控制，最后的序列号是用来追踪通信发起方发送的数据包序号，接收方可以通过序列号向发送方确认某个数据包的成功接收。</p>
<p>到这里，我们将原有的问题转换成了『为什么需要通过三次握手才可以初始化 <code>Sockets</code>、窗口大小和初始序列号？』，那么接下来我们就开始对这个细化的问题进行分析并寻找解释。</p>
<h5 id="阻止重复历史连接的初始化">阻止重复历史连接的初始化</h5>
<p><a target="_blank" rel="noopener" href="https://tools.ietf.org/html/rfc793">RFC 793 - Transmission Control Protocol</a> 其实就指出了 <code>TCP</code> 连接使用三次握手的首要原因 —— 为了阻止历史的重复连接初始化造成的混乱问题，防止使用 <code>TCP</code> 协议通信的双方建立了错误的连接。</p>
<blockquote>
<p>The principle reason for the three-way handshake is to prevent old duplicate connection initiations from causing confusion.</p>
</blockquote>
<p>想象一下这个场景，如果通信双方的通信次数只有两次，那么发送方一旦发出建立连接的请求之后它就没有办法撤回这一次请求，如果在网络状况复杂或者较差的网络中，发送方连续发送多次建立连接的请求，如果 <code>TCP</code> 建立连接只能通信两次，那么接收方只能选择接受或者拒绝发送方发起的请求，它并不清楚这一次请求是不是由于网络拥堵而早早过期的连接。</p>
<p>所以，<code>TCP</code> 选择使用三次握手来建立连接并在连接引入了 <code>RST</code> 这一控制消息，接收方当收到请求时会将发送方发来的 <code>SEQ+1</code> 发送给对方，这时由发送方来判断当前连接是否是历史连接：</p>
<ul>
<li>如果当前连接是历史连接，即 <code>SEQ</code> 过期或者超时，那么发送方就会直接发送 <code>RST</code> 控制消息中止这一次连接；</li>
<li>如果当前连接不是历史连接，那么发送方就会发送 <code>ACK</code> 控制消息，通信双方就会成功建立连接；</li>
</ul>
<p><strong>使用三次握手和 <code>RST</code> 控制消息将是否建立连接的最终控制权交给了发送方，因为只有发送方有足够的上下文来判断当前连接是否是错误的或者过期的，这也是 <code>TCP</code> 使用三次握手建立连接的最主要原因</strong>。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="5.png" alt="tcp-recovery-from-old-duplicate-syn"></p>
<blockquote>
<p><code>ACK</code>：确认序号（AN）有效。</p>
<p><code>RST</code>：<code>TCP</code>连接中出现严重差错（如主机崩溃），必须释放连接，在重新建立连接。</p>
<p><code>SYN</code>：处于<code>TCP</code>连接建立过程。</p>
</blockquote>
<p>在上图的过程中，发送方<code>SEQ=90</code>的历史连接请求被接收到并被服务器做出应答，但此时发送方的<code>SEQ</code>已经增长为100，发送方就可以知道这是历史连接，通过<code>RST</code>告知接受方废弃该连接，从而避免这个连接被建立在一个已经超时废弃的连接之上。</p>
<h5 id="初始序列号">初始序列号</h5>
<p>另一个使用三次握手的重要的原因就是通信双方都需要获得一个用于发送信息的初始化序列号，作为一个可靠的传输层协议，<code>TCP</code> 需要在不稳定的网络环境中构建一个可靠的传输层，网络的不确定性可能会导致数据包的缺失和顺序颠倒等问题，常见的问题可能包括：</p>
<ul>
<li>数据包被发送方多次发送造成数据的重复；</li>
<li>数据包在传输的过程中被路由或者其他节点丢失；</li>
<li>数据包到达接收方可能无法按照发送顺序；</li>
</ul>
<p>为了解决上述这些可能存在的问题，<code>TCP</code> 协议要求发送方在数据包中加入『序列号』字段，有了数据包对应的序列号，我们就可以：</p>
<ul>
<li>接收方可以通过序列号对重复的数据包进行去重；</li>
<li>发送方会在对应数据包未被 <code>ACK</code> 时进行重复发送；</li>
<li>接收方可以根据数据包的序列号对它们进行重新排序；</li>
</ul>
<p>序列号在 <code>TCP</code> 连接中有着非常重要的作用，初始序列号作为 <code>TCP</code> 连接的一部分也需要在三次握手期间进行初始化，由于 <code>TCP</code> 连接通信的双方都需要获得初始序列号，所以它们其实需要向对方发送 <code>SYN</code> 控制消息并携带自己期望的初始化序列号 <code>SEQ</code>，对方在收到 <code>SYN</code> 消息之后会通过 <code>ACK</code> 控制消息以及 <code>SEQ+1</code> 来进行确认。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="6.png" alt="basic-4-way-handshake"></p>
<p>如上图所示，通信双方的两个 <code>TCP A/B</code> 分别向对方发送 <code>SYN</code> 和 <code>ACK</code> 控制消息，等待通信双方都获取到了自己期望的初始化序列号之后就可以开始通信了，由于 <code>TCP</code> 消息头的设计，我们可以将中间的两次通信合成一个，<code>TCP B</code> 可以向 <code>TCP A</code> 同时发送 <code>ACK</code> 和 <code>SYN</code> 控制消息，这也就帮助我们将四次通信减少至三次。</p>
<blockquote>
<p>A three way handshake is necessary because sequence numbers are not tied to a global clock in the network, and TCPs may have different mechanisms for picking the ISN’s. The receiver of the first SYN has no way of knowing whether the segment was an old delayed one or not, unless it remembers the last sequence number used on the connection (which is not always possible), and so it must ask the sender to verify this SYN. The three way handshake and the advantages of a clock-driven scheme are discussed in [3].</p>
</blockquote>
<p>除此之外，网络作为一个分布式的系统，其中并不存在一个用于计数的全局时钟，而 <code>TCP</code> 可以通过不同的机制来初始化序列号，作为 <code>TCP</code> 连接的接收方我们无法判断对方传来的初始化序列号是否过期，所以我们需要交由对方来判断，<code>TCP</code> 连接的发起方可以通过保存发出的序列号判断连接是否过期，如果让接收方来保存并判断序列号却是不现实的，这也再一次强化了我们在上一节中提出的观点 —— 避免历史错连接的初始化。</p>
<h4 id="连接的断开">连接的断开</h4>
<p>一个<code>TCP</code>完整的断开需要进行四次挥手。</p>
<blockquote>
<p>第一次：客户端向服务端发送 <code>FIN + ACK</code> 报文，同时携带序号为 X。 客户端进入 <code>FIN-WAIT1</code></p>
<p>第二次：服务器端回复 <code>ACK</code> 报文。附带序号Z和确认序号X+1，表示服务器已经接受到了客服端的报文。但是由于服务器可能还在处理事务，因此，报文并不会携带FIN标志。状态：<code>CLOSE WAIT</code></p>
<p>第三次：在一段时间之后，服务器已经处理完毕，发送带有 <code>FIN</code>和<code>ACK</code>的报文，序号为Y，确认序号为 X + 1 。状态： <code>ACK-LAST</code></p>
<p>第四次：客户端发送<code>ACK</code>报文，序号为 X+1，确认号Y+1 。 客户端进入： <code>TIME_WAIT</code>。服务端进入<code>CLOSE</code>（初始状态）</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="10.webp" alt=""></p>
<p>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</p>
<p>这是因为服务端在<code>LISTEN</code>状态下，收到建立连接请求的<code>SYN</code>报文后，把<code>ACK</code>和<code>SYN</code>放在一个报文里发送给客户端。而关闭连接时，<strong>当收到对方的<code>FIN</code>报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方也未必全部数据都发送给对方了，所以己方可以立即<code>close</code>，也可以发送一些数据给对方后，再发送<code>FIN</code>报文给对方来表示同意现在关闭连接，因此，己方<code>ACK</code>和<code>FIN</code>一般都会分开发送</strong>。</p>
<p>打个不太恰当的比方，你点击关机按钮，相当于你向电脑发送<code>FIN</code>，但其实你电脑还有一些程序在运行，不过电脑会立即响应，进入关机阶段，相当于想你发送了<code>ACK</code>，然后他还会告诉你哪些程序需要被关闭，可以理解为又向你发送了一部分必要的数据，等待这些程序也被系统关闭后，电脑完成关机流程，黑屏，相当于向你发送了<code>FIN</code>，你发现电脑完成了关机、不再有任何响应，于是合上电脑起身离开，相当于发送了<code>ACK</code>（最后这个<code>ACK</code>有点牵强）</p>
<h3 id="UDP模型"><code>UDP</code>模型</h3>
<p><code>UDP</code>（<code>User Datagram Protocol</code>）是一个简单的面向消息的传输层协议，尽管<code>UDP</code>提供标头和有效负载的完整性验证（通过校验和），但它不保证向上层协议提供消息传递，并且<code>UDP</code>层在发送后不会保留<code>UDP</code> 消息的状态。因此，<code>UDP</code>有时被称为不可靠的数据报协议。如果需要传输可靠性，则必须在用户应用程序中实现。</p>
<p><code>UDP</code>使用具有最小协议机制的简单无连接通信模型。<code>UDP</code>提供数据完整性的校验和，以及用于在数据报的源和目标寻址不同函数的端口号。它没有握手对话，因此将用户的程序暴露在底层网络的任何不可靠的方面。如果在网络接口级别需要纠错功能，应用程序可以使用为此目的设计的传输控制协议（<code>TCP</code>）。</p>
<p>综上所述：<code>UDP</code>是基于IP的简单协议，不可靠的协议。</p>
<p><code>UDP</code>的优点：简单，轻量化。</p>
<p><code>UDP</code>的缺点：没有流控制，没有应答确认机制，不能解决丢包、重发、错序问题。</p>
<p>这里需要注意一点，并不是所有使用<code>UDP</code>协议的应用层都是不可靠的，应用程序可以自己实现可靠的数据传输，通过增加确认和重传机制，所以使用<code>UDP</code> 协议最大的特点就是速度快。</p>
<h4 id="PING包"><code>PING</code>包</h4>
<p>我们经常使用<code>ping</code>命令来测试两台主机之间<code>TCP/IP</code>通信是否正常， 其实<code>ping</code>命令的原理就是向对方主机发送<code>UDP</code>数据包，然后对方主机确认收到数据包， 如果数据包是否到达的消息及时反馈回来，那么网络就是通的。</p>
<p><code>ping</code>命令是用来探测主机到主机之间是否可通信，如果不能<code>ping</code>到某台主机，表明不能和这台主机建立连接。<code>ping</code>命令是使用 <code>IP</code> 和网络控制信息协议 (<code>ICMP</code>)，因而没有涉及到任何传输协议(<code>UDP</code>/<code>TCP</code>) 和应用程序。它发送<code>ICMP</code>回送请求消息给目的主机。</p>
<p><code>ICMP</code>协议规定：目的主机必须返回<code>ICMP</code>回送应答消息给源主机。如果源主机在一定时间内收到应答，则认为主机可达。</p>
<h4 id="UDP洪水"><code>UDP</code>洪水</h4>
<p><code>UDP</code> 洪水是一种拒绝服务攻击，攻击者将大量用户数据报协议(<code>UDP</code>) 数据包发送到目标服务器，旨在让该设备的处理和响应能力无力承担。由于<code>UDP</code> 洪水攻击，保护目标服务器的防火墙也可能不堪重负，导致对正常流量拒绝服务。</p>
<p><code>UDP</code> 洪水攻击的工作原理</p>
<p><code>UDP</code> 洪水的工作原理主要是利用服务器响应发送到其端口之一的<code>UDP</code> 数据包时所采取的步骤。在正常情况下，服务器在特定端口上收到<code>UDP</code> 数据包时，将通过以下两个步骤进行响应：</p>
<p>服务器首先检查是否有任何当前侦听指定端口请求的程序正在运行。</p>
<p>如果该端口上没有程序正在接收数据包，则服务器将以<code> ICMP (ping)</code> 数据包作为响应，以告知发送方目标不可达。</p>
<p><code>UDP</code>洪水就好比酒店接待员转接呼叫的情况。首先，接待员接到电话，呼叫者要求将其连接到特定客房。然后，接待员需要查看所有房间的列表，以确保客人在客房内，并愿意接听电话。如果接待员了解到客人没有接听电话，他们就必须重新接听电话，并告诉呼叫者客人不会接听电话。如果所有电话线路都突然同时发出类似请求，他们很快就会变得不堪重负。</p>
<p>由于目标服务器利用资源来检查并响应每个接收到的<code>UDP</code> 数据包，当收到大量<code>UDP</code> 数据包时，目标资源会很快耗尽，从而导致对正常流量拒绝服务。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="9.jpg" alt=""></p>
<p><strong>如何防护<code>UDP</code> 洪水攻击？</strong></p>
<p>大多数操作系统限制<code>ICMP</code> 数据包的响应速率，部分原因是为了中断需要<code>ICMP</code> 响应的<code>DDoS</code> 攻击。这种防护措施的一个缺点是，在攻击期间，合法数据包也可能在此过程中被过滤。如果<code>UDP</code>洪水的大小足以使目标服务器的防火墙的状态表饱和，则在服务器级别发生的任何防护都将是不够的，因为瓶颈将发生在目标设备的上游。</p>
<h2 id="详细的标志位">详细的标志位</h2>
<p><code>URG</code>：此标志表示<code>TCP</code>包的紧急指针域有效，用来保证<code>TCP</code>连接不被中断，并且督促中间层设备要尽快处理这些数据；</p>
<p><code>ACK</code>：此标志表示应答域有效，就是说前面所说的<code>TCP</code>应答号将会包含在<code>TCP</code>数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0；</p>
<p><code>PSH</code>：这个标志位表示<code>Push</code>操作。所谓<code>Push</code>操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队；</p>
<p><code>RST</code>：这个标志表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包；</p>
<p><code>SYN</code>：表示同步序号，用来建立连接。<code>SYN</code>标志位和<code>ACK</code>标志位搭配使用，当连接请求的时候，<code>SYN=1，ACK=0；</code>连接被相应的时候，<code>SYN=1，ACK= 1；</code>这个标志的数据包经常被用来进行端口扫描。扫描者发送一个只有<code>SYN</code>的数据包，如果对方主机响应了一个数据包回来，就表明这台主机存在这个端口；但是 由于这种扫描方式只是进行<code>TCP</code>三次握手的第一次握手，因此这种扫描的成功表示被扫描的机器不很安全，一台安全的主机将会强制要求一个连接严格的进行 <code>TCP</code>的三次握手；</p>
<p><code>FIN</code>：表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送<code>FIN</code>标志位的<code>TCP</code>数据包后，连接将被断开。这个标志的数 据包也经常被用于进行端口扫描。当一个FIN标志的<code>TCP</code>数据包发送到一台计算机的特定端口，如果这台计算机响应了这个数据，并且反馈回来一个<code>RST</code>标志 的<code>TCP</code>包，就表明这台计算机上没有打开这个端口，但是这台计算机是存在的；如果这台计算机没有反馈回来任何数据包，这就表明，这台被扫描的计算机存在这 个端口。</p>
<h1>参考</h1>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/freekiteyu/article/details/72236734">https://blog.csdn.net/freekiteyu/article/details/72236734</a></p>
<p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dac7b8bdb682">https://www.jianshu.com/p/dac7b8bdb682</a></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/whys-the-design-TCP-three-way-handshake/">https://draveness.me/whys-the-design-TCP-three-way-handshake/</a></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ZWN2001.github.io">洛雪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwn2001.github.io/2022/05/08/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD-TCP-UDP/">https://zwn2001.github.io/2022/05/08/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD-TCP-UDP/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ZWN2001.github.io" target="_blank">ZWN's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%AE%A1%E7%BD%91/">计网</a></div><div class="post_share"><div class="social-share" data-image="/img/cover3/32.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/07/flutter%E5%B1%8F%E5%B9%95%E6%97%8B%E8%BD%AC%E4%B8%8E%E7%8A%B6%E6%80%81%E6%A0%8F%E3%80%81%E5%AF%BC%E8%88%AA%E6%8C%89%E9%92%AE%E5%A4%84%E7%90%86/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/4-min.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">flutter屏幕旋转与状态栏、导航按钮处理</div></div></a></div><div class="next-post pull-right"><a href="/2022/05/11/%E4%BD%BF%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E7%A6%81%E7%94%A8%E9%94%AE%E7%9B%98/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/11-min.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">使用快捷键禁用键盘</div></div></a></div></nav><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">洛雪</div><div class="author-info__description">我虽无意逐鹿，却知苍生苦楚</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">107</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZWN2001"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZWN2001" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">新域名：https://www.zwn-blog.xyz/,建议使用无痕模式以更快地得到更新，或者访问https://zwn-2001-github-io.vercel.app/,或者https://zwn2001.github.io</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">TCP&amp;UDP初步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%9A%E4%BB%80%E4%B9%88%E6%98%AF%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.1.1.</span> <span class="toc-text">一个问题：什么是协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.</span> <span class="toc-text">模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP-IP%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">TCP&#x2F;IP模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">数据链路层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">网络层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82"><span class="toc-number">1.2.1.3.</span> <span class="toc-text">传输层</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E5%B1%82"><span class="toc-number">1.2.1.4.</span> <span class="toc-text">应用层</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TCP%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">TCP模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E5%8D%8F%E8%AE%AE%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">TCP协议作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#TCP%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%BB%BA%E7%AB%8B"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">TCP连接的建立</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%BD%E4%B8%8D%E8%83%BD%E9%80%9A%E8%BF%87%E4%B8%A4%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">能不能通过两次握手建立连接</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9E%E6%8E%A5"><span class="toc-number">1.2.2.3.1.</span> <span class="toc-text">什么是连接</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%98%BB%E6%AD%A2%E9%87%8D%E5%A4%8D%E5%8E%86%E5%8F%B2%E8%BF%9E%E6%8E%A5%E7%9A%84%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">1.2.2.3.2.</span> <span class="toc-text">阻止重复历史连接的初始化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%9D%E5%A7%8B%E5%BA%8F%E5%88%97%E5%8F%B7"><span class="toc-number">1.2.2.3.3.</span> <span class="toc-text">初始序列号</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9E%E6%8E%A5%E7%9A%84%E6%96%AD%E5%BC%80"><span class="toc-number">1.2.2.4.</span> <span class="toc-text">连接的断开</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UDP%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.3.</span> <span class="toc-text">UDP模型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#PING%E5%8C%85"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">PING包</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UDP%E6%B4%AA%E6%B0%B4"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">UDP洪水</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%A6%E7%BB%86%E7%9A%84%E6%A0%87%E5%BF%97%E4%BD%8D"><span class="toc-number">1.3.</span> <span class="toc-text">详细的标志位</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/09/30/android-environment/" title="android-environment"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/35.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="android-environment"/></a><div class="content"><a class="title" href="/2022/09/30/android-environment/" title="android-environment">android-environment</a><time datetime="2022-09-30T14:31:07.000Z" title="发表于 2022-09-30 22:31:07">2022-09-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/23/CSharp%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/" title="CSharp从入门到入门"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/13-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CSharp从入门到入门"/></a><div class="content"><a class="title" href="/2022/09/23/CSharp%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E5%85%A5%E9%97%A8/" title="CSharp从入门到入门">CSharp从入门到入门</a><time datetime="2022-09-23T15:47:18.000Z" title="发表于 2022-09-23 23:47:18">2022-09-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/19/FLutter%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="FLutter性能优化"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="FLutter性能优化"/></a><div class="content"><a class="title" href="/2022/09/19/FLutter%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/" title="FLutter性能优化">FLutter性能优化</a><time datetime="2022-09-19T01:13:39.000Z" title="发表于 2022-09-19 09:13:39">2022-09-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/15/%E5%AE%89%E5%8D%93Jetpack%E4%BB%8E%E4%B8%A4%E7%9C%BC%E4%B8%80%E6%8A%B9%E9%BB%91%E5%88%B0%E4%B8%A4%E7%9C%BC%E4%B8%80%E9%BB%91/" title="安卓Jetpack从两眼一抹黑到两眼一黑"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/24-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安卓Jetpack从两眼一抹黑到两眼一黑"/></a><div class="content"><a class="title" href="/2022/09/15/%E5%AE%89%E5%8D%93Jetpack%E4%BB%8E%E4%B8%A4%E7%9C%BC%E4%B8%80%E6%8A%B9%E9%BB%91%E5%88%B0%E4%B8%A4%E7%9C%BC%E4%B8%80%E9%BB%91/" title="安卓Jetpack从两眼一抹黑到两眼一黑">安卓Jetpack从两眼一抹黑到两眼一黑</a><time datetime="2022-09-15T11:45:02.000Z" title="发表于 2022-09-15 19:45:02">2022-09-15</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/09/15/Linux-mindMap-for-sduer-first-term/" title="Linux-mindMap-for-sduer-first-term"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/15.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Linux-mindMap-for-sduer-first-term"/></a><div class="content"><a class="title" href="/2022/09/15/Linux-mindMap-for-sduer-first-term/" title="Linux-mindMap-for-sduer-first-term">Linux-mindMap-for-sduer-first-term</a><time datetime="2022-09-15T08:33:36.000Z" title="发表于 2022-09-15 16:33:36">2022-09-15</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/cover3/32.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 洛雪</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">喵喵喵？</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '7MlJqmD9Ceux2bxiKqPqsMHW-gzGzoHsz',
      appKey: '3oP9XaednBAwtfMk2q28dwGP',
      avatar: 'retro',
      serverURLs: 'https://7mljqmd9.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="app-refresh" id="app-refresh"> <div class="app-refresh-wrap"> <label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" onclick="location.reload()">点击刷新</a> </div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"点击刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>