<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>移动互联网期末名词解释 | ZWN's blog</title><meta name="keywords" content="学习"><meta name="author" content="洛雪"><meta name="copyright" content="洛雪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="移动互联网名词 复习题目和范围 Android等移动开发开发环境，各部、功能、用法、流程等，术语SDK、NDK、clang、avd、adb、studio等。 Android中的技术，GUI元素和界面设计、声音录放、静图&#x2F;动图、网路通信、性能C、权限、GPS和地图、二维码等。 传感器技术和创意应用设计，再举例：街头棋局app。https:&#x2F;&#x2F;blog.csdn.net&#x2F;lanrenxiaowen&#x2F;a">
<meta property="og:type" content="article">
<meta property="og:title" content="移动互联网期末名词解释">
<meta property="og:url" content="https://zwn2001.github.io/2022/05/30/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E8%AF%8D/index.html">
<meta property="og:site_name" content="ZWN&#39;s blog">
<meta property="og:description" content="移动互联网名词 复习题目和范围 Android等移动开发开发环境，各部、功能、用法、流程等，术语SDK、NDK、clang、avd、adb、studio等。 Android中的技术，GUI元素和界面设计、声音录放、静图&#x2F;动图、网路通信、性能C、权限、GPS和地图、二维码等。 传感器技术和创意应用设计，再举例：街头棋局app。https:&#x2F;&#x2F;blog.csdn.net&#x2F;lanrenxiaowen&#x2F;a">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zwn2001.github.io/img/cover3/15-min.jpg">
<meta property="article:published_time" content="2022-05-30T12:17:55.000Z">
<meta property="article:modified_time" content="2022-06-18T15:02:30.068Z">
<meta property="article:author" content="洛雪">
<meta property="article:tag" content="学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zwn2001.github.io/img/cover3/15-min.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zwn2001.github.io/2022/05/30/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E8%AF%8D/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: 洛雪","link":"链接: ","source":"来源: ZWN's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '移动互联网期末名词解释',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-06-18 23:02:30'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover3/15-min.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZWN's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">移动互联网期末名词解释</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-05-30T12:17:55.000Z" title="发表于 2022-05-30 20:17:55">2022-05-30</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-06-18T15:02:30.068Z" title="更新于 2022-06-18 23:02:30">2022-06-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">26k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>84分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>移动互联网名词</h1>
<h2 id="复习题目和范围">复习题目和范围</h2>
<p>Android等移动开发开发环境，各部、功能、用法、流程等，术语SDK、NDK、clang、avd、adb、studio等。<br>
Android中的技术，GUI元素和界面设计、声音录放、静图/动图、网路通信、性能C、权限、GPS和地图、二维码等。</p>
<p>传感器技术和创意应用设计，再举例：街头棋局app。<a target="_blank" rel="noopener" href="https://blog.csdn.net/lanrenxiaowen/article/details/108051656">https://blog.csdn.net/lanrenxiaowen/article/details/108051656</a></p>
<p>通信技术，ip、port、socket、tcp/udp/sctp、multicast/mdns、proxy、http/s、socks、mq、p2p、nat、socat、ssh/-L-R-D、JSch</p>
<p>与桌面开发不同的移动开发技术。</p>
<p>移动开发和云的结合：计算能力和续航能力的平衡、分布式计算或数据存储、云备份、安全加密等。<br>
与时俱进的移动开发技术，各方面：接入、通信、存储、界面、显示、Web/HTML、云、各种识别等。</p>
<p>从HTML/5到WebView的开发技术和过程。</p>
<p>H5/Canvas和Android/Canvas</p>
<p>Android上app代码运行优化的机制和过程等：JVM、DVM、JIT、AOT、ART等</p>
<p>从APK结构解析，到Android安全技术和对抗逆向。</p>
<h2 id="术语和线索词汇">术语和线索词汇</h2>
<h3 id="Activity">Activity</h3>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/activities/intro-activities?hl=zh-cn">推荐阅读</a></p>
<blockquote>
<p><code>Activity</code> 类是 Android 应用的关键组件，而 Activity 的启动和组合方式则是该平台应用模型的基本组成部分。在编程范式中，应用是通过 <code>main()</code> 方法启动的，而 Android 系统与此不同，它会调用与其生命周期特定阶段相对应的特定回调方法来启动 <code>Activity</code> 实例中的代码。</p>
<p>本文介绍了 Activity 的概念，并提供了有关如何使用 Activity 的简要说明。要详细了解有关设计应用架构的最佳做法，请参阅<a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/architecture/guide?hl=zh-cn">应用架构指南</a>。</p>
<h4 id="Activity-的概念">Activity 的概念</h4>
<p>移动应用体验与桌面体验的不同之处在于，用户与应用的互动并不总是在同一位置开始，而是经常以不确定的方式开始。例如，如果您从主屏幕打开电子邮件应用，可能会看到电子邮件列表，如果您通过社交媒体应用启动电子邮件应用，则可能会直接进入电子邮件应用的邮件撰写界面。</p>
<p><code>Activity</code> 类的目的就是促进这种范式的实现。当一个应用调用另一个应用时，调用方应用会调用另一个应用中的 Activity，而不是整个应用。通过这种方式，Activity 充当了应用与用户互动的入口点。您可以将 Activity 实现为 <code>Activity</code> 类的子类。</p>
<p>Activity 提供窗口供应用在其中绘制界面。此窗口通常会填满屏幕，但也可能比屏幕小，并浮动在其他窗口上面。通常，一个 Activity 实现应用中的一个屏幕。例如，应用中的一个 Activity 实现“偏好设置”屏幕，而另一个 Activity 实现“选择照片”屏幕。</p>
<p>大多数应用包含多个屏幕，这意味着它们包含多个 Activity。通常，应用中的一个 Activity 会被指定为主 Activity，这是用户启动应用时出现的第一个屏幕。然后，每个 Activity 可以启动另一个 Activity，以执行不同的操作。例如，一个简单的电子邮件应用中的主 Activity 可能会提供显示电子邮件收件箱的屏幕。主 Activity 可能会从该屏幕启动其他 Activity，以提供执行写邮件和打开邮件这类任务的屏幕。</p>
<p>虽然应用中的各个 Activity 协同工作形成统一的用户体验，但每个 Activity 与其他 Activity 之间只存在松散的关联，应用内不同 Activity 之间的依赖关系通常很小。事实上，Activity 经常会启动属于其他应用的 Activity。例如，浏览器应用可能会启动社交媒体应用的“分享”Activity。</p>
</blockquote>
<h3 id="adb">adb</h3>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/studio/command-line/adb?hl=zh-cn">推荐阅读</a></p>
<blockquote>
<p>Android 调试桥 (adb) 是一种功能多样的命令行工具，可让您与设备进行通信。adb 命令可用于执行各种设备操作（例如安装和调试应用），并提供对 Unix shell（可用来在设备上运行各种命令）的访问权限。它是一种客户端-服务器程序，包括以下三个组件：</p>
<ul>
<li><strong>客户端</strong>：用于发送命令。客户端在开发机器上运行。您可以通过发出 adb 命令从命令行终端调用客户端。</li>
<li><strong>守护程序 (adbd)</strong>：用于在设备上运行命令。守护程序在每个设备上作为后台进程运行。</li>
<li><strong>服务器</strong>：用于管理客户端与守护程序之间的通信。服务器在开发机器上作为后台进程运行。</li>
</ul>
<h4 id="adb-的工作原理">adb 的工作原理</h4>
<p>当您启动某个 adb 客户端时，该客户端会先检查是否有 adb 服务器进程正在运行。如果没有，它会启动服务器进程。服务器在启动后会与本地 TCP 端口 5037 绑定，并监听 adb 客户端发出的命令 - 所有 adb 客户端均通过端口 5037 与 adb 服务器通信。</p>
<p>然后，服务器会与所有正在运行的设备建立连接。它通过扫描 5555 到 5585 之间（该范围供前 16 个模拟器使用）的奇数号端口查找模拟器。服务器一旦发现 adb 守护程序 (adbd)，便会与相应的端口建立连接。请注意，每个模拟器都使用一对按顺序排列的端口 - 用于控制台连接的偶数号端口和用于 adb 连接的奇数号端口。例如：</p>
<p>模拟器 1，控制台：5554<br>
模拟器 1，adb：5555<br>
模拟器 2，控制台：5556<br>
模拟器 2，adb：5557<br>
依此类推</p>
<p>如上所示，在端口 5555 处与 adb 连接的模拟器与控制台监听端口为 5554 的模拟器是同一个。</p>
<p>服务器与所有设备均建立连接后，您便可以使用 adb 命令访问这些设备。由于服务器管理与设备的连接，并处理来自多个 adb 客户端的命令，因此您可以从任意客户端（或从某个脚本）控制任意设备。</p>
</blockquote>
<h3 id="android-onClick">android:onClick</h3>
<p>点击事件监听，对应于安卓事务。</p>
<p>这里使用四种onClick单击事件，来实现电话拔号器的DEMO。</p>
<p>XML文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:inputType</span>=<span class="string">&quot;phone&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:ems</span>=<span class="string">&quot;10&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/et_number&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignParentTop</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignParentLeft</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignParentStart</span>=<span class="string">&quot;true&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:text</span>=<span class="string">&quot;@string/dial_number&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/bt_dial&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_below</span>=<span class="string">&quot;@id/et_number&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignRight</span>=<span class="string">&quot;@id/et_number&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_alignEnd</span>=<span class="string">&quot;@id/et_number&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>第一种、匿名内部类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    Button bt_dial = (Button) findViewById(R.id.bt_dial);</span><br><span class="line">    bt_dial.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            dialPhone();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种、自定义单击事件监听类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        et_number = (EditText) MainActivity.<span class="keyword">this</span>.findViewById(R.id.et_number);</span><br><span class="line">                    </span><br><span class="line">        Button bt_dial = (Button) findViewById(R.id.bt_dial);</span><br><span class="line">        bt_dial.setOnClickListener(<span class="keyword">new</span> MyListener());</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">MyListener</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        dialPhone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第三种、Activity继承View.OnClickListener，由Activity实现OnClick(View view)方法，在OnClick(View view)方法中用switch-case对不同id代表的button进行相应的处理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">View</span>.<span class="title">OnClickListener</span> </span>&#123;</span><br><span class="line">    EditText et_number;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        et_number = (EditText) MainActivity.<span class="keyword">this</span>.findViewById(R.id.et_number);</span><br><span class="line">        </span><br><span class="line">    Button bt_dial = (Button) findViewById(R.id.bt_dial);</span><br><span class="line">        bt_dial.setOnClickListener(<span class="keyword">this</span>);</span><br><span class="line"> </span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">switch</span> (view.getId())&#123;</span><br><span class="line">            <span class="keyword">case</span> R.id.bt_dial:</span><br><span class="line">                dialPhone();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第四种、在XML文件中显示指定按钮的onClick属性，这样点击按钮时会利用反射的方式调用对应Activity中的click()方法：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Button</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:onClick</span>=<span class="string">&quot;dialPhoneMethod&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:text</span>=<span class="string">&quot;@string/dial_number&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">&quot;@+id/bt_dial&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_below</span>=<span class="string">&quot;@id/et_number&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignRight</span>=<span class="string">&quot;@id/et_number&quot;</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_alignEnd</span>=<span class="string">&quot;@id/et_number&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<pre><code>public void dialPhoneMethod(View view)&#123;
    dialPhone();
&#125;
 
private void dialPhone() &#123;
    String number = et_number.getText().toString().trim();
 
    if (TextUtils.isEmpty(number))&#123;
        Toast.makeText(this, &quot;电话号码不能为空&quot;, Toast.LENGTH_LONG).show();
        return;
    &#125;
    Intent intent = new Intent();
    intent.setAction(Intent.ACTION_CALL);
    intent.setData(Uri.parse(&quot;tel:&quot; + number));
    startActivity(intent);
&#125;
</code></pre>
<p>总结：<br>
第四种写法整个代码中都不用声明button就可以实现button的单击事件。但通常不推荐这样使用，第三种方法是onClick最佳的的使用方式。按钮少的时候用匿名内部类会比较快，比如写demo测试的时候。</p>
<p>————————————————<br>
原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/a78270528/article/details/46953541">https://blog.csdn.net/a78270528/article/details/46953541</a></p>
<h3 id="AnimationDrawable">AnimationDrawable</h3>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/graphics/drawable-animation?hl=zh-cn">推荐阅读</a></p>
<blockquote>
<p>在某些情况下，图片需要在屏幕上呈现动画效果。如果您希望显示由多张图片组成的自定义加载动画，或者希望一个图标在用户执行操作后变为另一个图标，这种做法就非常实用。Android 提供了两个选项供您为可绘制对象添加动画效果。</p>
<p>第一个选项是使用 <a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/graphics/drawable-animation?hl=zh-cn#AnimationDrawable">AnimationDrawable</a>。使用该选项，您可以指定多个静态<a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/graphics/2d-graphics?hl=zh-cn">可绘制对象文件</a>（每次展示一个）来创建动画。第二个选项是使用 <a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/graphics/drawable-animation?hl=zh-cn#AnimVector">AnimatedVectorDrawable</a>。使用该选项，您可以为<a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/graphics/vector-drawable-resources?hl=zh-cn">矢量可绘制对象</a>的属性添加动画效果。</p>
<h4 id="使用-AnimationDrawable">使用 AnimationDrawable</h4>
<p>要为 <code>Drawables</code> 添加动画效果，一种方法是接连加载一系列可绘制资源以创建动画。从某种意义上来说，这是一种传统动画，使用一系列不同的图片创建而成，然后像一卷胶卷一样按顺序播放。<code>AnimationDrawable</code> 类是可绘制动画的基础。</p>
<p>虽然您可以使用 <code>AnimationDrawable</code> 类 API 在代码中定义动画帧，但使用单个 XML 文件（其中列出构成动画的各个帧）可更轻松地完成此操作。此类动画的 XML 文件位于 Android 项目的 <code>res/drawable/</code> 目录中。在这种情况下，具体指令是每个动画帧的顺序和时长。</p>
<p>XML 文件包含一个 <code>&lt;animation-list&gt;</code> 元素（用作根节点）和一系列子 <code>&lt;item&gt;</code> 节点（每个节点定义一个帧）：帧和帧时长的可绘制资源。以下是可绘制动画的 XML 文件示例：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animation-list</span> <span class="attr">xmlns:android</span>=<span class="string">&quot;http://schemas.android.com/apk/res/android&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:oneshot</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/rocket_thrust1&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/rocket_thrust2&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">item</span> <span class="attr">android:drawable</span>=<span class="string">&quot;@drawable/rocket_thrust3&quot;</span> <span class="attr">android:duration</span>=<span class="string">&quot;200&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>此动画仅运行 3 帧。通过将列表的 <code>android:oneshot</code> 属性设置为 true，此动画仅循环一次，然后便停止并保持在最后一帧。如果设置为 false，则动画会一直循环。将此 XML 文件另存为 <code>rocket_thrust.xml</code>（位于项目的 <code>res/drawable/</code> 目录中）后，可将其作为背景图片添加到视图，然后进行调用以播放。在以下示例 Activity 中，该动画添加到了 <code>ImageView</code> 中，然后在用户轻触屏幕时呈现动画效果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">AnimationDrawable rocketAnimation;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">  setContentView(R.layout.main);</span><br><span class="line"></span><br><span class="line">  ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image);</span><br><span class="line">  rocketImage.setBackgroundResource(R.drawable.rocket_thrust);</span><br><span class="line">  rocketAnimation = (AnimationDrawable) rocketImage.getBackground();</span><br><span class="line"></span><br><span class="line">  rocketImage.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">        rocketAnimation.start();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请务必注意，对 <code>AnimationDrawable</code> 调用的 <code>start()</code> 方法不能在 Activity 的 <code>onCreate()</code> 方法期间调用，因为 <code>AnimationDrawable</code> 尚未完全附加到窗口。如果您想立即播放动画而无需互动，那么您可能需要从 Activity 中的 `onStart()``` 方法进行调用，该方法会在 Android 在屏幕上呈现视图时调用。</p>
</blockquote>
<h3 id="aosp">aosp</h3>
<p><a target="_blank" rel="noopener" href="https://www.eet-china.com/mp/a56086.html">官网</a>、<a target="_blank" rel="noopener" href="https://www.eet-china.com/mp/a56086.html">推荐阅读</a></p>
<blockquote>
<p>Android 是一个适用于移动设备的开源操作系统，也是由 Google 主导的对应开源项目。此网站和 Android 开源项目 (AOSP) 代码库可为您提供所需信息和源代码，供您创建定制的 Android 操作系统版本，将设备和配件移植到 Android 平台，同时确保您的设备符合兼容性要求，从而让 Android 生态系统维持良好稳健的运行环境，以便更好地服务于数百万用户。</p>
<hr>
<p>AOSP 是由谷歌主导的一个开源项目，通过 AOSP 可以编译出一个比较纯净的，可以用于智能设备的操作系统。</p>
<p>Android 系统是开源的 AOSP 和额外的闭源部分（其中包括 GMS ）的组合而成，所以可以认为 Android=AOSP+GMS 。</p>
<p>网友有一个通俗的比喻：<strong>AOSP 是个毛坯房，Android 是个精装房</strong>。</p>
<p>由于 AOSP 是开源的，一些第三方机构就可以以 AOSP 为基础，做出自己的改进，并对不同机型适配，然后自己取一个名字。</p>
<p>比如小米的 MIUI、华为的 EMUI、或者魅族的 Flyme。</p>
</blockquote>
<h3 id="HarmonyOS">HarmonyOS</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/378568208">阅读参考</a></p>
<blockquote>
<p>鸿蒙是一个面向全场景的分布式操作系统，蒙是基于微内核的全场景分布式操作系统，目前华为已经将鸿蒙捐献给了<strong>开放原子开源基金会</strong>。</p>
<p>有人说鸿蒙是基于 2012 年华为的 LiteOS 开发而来，LiteOS 是轻量级物联网操作系统，目前也以及完全开源。</p>
<p>从客观上来讲，鸿蒙肯定借鉴了 LiteOS 开发中所积累的经验，所以<strong>华为鸿蒙OS 算是 LiteOS 的一个发展产物</strong>，但它们是两款完全不同的操作系统。</p>
<p>这里还需要和大家明确，区分一个概念，说实话如果不是为了给大家写这篇文章，查了很多资料，不然我也混淆的。</p>
<p><strong>Openharmony 和 HarmonyOS（鸿蒙操作系统） 是两个完全不同的概念！</strong></p>
<p>HarmonyOS 是华为研发的面向万物互联时代的全新的、独立的智能终端操作系统，为不同设备的智能化、互联与协同提供统一的语言。</p>
<p>华为把 HarmonyOS 中基础功能提取出来，打包成功一个项目叫做：Openharmony ，把 Openharmony 捐献给原子开源基金会。</p>
<p>华为这次发布的 HarmonyOS 2 是华为基于开源项目 OpenHarmony 2.0 开发的面向多种全场景智能设备的商用版本。</p>
<p>OpenHarmony 是华为主要贡献的，不属于华为，属于开源组织；而 HarmonyOS 是华为的商业系统，属于华为拥有。</p>
<h4 id="国产厂商为什么不跟进？"><strong>国产厂商为什么不跟进？</strong></h4>
<p>大家如果明白上面这两个概念的区别之后，就应该很容易明白，为什么国内厂商没有跟进鸿蒙？</p>
<p>上面说的有点绕，做一个简单的比喻大家应该就明白了：</p>
<p><strong>HarmonyOS 2 = Openharmony 2 + 华为的 EMUI + 兼容安卓部分</strong></p>
<p>根据这个公式，我们可以回答好几个问题：</p>
<p>1、Openharmony 是不兼容安卓的，也没有什么 AOSP 的事情，是一个纯正、独立的开源操作系统。</p>
<p>2、<strong>HarmonyOS 2</strong> 是不开源的，是华为基于 <strong>Openharmony 2</strong> 开发的一个商业版本。</p>
<p>为了兼容安卓应用，必定使用了一些 AOSP 的内容，同时华为是不可能将 EMUI 开放给同行的，所以同行厂商没办法直接使用 <strong>HarmonyOS 2</strong> 。</p>
<p>3、如果让国内同行都兼容鸿蒙的话，他们需要做的工作是：基于 <strong>Openharmony 2</strong> 开发自己的 UI。</p>
<p>比如 MIUI + 兼容以前应用，工作量巨大，可能不是一时半会就可以搞定，同时他们还需要考虑谷歌在国外对他们制裁的风险。</p>
<p>可以套用上面的比如：<strong>Openharmony 2 是个毛坯房，而 HarmonyOS 2</strong> <strong>是个精装房。</strong></p>
</blockquote>
<h3 id="apk">apk</h3>
<p><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-hans/APK">参考阅读</a></p>
<blockquote>
<p>APK是Android Package的缩写，即Android安装包(apk)。APK是类似Symbian Sis或Sisx的文件格式。通过将APK文件直接传到Android模拟器或Android手机中执行即可安装。apk文件和sis一样，把android sdk编译的工程打包成一个安装程序文件，格式为apk。 APK文件其实是zip格式，但后缀名被修改为apk，通过UnZip解压后，可以看到Dex文件，Dex是Dalvik VM executes的全称，即Android Dalvik执行程序，并非Java ME的字节码而是Dalvik字节码。Android在运行一个程序时首先需要UnZip，然后类似Symbian那样直接，和Windows Mobile中的PE文件有区别。</p>
<hr>
<p><strong>Android应用程序包</strong>（英语：Android application package，<strong>APK</strong>），是<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Android">Android</a><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F">操作系统</a>使用的一种<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F">应用程序</a>包文件格式，用于分发和安装<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E7%A7%BB%E5%8A%A8%E5%BA%94%E7%94%A8">移动应用</a>及<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E4%B8%AD%E9%97%B4%E4%BB%B6">中间件</a>。一个Android应用程序的代码想要在Android设备上运行，必须先进行<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E7%BC%96%E8%AF%91">编译</a>，然后被打包成为一个被Android系统所能识别的文件才可以被运行，而这种能被Android系统识别并运行的<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F">文件格式</a>便是“APK”。 一个APK文件内包含被编译的代码文件(.dex 文件)，文件资源（resources）， assets，证书（certificates），和清单文件（manifest file）</p>
</blockquote>
<h3 id="ARM">ARM</h3>
<p><a target="_blank" rel="noopener" href="https://www.agora.io/cn/community/blog-123-category-23728">参考阅读</a></p>
<blockquote>
<p>ARM架构，称为进阶精简指令集机器（Advanced RISC Machine，更早称作：Acorn RISC Machine），是一个32位精简指令集（RISC）处理器架构，其广泛地使用在许多嵌入式系统设计。由于节能的特点，ARM处理器非常适用于行动通讯领域，符合其主要设计目标为低耗电的特性。</p>
<p>在今日，ARM家族占了所有32位嵌入式处理器75%的比例，使它成为占全世界最多数的32位架构之一。ARM处理器可以在很多消费性电子产品上看到，从可携式装置（PDA、移动电话、多媒体播放器、掌上型电子游戏，和计算机）到电脑外设（硬盘、桌上型路由器）甚至在导弹的弹载计算机等军用设施中都有他的存在。在此还有一些基于ARM设计的派生产品，重要产品还包括Marvell的XScale架构和德州仪器的OMAP系列。</p>
<p>优势：价格低；能耗低；</p>
<h4 id="X86架构">X86架构</h4>
<p>是一个复杂指令集CISC（Complex Instruction Set Computer）处理器架构。X86结构的电脑无论如何都比ARM结构的系统在性能方面要快得多、强得多。X86的CPU随便就是1G以上、双核、四核。X86结构的电脑采用“桥”的方式与扩展设备（如：硬盘、内存等）进行连接，而且X86结构的电脑出现了近30年，其配套扩展的设备种类多、价格也比较便宜，所以X86结构的电脑能很容易进行性能扩展，如增加内存、硬盘等。</p>
<h4 id="ARM-和x86的区别">ARM 和x86的区别</h4>
<p>ARM 架构注重的是续航能力， X86 架构注重的是性能</p>
<ul>
<li>(1) ARM系统的作用：ARM的Jazelle技术使Java加速得到比基于软件的Java虚拟机(JVM)高得多的性能，和同等的非Java加速核相比功耗降低80%。</li>
<li>(2) Android X86的作用：项目的主要目的在于为X86平台提供一套完整的Android 系统解决方案。这个项目提供了一套完整的可行源代码树，配套文档以及Live CD与Live USB。</li>
<li>(3) ARM系统的特点：耗电少，功能强；16位/32位双指令集；合作伙伴众多。</li>
<li>(4) Android X86的特点：具有更完善的安装程序和多重启动系统；支持鼠标及部分键盘；支持待机功能；支持部分触摸屏；支持压缩档案格式。</li>
</ul>
<h4 id="RISC-V">RISC-V</h4>
<p>RISC-V是一个基于精简指令集（RISC）原则的开源指令集架构（ISA）。V表示为第五代RISC.与大多数指令集相比，RISC-V指令集可以自由地用于任何目的，允许任何人设计、制造和销售RISC-V芯片和软件。RISC-V被认为是继x86、ARM之后的第三大CPU架构。</p>
<p>RISC-V包括三大优势，</p>
<ol>
<li>模块化：RISC-V将不同的部分以模块化的方式组织在一起，这种模块化是x86与ARM架构所不具备的。</li>
<li>指令数目少：受益于短小精悍的架构以及模块化的特性，RISC-V架构的指令数目非常的简洁。</li>
<li>RISC-V全面开源，且具有全套开源免费的编译器、开发工具和软件开发环境，大大降低指令集修改的门槛。</li>
</ol>
<p>RISC-V作为新兴架构，以其精简的体量，未来的IoT（物联网）领域中能取得绝对的优势。IoT的“碎片化”需求，IoT芯片设计速度要快、成本要低、能量身定制。同时嵌入式市场具备少量多样的特点，在各细分应用场景并未形成真正壁垒，架构的选择五花八门。以上原因成就了RISC-V绝佳的突破口。RISC-V的开源能降低成本，也能让用户自由修改，可定制化，RISC-V生态与敏捷设计同源。</p>
<p>目前，国内外已有多家芯片企业投入大量资金研发RISC-V在IoT领域的应用。2015年，RISC-V基金会正式成立，吸引了包括英伟达、NXP、三星、Microsemi在内等企业的加入。迄今为止，该基金会已吸引了全球28个国家327多家会员加入。目前，阿里、亚马逊等都有相关芯片研制出，甚至就连苹果A4/A5、AMD速龙/Zen架构之父JimKeller也创业投身RISC-V了。</p>
</blockquote>
<h3 id="AOT">AOT</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/53723652">参考文档</a></p>
<blockquote>
<h4 id="AOT是干嘛的">AOT是干嘛的</h4>
<p>AOT 是<strong>静态编译</strong>，应用在安装的时候会启动 dex2oat 过程把 dex预编译成 ELF 文件，每次运行程序的时候不用重新编译。 ART 对 Garbage Collection（GC）过程的也进行了改进：</p>
<ol>
<li>只有一次 GC 暂停（Dalvik 需要两次）</li>
<li>在 GC 保持暂停状态期间并行处理</li>
<li>在清理最近分配的短时对象这种特殊情况中，回收器的总 GC 时间更短</li>
<li>优化了垃圾回收的工效，能够更加及时地进行并行垃圾回收，这使得 GC_FOR_ALLOC 事件在典型用例中极为罕见</li>
<li>压缩 GC 以减少后台内存使用和碎片</li>
</ol>
<h4 id="AOT的缺陷">AOT的缺陷</h4>
<ul>
<li>应用安装和系统升级之后的应用优化比较耗时（重新编译，把程序代码转换成机器语言）</li>
<li>优化后的文件会占用额外的存储空间（缓存转换结果）</li>
</ul>
</blockquote>
<h3 id="JIT">JIT</h3>
<p>参考阅读同上</p>
<blockquote>
<p>JIT意思是<strong>Just In Time Compiler</strong>，就是<strong>即时编译技术</strong>，与Dalvik虚拟机相关。</p>
<h4 id="JIT是干嘛的">JIT是干嘛的</h4>
<p>JIT在Android2.2到Android4.4版本，JIT的目的是为了提高Android的运行效率。</p>
<p>Dalvik虚拟机可以看做是一个Java虚拟机。在 Android系统初期，每次运行程序的时候，Dalvik负责将dex翻译为机器码交由系统调用。这样有一个<strong>缺陷</strong>：<strong>每次执行代码，都需要Dalvik将操作码代码翻译为机器对应的微处理器指令，然后交给底层系统处理，运行效率很低</strong>。</p>
<p>为了提升效率Android在2.2版本中添加了<strong>JIT编译器</strong>，当App运行时，每当遇到一个新类，JIT编译器就会对这个类进行即时编译，经过编译后的代码，会被优化成相当精简的原生型指令码（即native code），这样在下次执行到相同逻辑的时候，速度就会更快。JIT 编译器可以对执行次数频繁的 dex/odex 代码进行编译与优化，将 dex/odex 中的 Dalvik Code（Smali 指令集）翻译成相当精简的 Native Code 去执行，JIT 的引入使得 Dalvik 的性能提升了 3~6 倍。</p>
<h4 id="JIT缺陷">JIT缺陷</h4>
<ul>
<li>每次启动应用都需要重新编译（没有缓存）</li>
<li>运行时比较耗电，耗电量大</li>
</ul>
</blockquote>
<h3 id="dex">dex</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/lzzjjx/article/details/115357452?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-115357452-blog-108287804.pc_relevant_default&amp;spm=1001.2101.3001.4242.1&amp;utm_relevant_index=3">参考1</a>、<a target="_blank" rel="noopener" href="https://blog.51cto.com/zhaoyanjun/3814685">参考2</a></p>
<blockquote>
<p>dex文件是Android系统的可执行文件，包含应用程序的全部操作指令以及运行时数据。</p>
<p>相对于PC上的java虚拟机能运行.class；android上的Davlik虚拟机能运行.dex。由于dalvik是一种针对嵌入式设备而特殊设计的java虚拟机，所以dex文件与标准的class文件在结构设计上有着本质的区别。</p>
<p>当java程序编译成class后，还需要使用dex工具将所有的class文件整合到一个dex文件，目的是其中各个类能够共享数据，在一定程度上降低了冗余，同时也是文件结构更加紧凑，dex文件是传统jar文件大小的50％左右。</p>
<p>dex将原来class每个文件都有的共有信息合成一体，这样减少了class的冗余。</p>
<p>从宏观上来说dex的文件结果很简单，实际上是由多个不同结构的数据体以首尾相接的方式拼接而成。</p>
<p>为何要研究dex格式？因为dex里面包含了所有app代码，利用反编译工具可以获取java源码。理解并修改dex文件，就能更好的apk破解和防破解。</p>
<h4 id="dex好处">dex好处</h4>
<p>dex文件有个天大的好处：它可以直接用DexClassLoader类加载，这叫动态加载。于是我们只要在dex上加壳，在程序运行时脱壳，就可以规避静态反编译的风险。</p>
<h4 id="一般的反编译流程是什么样子的">一般的反编译流程是什么样子的</h4>
<p>下载apk文件，然后解压 ，得到 class.dex 文件</p>
<p>用dex2jar 把 class.dex 还原成 classes-dex2jar.jar 文件</p>
<p>用 jd-gui.exe 把 classes-dex2jar.jar 文件打开，就可以看到源码了。</p>
</blockquote>
<h3 id="DVM">DVM</h3>
<blockquote>
<h4 id="什么是Dalvik">什么是Dalvik?</h4>
<p>Dalvik是Google公司自己设计用于Android平台的虚拟机。 Dalvik虚拟机是Google等厂商合作开发的Android移动设备平台的核心组成部分之一，它可以支持已转换为 .dex格式的Java应用程序的运行，.dex格式是专为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Dalvik经过优化，允许在有限的内存中同时运行多个虚拟机的实例，并且每一个Dalvik应用作为一个独立的Linux进程执行。独立的进程可以防止在虚拟机崩溃时候所有程序都被关闭。</p>
<p>很长时间以来，Dalvik虚拟机一直被用户指责为拖慢安卓系统运行速度不如IOS的根源。2014年6月25日，Android L正式亮相于召开的谷歌i/o大会，Android L改动幅度较大，谷歌将直接删除Dalvik，代替它的是传闻已久的ART.</p>
<h4 id="Dalvik和JVM有啥关系？">Dalvik和JVM有啥关系？</h4>
<p>主要区别：</p>
<p>Dalvik是基于寄存器的，而JVM是基于栈的。</p>
<p>Dalvik运行dex文件，而JVM运行java字节码</p>
<p>自Android 2.2开始，Dalvik支持JIT(just-in-time,即时编译技术)。</p>
<p>优化后的Dalvik较其他标准虚拟机存在一些不同特性：</p>
<p>1.占用更少空间</p>
<p>2.为简化翻译，常量池只使用32位索引</p>
<p>3.标准Java字节码实行8位堆栈指令，Dalvik使用16位指令集直接作用于局部变量。局部变量通常来自4位的”虚拟寄存器”区。这样减少了Dalvik的指令指数，提高了翻译速度。</p>
</blockquote>
<h3 id="ART">ART</h3>
<blockquote>
<p>ART是一个AOT编译器。所谓AOT (Ahead of Time)是指在运行以前就把中间代码静态编译成本地代码，而JIT (Just inTime)则是在运行时动态编译。</p>
<p>ART 使用AOT，在安装apk时会进行预编译，生成OAT文件，仍以.odex保存，但是与Dalvik下不同，这个文件是可执行文件。dex、odex 均可通过dex2oat生成oat文件，以实现兼容性。在大型应用安装时需要更多时间和空间。</p>
<p>**在Android N中引入了一种新的编译模式，同时使用JIT和AOT。**这是我在网上找到的一些解释：</p>
<p>包含了一个混合模式的运行时。应用在安装时不做编译，而是解释字节码，所以可以快速启动。ART中有一种新的、更快的解释器，通过一种新的JIT完成，</p>
<p>但是这种JIT的信息不是持久化的。取而代之的是，代码在执行期间被分析，分析结果保存起来。然后，当设备空转和充电的时候，ART会执行针对“热代码”进行的基于分析的编译，其他代码不做编译。为了得到更优的代码，ART采用了几种技巧包括深度内联。 对同一个应用可以编译数次，或者找到变“热”的代码路径或者对已经编译的代码进行新的优化，</p>
<p>这取决于分析器在随后的执行中的分析数据。</p>
<p><strong>新的ART在安装程序时使用JIT，在JIT编译了一些代码后将这些代码保存到本地，等到设备空闲的时候将保存的这些代码使用AOT编译生成可执行文件保存到本地，待下次运行时直接使用，并且不断监视代码的更新，在代码有更新后重新生成可执行文件。</strong></p>
</blockquote>
<blockquote>
<p>ART的机制与Dalvik不同。在Dalvik下，应用每次运行的时候，字节码都需要通过即时编译器（just in time, JIT）转换为机器码，这会拖慢应用的运行效率，而在ART环境中，应用在第一次安装的时候，字节码酒会预先编译成机器码，使其成为真正的本地应用。这个过程叫做预编译(AOT,Ahead-Of-Time). 这样的话，应用的启动（首次）和执行都会变得更加快速.</p>
<p>优点：</p>
<p>1，系统性能的显著提升<br>
2，应用启动更快，运行更快，体验更流畅，触感反馈更及时<br>
3，更长的电池续航能力<br>
4，支持更低的硬件</p>
<p>缺点：</p>
<p>1,   机器码占用的存储空间更大，字节码变为机器码之后，可能会增加10%-20%(不过在应用包中，可执行的代码常常只是一部分。比如最新的Google+ Apk是 28.3mb, 但是代码只有6.9mb)<br>
2，应用的安装时间会变长</p>
</blockquote>
<h3 id="AVD">AVD</h3>
<blockquote>
<p>Android 虚拟设备 (AVD) 是一种配置，用于定义您要在 <a target="_blank" rel="noopener" href="https://developer.android.com/studio/run/emulator?hl=zh-cn">Android 模拟器</a>中模拟的 Android 手机、平板电脑、Wear OS、Android TV 或 Automotive OS 设备的特性。</p>
<p>AVD 包含硬件配置文件、系统映像、存储区域、皮肤和其他属性。</p>
</blockquote>
<h3 id="Camera2">Camera2</h3>
<blockquote>
<p>对于大多数开发者，我们推荐使用 <a target="_blank" rel="noopener" href="https://developer.android.com/training/camerax?hl=zh-cn">CameraX</a>。CameraX 是一个 Jetpack 库，支持绝大多数 Android 设备（Android 5.0 及更高版本），并提供围绕常见用例设计的一致的高级别 API。CameraX 会为您解决设备兼容性问题，因此您无需向应用添加针对特定设备的代码。</p>
<p>CameraX 基于 <a target="_blank" rel="noopener" href="https://developer.android.com/training/camera2?hl=zh-cn">Camera2</a> 软件包构建而成。如果您需要低级别的相机控件来支持复杂用例，那么 Camera2 是一个不错的选择，但相应 API 比 CameraX 更复杂，并且您需要管理设备专属配置。与 CameraX 一样，Camera2 适用于 Android 5.0（API 级别 21）及更高版本。</p>
<p>原始 Android <a target="_blank" rel="noopener" href="https://developer.android.com/training/camera?hl=zh-cn">Camera</a> 类已废弃。新应用应使用 CameraX（推荐）或 Camera2；现有应用应进行迁移，以便充分利用新功能，并避免与未来设备不兼容。</p>
</blockquote>
<h3 id="CGI">CGI</h3>
<p>摘自<a target="_blank" rel="noopener" href="https://blog.csdn.net/liitdar/article/details/79896457">此文</a></p>
<blockquote>
<p>CGI（Common Gateway Interface），即通用网关接口，是 WWW（World Wide Web）技术中最重要的技术之一，是外部应用程序（即 CGI 程序）与 Web 服务器之间的接口标准，负责在 CGI 程序和 Web 服务器之间传递信息。</p>
<p>CGI 是 Web 服务器运行时，调用外部应用程序（即 CGI 程序）的规范，CGI 规范允许 Web 服务器执行外部程序，并将它们的输出发送给 Web 浏览器，CGI 将 Web 的一组简单的静态超媒体文档变成一个完整的、新的交互式媒体，按照 CGI 编写的程序可以扩展 Web 服务器功能。</p>
<p>出现背景：CGI 是比较原始的开发动态网站的方式。由于静态的 HTML 页面无法实现网站的动态内容的生成，所以就需要由 Web 服务器调用 CGI 程序，CGI 程序生成动态内容，返回给 Web 服务器，Web 服务器再返回给 Web 浏览器。</p>
<p>CGI 应用程序能通过 Web 服务器与 Web 浏览器进行交互，还可以通过数据库 API 与数据库服务器等外部数据源进行通信，从数据库服务器中获取数据，将数据格式化为 HTML 文档后，发送给 Web 浏览器，也可以将从 Web 浏览器获得的数据放到数据库中。CGI 与这几者的关系图如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="移动互联网名词/1.png" style="zoom:60%;" />
<p>几乎所有 Web 服务器都支持 CGI，可用多种语言编写 CGI（包括流行的 C、C++ 等），只要这种语言具有标准输入、输出和环境变量即可。</p>
<p>大多数的 CGI 程序被用来解释处理来自表单的输入信息，并在服务器产生相应的处理，或将相应的信息反馈给 Web 浏览器，CGI 程序使网页具有了交互功能。<br>
————————————————<br>
版权声明：本文为CSDN博主「liitdar」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/liitdar/article/details/79896457">https://blog.csdn.net/liitdar/article/details/79896457</a></p>
</blockquote>
<h3 id="LLVM">LLVM</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/75723370">推荐阅读</a></p>
<blockquote>
<p>LLVM项目包含了一系列的模块化，可复用的编译器和工具链集合。</p>
<p><a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fllvm.org%2F">官方</a>描述如下：<br>
The LLVM Project is a collection of modular and reusable compiler and toolchain technologies. Despite its name, LLVM has little to do with traditional virtual machines. The name “LLVM” itself is not an acronym; it is the full name of the project.</p>
<p>在官网上罗列了11个LLVM子项目。其中2个最重要的：</p>
<ol>
<li>
<p>LLVM　核心优化器（optimizer）。它不依赖于源码和目标机器指令集。这个核心库基于LLVM的中间表示（LLVM intermedaite representation）。</p>
</li>
<li>
<p>Clang 编译器（compiler）。Clang目标是实现一个C/C++/Objective-C compiler。Clang可以提供非常有用的错误和警告信息。Clang Static Analyzer是一个自动化发bug的工具。</p>
</li>
</ol>
</blockquote>
<h3 id="clang">clang</h3>
<p><a target="_blank" rel="noopener" href="https://yupeng.fun/2020/01/11/clang-llvm/">推荐阅读</a></p>
<blockquote>
<h4 id="什么是clang编译器？">什么是clang编译器？</h4>
<p>LLVM (Low Level Virtual Machine) 是一个开源的编译器架构。Clang 是 LLVM 的一个编译器前端，它目前支持 C, C++, Objective-C 等编程语言。</p>
<p>Clang 对源程序进行预处理、词法分析、语法分析，并将分析结果转换为 Abstract Syntax Tree ( 抽象语法树 ) ，最后使用 LLVM 作为编译器后端代码的生成器。</p>
<p>Clang 的开发目标是提供一个可以替代 GCC 的前端编译器。Apple 对 Objective-C 新增很多特性，想做的很多功能，比如更好的IDE支持，GCC 不能很好的支持，于是，苹果开发了 Clang 与 LLVM 来完全取代GCC。Clang作为编译器前端，LLVM作为编译器后端。</p>
<h4 id="clang编译器的优势与劣势">clang编译器的优势与劣势</h4>
<p>相比于gcc，clang 具有如下优势：</p>
<ul>
<li>编译速度更快：在某些平台上，clang 的编译速度要明显快于gcc。</li>
<li>占用内存更小：clang生成的AST所占用的内存通常是gcc的五分之一左右。</li>
<li>模块化的设计：clang采用基于库的模块化设计，更易于IDE的集成及其他用途的重用。</li>
<li>诊断信息可读性强：在编译过程中，clang会创建并保留大量详细的元数据 (metadata)，这将更有利于调试和错误报告。</li>
<li>设计更清晰简单，容易理解，易于扩展加强。与代码基础较为古老的gcc相比，学习曲线会显得更为平缓。</li>
</ul>
<p>当前 Clang 还处在不断完善过程中，相比于 gcc，clang在以下方面还有待加强：</p>
<ul>
<li>需要支持更多语言：gcc除了支持 C/C++/Objective-C, 还支持Fortran/Pascal/Java/Ada/Go等其他语言。clang目前基本上只支持C/C++/Objective-C/Objective-C++这四种语言。</li>
<li>需要加强对C++的支持：clang对C++的支持依然落后于gcc，clang还需要加强对C++ 提供全方位支持。</li>
<li>需要支持更多平台：由于gcc流行的时间比较长，已经被广泛使用，对各种平台的支持也很完备。clang目前支持的平台有 Linux/Windows/Mac OS。</li>
</ul>
</blockquote>
<h3 id="dex2jar">dex2jar</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/433259910">推荐阅读（参考）</a></p>
<blockquote>
<p>1、dex2jar 工具主要是将 dex 文件转换为包含 class 文件的 jar 文件。<br>
2、JD-GUI 工具是针对从dex 转为jar后的文件，进行可视化读取与展示。</p>
<p>apk 安装包本质是经过特殊处理的压缩包，可以直接将 target.apk 修改后缀名为 target.zip，然后通过解压工具解压，解压后的文件夹包含各种资源文件和文件夹，以及 dex 文件，如果apk是多个 dex 文件组成，解压后会有多个dex 存在，可逐个操作，最终会生成jar文件。</p>
<p>直接将 之前通过dex2jar生成的 jar文件拖入 JD-GUI 即可查看源码，通过工具可以查看到源码是否有混淆。</p>
</blockquote>
<h3 id="findViewById">findViewById</h3>
<blockquote>
<p>安卓编程的定位函数，主要是引用<code>.R</code>文件里的引用名。一般在<code>R.java</code>文件里系统会自动帮你给出你在XML里定义的ID或者<code>Layout</code>里面的名称，例如：<code>Button button=(Button)findViewById(R.id.button01);</code>这样就引用了XML（res里的布局文件）文件里面的<code>button</code>，使得在写<code>.java</code>的按钮时能与XML里的一致。<br>
————————————————<br>
版权声明：本文为CSDN博主「proveyourself」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</p>
<p>原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/sugesi/article/details/77103727">https://blog.csdn.net/sugesi/article/details/77103727</a></p>
</blockquote>
<p>替代品，<a target="_blank" rel="noopener" href="https://developer.android.com/topic/libraries/view-binding?hl=zh-cn">推荐阅读</a></p>
<blockquote>
<p>通过视图绑定功能，您可以更轻松地编写可与视图交互的代码。在模块中启用视图绑定之后，系统会为该模块中的每个 XML 布局文件生成一个绑定类。绑定类的实例包含对在相应布局中具有 ID 的所有视图的直接引用。</p>
<p>在大多数情况下，视图绑定会替代 <code>findViewById</code>。</p>
<p>与使用 <code>findViewById</code> 相比，视图绑定具有一些很显著的优点：</p>
<ul>
<li><strong>Null 安全</strong>：由于视图绑定会创建对视图的直接引用，因此不存在因视图 ID 无效而引发 Null 指针异常的风险。此外，如果视图仅出现在布局的某些配置中，则绑定类中包含其引用的字段会使用 <code>@Nullable</code> 标记。</li>
<li><strong>类型安全</strong>：每个绑定类中的字段均具有与它们在 XML 文件中引用的视图相匹配的类型。这意味着不存在发生类转换异常的风险。</li>
</ul>
<p>这些差异意味着布局和代码之间的不兼容将会导致构建在编译时（而非运行时）失败。</p>
</blockquote>
<h3 id="Flutter">Flutter</h3>
<p><a target="_blank" rel="noopener" href="https://book.flutterchina.club/chapter1/flutter_intro.html#_1-2-1-flutter-%E7%AE%80%E4%BB%8B">推荐阅读</a></p>
<blockquote>
<h2 id="1-2-1-Flutter-简介">1.2.1 Flutter 简介</h2>
<p>Flutter 是 Google 推出并开源的移动应用开发框架，主打跨平台、高保真、高性能。开发者可以通过 Dart 语言开发 App，一套代码同时运行在 iOS 和 Android平台。 Flutter 提供了丰富的组件、接口，开发者可以很快地为 Flutter 添加 Native 扩展。下面我们整体介绍一下 Flutter 技术的主要特点。</p>
<h3 id="1-跨平台自绘引擎"><a target="_blank" rel="noopener" href="https://book.flutterchina.club/chapter1/flutter_intro.html#_1-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%87%AA%E7%BB%98%E5%BC%95%E6%93%8E">#</a>1. 跨平台自绘引擎</h3>
<p>Flutter 与用于构建移动应用程序的其它大多数框架不同，因为 Flutter 既不使用 WebView，也不使用操作系统的原生控件。 相反，Flutter 使用自己的高性能渲染引擎来绘制 Widget（组件）。这样不仅可以保证在 Android 和iOS 上 UI 的一致性，也可以避免对原生控件依赖而带来的限制及高昂的维护成本。</p>
<p>Flutter 底层使用 Skia 作为其 2D 渲染引擎，Skia 是 Google的一个 2D 图形处理函数库，包含字型、坐标转换，以及点阵图，它们都有高效能且简洁的表现。Skia 是跨平台的，并提供了非常友好的 API，目前 Google Chrome浏览器和 Android 均采用 Skia 作为其 2D 绘图引擎。</p>
<p>目前 Flutter 已经支持 iOS、Android、Web、Windows、macOS、Linux、Fuchsia（Google新的自研操作系统）等众多平台，但本书的示例和介绍主要是基于 iOS 和 Android 平台的，其它平台读者可以自行了解。</p>
<h3 id="2-高性能"><a target="_blank" rel="noopener" href="https://book.flutterchina.club/chapter1/flutter_intro.html#_2-%E9%AB%98%E6%80%A7%E8%83%BD">#</a>2. 高性能</h3>
<p>Flutter 高性能主要靠两点来保证：</p>
<p>第一：Flutter APP 采用 Dart 语言开发。Dart 在 JIT（即时编译）模式下，执行速度与 JavaScript 基本持平。但是 Dart 支持 AOT，当以 AOT模式运行时，JavaScript 便远远追不上了。执行速度的提升对高帧率下的视图数据计算很有帮助。</p>
<p>第二：Flutter 使用自己的渲染引擎来绘制 UI ，布局数据等由 Dart 语言直接控制，所以在布局过程中不需要像 RN 那样要在 JavaScript 和 Native 之间通信，这在一些滑动和拖动的场景下具有明显优势，因为在滑动和拖动过程往往都会引起布局发生变化，所以 JavaScript 需要和 Native 之间不停的同步布局信息，这和在浏览器中JavaScript 频繁操作 DOM 所带来的问题是类似的，都会导致比较可观的性能开销。</p>
<h3 id="3-采用Dart语言开发"><a target="_blank" rel="noopener" href="https://book.flutterchina.club/chapter1/flutter_intro.html#_3-%E9%87%87%E7%94%A8dart%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91">#</a>3. 采用Dart语言开发</h3>
<p>这个是一个很有意思但也很有争议的问题，在了解 Flutter 为什么选择了 Dart 而不是 JavaScript 之前我们先来介绍一下之前提到过的两个概念：JIT 和 AOT。</p>
<p>程序主要有两种运行方式：静态编译与动态解释。静态编译的程序在执行前程序会被提前编译为机器码（或中间字节码），通常将这种类型称为<strong>AOT</strong> （Ahead of time）即 “提前编译”。而解释执行则是在运行时将源码实时翻译为机器码来执行，通常将这种类型称为<strong>JIT</strong>（Just-in-time）即“即时编译”。</p>
<p>AOT 程序的典型代表是用 C/C++ 开发的应用，它们必须在执行前编译成机器码；而JIT的代表则非常多，如JavaScript、python等，事实上，所有脚本语言都支持 JIT 模式。但需要注意的是 JIT 和 AOT 指的是程序运行方式，和编程语言并非强关联的，有些语言既可以以 JIT 方式运行也可以以 AOT 方式运行，如Python，它可以在第一次执行时编译成中间字节码，然后在之后执行时再将字节码实施转为机器码执行。也许有人会说，中间字节码并非机器码，在程序执行时仍然需要动态将字节码转为机器码，这不应该是 JIT 吗 ? 是这样，但通常我们区分是否为AOT 的标准就是看代码在执行之前<strong>是否需要编译</strong>，只要需要编译，无论其编译产物是字节码还是机器码，都属于AOT。在此，读者不必纠结于概念，概念就是为了传达精神而发明的，只要读者能够理解其原理即可，得其神忘其形。</p>
<p>现在我们看看 Flutter 为什么选择 Dart 语言？笔者根据官方解释以及自己对 Flutter 的理解总结了以下几条（由于其它跨平台框架都将 JavaScript 作为其开发语言，所以主要将 Dart 和 JavaScript 做一个对比）：</p>
<ol>
<li>
<p><strong>开发效率高</strong>。</p>
<p>Dart 运行时和编译器支持 Flutter 的两个关键特性的组合：</p>
<ul>
<li><strong>基于 JIT 的快速开发周期</strong>：Flutter 在开发阶段采用，采用 JIT 模式，这样就避免了每次改动都要进行编译，极大的节省了开发时间；</li>
<li><strong>基于 AOT 的发布包</strong>: Flutter 在发布时可以通过 AOT 生成高效的机器码以保证应用性能。而 JavaScript 则不具有这个能力。</li>
</ul>
</li>
<li>
<p><strong>高性能</strong>。</p>
<p>Flutter 旨在提供流畅、高保真的的 UI 体验。为了实现这一点，Flutter 中需要能够在每个动画帧中运行大量的代码。这意味着需要一种既能提供高性能的语言，而不会出现会丢帧的周期性暂停，而 Dart 支持 AOT，在这一点上可以做的比 JavaScript 更好。</p>
</li>
<li>
<p><strong>快速内存分配</strong>。</p>
<p>Flutter 框架使用函数式流，这使得它在很大程度上依赖于底层的内存分配器。因此，拥有一个能够有效地处理琐碎任务的内存分配器将显得十分重要，在缺乏此功能的语言中，Flutter 将无法有效地工作。当然 Chrome V8 的 JavaScript 引擎在内存分配上也已经做的很好，事实上 Dart 开发团队的很多成员都是来自Chrome 团队的，所以在内存分配上 Dart 并不能作为超越 JavaScript 的优势，而对于Flutter来说，它需要这样的特性，而 Dart 也正好满足而已。</p>
</li>
<li>
<p><strong>类型安全和空安全</strong>。</p>
<p>由于 Dart 是类型安全的语言，且 2.12 版本后也支持了空安全特性，所以 Dart 支持静态类型检测，可以在编译前发现一些类型的错误，并排除潜在问题，这一点对于前端开发者来说可能会更具有吸引力。与之不同的，JavaScript 是一个弱类型语言，也因此前端社区出现了很多给 JavaScript 代码添加静态类型检测的扩展语言和工具，如：微软的 TypeScript 以及Facebook 的 Flow。相比之下，Dart 本身就支持静态类型，这是它的一个重要优势。</p>
</li>
</ol>
</blockquote>
<h3 id="git">git</h3>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/ThinkWon/article/details/94346816">推荐阅读</a></p>
<blockquote>
<p>Git是一款免费、开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</p>
<p>Git是一个开源的<strong>分布式版本控制系统</strong>，可以有效、高速的处理从很小到非常大的项目版本管理。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<h4 id="Git特点">Git特点</h4>
<p>优点：</p>
<ul>
<li>
<p>适合分布式开发，强调个体；</p>
</li>
<li>
<p>公共服务器压力和数据量都不会太大；</p>
</li>
<li>
<p>速度快、灵活；</p>
</li>
<li>
<p>任意两个开发者之间可以很容易的解决冲突；</p>
</li>
<li>
<p>离线工作。</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>
<p>代码保密性差，一旦开发者把整个库克隆下来就可以完全公开所有代码和版本信息；</p>
</li>
<li>
<p>权限控制不友好；如果需要对开发者限制各种权限的建议使用SVN。</p>
</li>
</ul>
<p>————————————————<br>
版权声明：本文为CSDN博主「ThinkWon」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/ThinkWon/article/details/94346816">https://blog.csdn.net/ThinkWon/article/details/94346816</a></p>
</blockquote>
<h3 id="GPS">GPS</h3>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%BB%9F">推荐阅读</a></p>
<blockquote>
<p><strong>全球定位系统</strong>（英语：<strong>G</strong>lobal <strong>P</strong>ositioning <strong>S</strong>ystem，通常简称<strong>GPS</strong>），又称<strong>全球卫星定位系统</strong>，是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E9%98%B2%E9%83%A8">美国国防部</a>研制，<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9C%8B%E5%A4%AA%E7%A9%BA%E8%BB%8D">美国太空军</a>运营与维护的中距离圆型轨道<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F">卫星导航系统</a>。它可以为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%83">地球</a>表面绝大部分地区（98%）提供准确的定位、测速和高精度的标准时间。全球定位系统可满足位于全球地面任何一处或近地空间的军事用户连续且精确地确定三维位置、三维运动和时间的需求。该系统包括<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%A4%AA%E7%A9%BA">太空</a>中的31颗GPS<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BA%BA%E9%80%A0%E8%A1%9B%E6%98%9F">人造卫星</a>；地面上1个主控站、3个数据注入站和5个监测站，及作为用户端的GPS军用接收机器、智能手机等。最少只需其中4卫星，就能迅速确定用户端在<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%83">地球</a>上所处的位置及<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%B5%B7%E6%8B%94%E9%AB%98%E5%BA%A6">海拔高度</a>；所能接收到的卫星讯号数越多，解码出来的位置就越精确。</p>
<p>GPS系统拥有如下多种优点：使用低频讯号，就算天气不佳仍能保持相当的讯号穿透性；高达98%的全球覆盖率；高精度三维定速定时；快速、省时、高效率；应用广泛、多功能；可移动定位。不同于双星定位系统，使用过程中接收机不需要发出任何信号；此举增加了隐蔽性，提高了其军事应用效能。</p>
</blockquote>
<h3 id="HTML5">HTML5</h3>
<p><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-hans/HTML5">推荐阅读</a></p>
<blockquote>
<p>HTML5 是<strong>最新的 HTML 标准</strong>。HTML5 是专门<strong>为承载丰富的 web 内容而设计的</strong>，并且无需额外插件。HTML5 <strong>拥有新的语义、图形以及多媒体元素</strong>。HTML5 提供的新元素和新的 API 简化了 web 应用程序的搭建。HTML5 是<strong>跨平台</strong>的，被设计为在不同类型的硬件（PC、平板、手机、电视机等等）之上运行。</p>
<hr>
<p><strong>HTML5</strong>是<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/HTML">HTML</a>最新的修订版本，由<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E4%B8%87%E7%BB%B4%E7%BD%91%E8%81%94%E7%9B%9F">万维网联盟</a>（W3C）于2014年10月完成标准制定。目标是取代1999年所制定的<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/HTML">HTML</a> 4.01和<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/XHTML">XHTML</a> 1.0标准，以期能在网际网路应用迅速发展的时候，使网路标准达到符合当代的网路需求。广义论及HTML5时，实际指的是包括HTML、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/CSS">CSS</a>和<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/JavaScript">JavaScript</a>在内的一套技术组合。它希望能够减少<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E7%B6%B2%E9%A0%81%E7%80%8F%E8%A6%BD%E5%99%A8">网页浏览器</a>对于需要<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E6%8F%92%E4%BB%B6">外挂程式</a>的<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%B1%90%E5%AF%8C%E6%80%A7%E7%B6%B2%E8%B7%AF%E6%87%89%E7%94%A8%E6%9C%8D%E5%8B%99">丰富性网路应用服务</a>（Plug-in-Based Rich Internet Application，RIA），例如：<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Adobe_Flash_Player">Adobe Flash</a>、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Microsoft">Microsoft</a> <a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Silverlight">Silverlight</a>与<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Oracle">Oracle</a> <a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/JavaFX">JavaFX</a>的需求，并且提供更多能有效加强网路应用的标准集。</p>
</blockquote>
<h3 id="HttpURLConnection">HttpURLConnection</h3>
<p>虽然更喜欢<code>OKHttp</code></p>
<blockquote>
<p>JDK的java.net包中提供了访问HTTP协议的基本功能的类：HttpURLConnection。</p>
<p>URLConnection是个抽象类，它有两个直接子类分别是HttpURLConnection和JarURLConnection。另外一个重要的类是URL，通常URL可以通过传给构造器一个String类型的参数来生成一个指向特定地址的URL实例。</p>
<p>HttpURLConnection是Java的标准类，它继承自URLConnection，可用于向指定网站发送GET请求、POST请求。它在URLConnection的基础上提供了如下便捷的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResponseCode</span><span class="params">()</span></span>;        <span class="comment">// 获取服务器的响应代码。</span></span><br><span class="line"><span class="function">String <span class="title">getResponseMessage</span><span class="params">()</span></span>;  <span class="comment">// 获取服务器的响应消息。</span></span><br><span class="line"><span class="function">String <span class="title">getResponseMethod</span><span class="params">()</span></span>;   <span class="comment">// 获取发送请求的方法。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setRequestMethod</span><span class="params">(String method)</span></span>; <span class="comment">// 设置发送请求的方法。</span></span><br></pre></td></tr></table></figure>
<p>每个 HttpURLConnection 实例都可用于生成单个请求，但是其他实例可以透明地共享连接到 HTTP 服务器的基础网络。请求后在 HttpURLConnection 的 InputStream 或 OutputStream 上调用 close() 方法可以释放与此实例关联的网络资源，但对共享的持久连接没有任何影响。如果在调用 disconnect() 时持久连接空闲，则可能关闭基础套接字。<br>
————————————————<br>
版权声明：本文为CSDN博主「冯insist」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40036754/article/details/102554755">https://blog.csdn.net/qq_40036754/article/details/102554755</a></p>
</blockquote>
<h3 id="HUAWEI-DevEco-Studio">HUAWEI DevEco Studio</h3>
<p><a target="_blank" rel="noopener" href="https://developer.harmonyos.com/cn/docs/documentation/doc-guides/tools_overview-0000001053582387">推荐阅读</a></p>
<blockquote>
<p>HUAWEI DevEco Studio（以下简称DevEco Studio）是基于IntelliJ IDEA Community开源版本打造，面向华为终端全场景多设备的一站式集成开发环境（IDE），为开发者提供工程模板创建、开发、编译、调试、发布等E2E的HarmonyOS应用/服务开发。通过使用DevEco Studio，开发者可以更高效的开发具备HarmonyOS分布式能力的应用/服务，进而提升创新效率。</p>
<p>作为一款开发工具，除了具有基本的代码开发、编译构建及调测等功能外，DevEco Studio还具有如下特点：</p>
<ul>
<li><strong>多设备统一开发环境</strong>：支持多种HarmonyOS设备的应用/服务开发，包括手机（Phone）、平板（Tablet）、车机（Car）、智慧屏（TV）、智能穿戴（Wearable），轻量级智能穿戴（LiteWearable）和智慧视觉（Smart Vision）设备。</li>
<li><strong>支持多语言的代码开发和调试</strong>：包括Java、XML（Extensible Markup Language）、C/C++ 、eTS（Extended TypeScript）、 JS（JavaScript）、CSS（Cascading Style Sheets）和HML（HarmonyOS Markup Language）。</li>
<li><strong>支持FA（Feature Ability）和PA（Particle Ability）快速开发</strong>：通过工程向导快速创建FA/PA工程模板，一键式打包成HAP（HarmonyOS Ability Package）。</li>
<li><strong>支持分布式多端应用/服务开发</strong>：一个工程和一份代码可跨设备运行，支持不同设备界面的实时预览和差异化开发，实现代码的最大化重用。</li>
<li><strong>支持多设备模拟器</strong>：提供多设备的模拟器资源，包括手机、平板、车机、智慧屏、智能穿戴设备的模拟器，方便开发者高效调试。</li>
<li><strong>支持多设备预览器</strong>：提供JS和Java预览器功能，可以实时查看应用/服务的布局效果，支持实时预览和动态预览；同时还支持多设备同时预览，查看同一个布局文件在不同设备上的呈现效果。</li>
</ul>
</blockquote>
<h3 id="HAXM">HAXM</h3>
<blockquote>
<p>Hardware Accelerated Execution Manager的缩写。</p>
<p>intel的硬件加速执行管理器，是一款可以使用英特尔虚拟化技术（VT）加快 Android* 开发速度的硬件辅助虚拟化引擎（管理程序）。是AMD的CPU不能安装，在CPU中增加了控制硬件，对应开启VT的时候，启动一些模拟指令（或者新增部分基础指令）来加速运算，减少各个周期以达到优化效果。开启HAXM的时候，android模拟器的速度会明显增快。</p>
<p>HAXM是一个跨平台的硬件辅助虚拟化引擎（hypervisor），广泛用作Android Emulator和QEMU的加速器。<br>
————————————————<br>
版权声明：本文为CSDN博主「hankern」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hankern/article/details/117400801">https://blog.csdn.net/hankern/article/details/117400801</a></p>
<hr>
<p>以下参考<a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-cn/xamarin/android/get-started/installation/android-emulator/hardware-acceleration?pivots=windows">here</a></p>
<p>以下虚拟化技术可用于加速 Android Emulator：</p>
<ol>
<li><strong>Microsoft 的 Hyper-V 和 Windows 虚拟机监控程序平台 (WHPX)</strong> 。 <a target="_blank" rel="noopener" href="https://docs.microsoft.com/zh-CN/virtualization/hyper-v-on-windows/">Hyper-V</a> 是 Windows 的虚拟化功能，使虚拟的计算机系统可以在物理主计算机上运行。</li>
<li><strong>Intel 硬件加速执行管理器 (HAXM)</strong> 。 HAXM 是运行 Intel CPU 的计算机所用的虚拟化引擎。</li>
</ol>
<p>为了在 Windows 上获得最佳体验，建议使用 WHPX 来加速 Android Emulator。 如果计算机没有 Hyper-V，则可使用 HAXM。 如果满足以下条件，Android Emulator 将自动使用硬件加速：</p>
<ul>
<li>硬件加速在开发计算机上可用并已启用。</li>
<li>仿真器正在运行为基于 x86 的虚拟设备创建的系统映像。</li>
</ul>
</blockquote>
<h3 id="ImageView">ImageView</h3>
<blockquote>
<p>ImageView 继承自View组件，主要功能是用于显示图片，实际上它不仅仅可以用来显示图片，任何Drawable对象都可以使用ImageView来显示。ImageView可以适用于任何布局中，并且Android为其提供了缩放和着色的一些操作。</p>
</blockquote>
<h3 id="Intent">Intent</h3>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/intents-filters?hl=zh-cn">推荐阅读</a></p>
<blockquote>
<p><code>Intent</code> 是一个消息传递对象，您可以用来从其他<a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/fundamentals?hl=zh-cn#Components">应用组件</a>请求操作。尽管 Intent 可以通过多种方式促进组件之间的通信，但其基本用例主要包括以下三个：</p>
<ul>
<li>
<p>启动 Activity</p>
<p><code>Activity</code> 表示应用中的一个屏幕。通过将 <code>Intent</code> 传递给 <code>startActivity()</code>，您可以启动新的 <code>Activity</code> 实例。<code>Intent</code> 用于描述要启动的 Activity，并携带任何必要的数据。</p>
<p>如果您希望在 Activity 完成后收到结果，请调用 <code>startActivityForResult()</code>。在 Activity 的 <code>onActivityResult()</code> 回调中，您的 Activity 将结果作为单独的 <code>Intent</code> 对象接收。如需了解详细信息，请参阅 <a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/activities?hl=zh-cn">Activity</a> 指南。</p>
</li>
<li>
<p>启动服务</p>
<p><code>Service</code> 是一个不使用用户界面而在后台执行操作的组件。使用 Android 5.0（API 级别 21）及更高版本，您可以启动包含 <code>JobScheduler</code> 的服务。如需了解有关 <code>JobScheduler</code> 的详细信息，请参阅其 <code>API-reference documentation</code>。</p>
<p>对于 Android 5.0（API 级别 21）之前的版本，您可以使用 <code>Service</code> 类的方法来启动服务。通过将 <code>Intent</code> 传递给 <code>startService()</code>，您可以启动服务执行一次性操作（例如，下载文件）。<code>Intent</code> 用于描述要启动的服务，并携带任何必要的数据。</p>
<p>如果服务旨在使用客户端-服务器接口，则通过将 <code>Intent</code> 传递给 <code>bindService()</code>，您可以从其他组件绑定到此服务。如需了解详细信息，请参阅<a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/services?hl=zh-cn">服务</a>指南。</p>
</li>
<li>
<p>传递广播</p>
<p>广播是任何应用均可接收的消息。系统将针对系统事件（例如：系统启动或设备开始充电时）传递各种广播。通过将 <code>Intent</code> 传递给 <code>sendBroadcast()</code> 或 <code>sendOrderedBroadcast()</code>，您可以将广播传递给其他应用。</p>
<h4 id="Intent-类型">Intent 类型</h4>
<p>Intent 分为两种类型：</p>
<ul>
<li><strong>显式 Intent</strong>：通过提供目标应用的软件包名称或完全限定的组件类名来指定可处理 Intent 的应用。通常，您会在自己的应用中使用显式 Intent 来启动组件，这是因为您知道要启动的 Activity 或服务的类名。例如，您可能会启动您应用内的新 Activity 以响应用户操作，或者启动服务以在后台下载文件。</li>
<li><strong>隐式 Intent</strong> ：不会指定特定的组件，而是声明要执行的常规操作，从而允许其他应用中的组件来处理。例如，如需在地图上向用户显示位置，则可以使用隐式 Intent，请求另一具有此功能的应用在地图上显示指定的位置。</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="jar">jar</h3>
<blockquote>
<h4 id="JAR-包是什么">JAR 包是什么</h4>
<p>JAR 文件的全称 Java Archive File（Java 档案文件），通常 JAR 文件是一种压缩格式，和 ZIP 格式兼容，与 ZIP格式不同的是它 包含了一个名为 META-INF/MANIFEST.MF的清单文件，这个清单文件是由生成 JAR 包的时候系统自动创建的，这个清单文件与我们可以不做关注。</p>
<h4 id="JAR-包的用途">JAR 包的用途</h4>
<p>当我们开发了一个程序以后，程序中有很多的类，如果需要提供给别人使用，发给对方一堆的源文件是非常不好的，通常需要把这些类打包成一个 JAR 包，把这个 JAR 包提供给别人使用，只需要别人在CLASSPATH 环境变量中添加这个 JAR 包，则 Java 虚拟机就可以在内存中解析这个 JAR 包了，这个 JAR 包就是一个路径，就像我们电脑访问普通文件一样，Java 虚拟机会根据路径查找相应的文件。</p>
<h4 id="JAR-包的优点">JAR 包的优点</h4>
<p>体积小,安全,可移植性强，封装好等优点.</p>
<p>作者：Lstone<br>
链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/2b2e7d7fb160">https://www.jianshu.com/p/2b2e7d7fb160</a><br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="JNI">JNI</h3>
<blockquote>
<p><strong>JNI (Java Native Interface) 介绍</strong></p>
<p>JNI是一个协议，这个协议用来沟通Java代码和外部本地代码(c/c++)，外部的c/c++代码也可以调用Java代码。</p>
<p>以下是<a target="_blank" rel="noopener" href="https://links.jianshu.com/go?to=https%3A%2F%2Fdocs.oracle.com%2Fjavase%2F6%2Fdocs%2Ftechnotes%2Fguides%2Fjni%2F">oracle</a>对JNI的定义<br>
JavaTM Native Interface (JNI) is a standard programming interface for writing Java native methods and embedding the JavaTM virtual machine* into native applications. The primary goal is binary compatibility of native method libraries across all Java virtual machine implementations on a given platform.</p>
<p><strong>JNI的优点</strong></p>
<ul>
<li>
<p>效率上c/c++是本地代码，比java更高效</p>
</li>
<li>
<p>代码移植，如果之前用c语言开发过的模块，可以复用已经存在的c代码</p>
</li>
<li>
<p>java反编译比c语言容易，一般加密算法都是用c语言编码，不容易被反编译</p>
</li>
</ul>
</blockquote>
<h3 id="ssh-L-R-D">ssh/-L-R-D</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/57630633">推荐阅读</a></p>
<blockquote>
<p>ssh 命令除了登陆外还有三种代理功能：</p>
<ul>
<li>正向代理（-L）：相当于 iptable 的 port forwarding</li>
<li>反向代理（-R）：相当于 frp 或者 ngrok</li>
<li>socks5 代理（-D）：相当于 ss/ssr</li>
</ul>
<p><strong>正向代理</strong></p>
<p>所谓“正向代理”就是在本地启动端口，把本地端口数据转发到远端。</p>
<p><strong>反向代理</strong></p>
<p>所谓“反向代理”就是让远端启动端口，把远端端口数据转发到本地。</p>
<p><strong>本地 socks5 代理</strong></p>
<p>在 HostA 的本地 1080 端口启动一个 socks5 服务，通过本地 socks5 代理的数据会通过 ssh 链接先发送给 HostB，再从 HostB 转发送给远程主机：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HostA$ ssh -D localhost:1080  HostB</span><br></pre></td></tr></table></figure>
<p>那么在 HostA 上面，浏览器配置 socks5 代理为 127.0.0.1:1080，看网页时就能把数据通过 HostB 代理出去，类似 ss/ssr 版本，只不过用 ssh 来实现。</p>
</blockquote>
<h3 id="JSch">JSch</h3>
<blockquote>
<h4 id="SSH的介绍">SSH的介绍</h4>
<p>SSH(Secure Shell)是一种网络协议，<strong>用于互联网上不同设备之间信息的安全传输</strong>，在安全性方面其使用了公钥的加密技术。目前大都数的Linux中都运行着OpenSSH,为用户安全的提供远程登录管理和其他数据传输的功能.</p>
<h4 id="JSCH的介绍">JSCH的介绍</h4>
<p>JSch 是SSH2的一个纯Java实现。它允许你连接到一个sshd 服务器，使用<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91&amp;spm=1001.2101.3001.7020">端口转发</a>，X11转发，文件传输等等。你可以将它的功能集成到你自己的程序中。同时该项目也提供一个J2ME版本用来在手机上直连SSHD服务器。</p>
<p><strong>SSH</strong> 是较<strong>可靠</strong>，专为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=%E8%BF%9C%E7%A8%8B%E7%99%BB%E5%BD%95&amp;spm=1001.2101.3001.7020">远程登录</a>会话和其他网络服务提供安全性的协议。</p>
<p><strong>ftp协议</strong>通常是用来在两个服务器之间传输文件的，但是它本质上是<strong>不安全</strong>的。</p>
<p><strong>SFTP</strong>可以理解为<a target="_blank" rel="noopener" href="https://so.csdn.net/so/search?q=SSH&amp;spm=1001.2101.3001.7020">SSH</a> + FTP，也就是<strong>安全的</strong>网络文件传输协议。</p>
</blockquote>
<h3 id="Kotlin">Kotlin</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/39259622">推荐阅读</a></p>
<blockquote>
<p>Kotlin是由JetBrains开发的针对JVM、Android和浏览器的静态编程语言，目前，在Apache组织的许可下已经开源。使用Kotlin，开发者可以很方便地开发移动Android应用、服务器程序和JavaScript程序。Kotlin可以将代码编译成Java字节码，也可以编译成JavaScript，方便在没有JVM的设备上运行。</p>
<p>Kotlin 相比 Java 有哪些优势呢？</p>
<p><strong>更容易学习</strong></p>
<p>Kotlin是一门具备函数式编程思想的面向对象编程语言，它具有静态编程语言的很多特点，学习更加容易。</p>
<p><strong>更快的编译速度</strong></p>
<p>第一次编译Kotlin代码时，它需要比Java更长的时间，当使用增量编译的时候，Kotlin则比Java更快。</p>
<p><strong>性能更好</strong></p>
<p>由于非常相似的字节码结构，Kotlin应用程序的运行速度与Java类似。随着Kotlin对内联函数的支持，使用Lambda表达式的代码通常比用Java 写的代码运行得更快。</p>
<p><strong>空指针安全</strong></p>
<p>Kotlin对比于Java的最大的一个优点就是可以有效解决空指针问题，毕竟价值“十亿美元的错误”不是人人都犯的起的。</p>
<p><strong>跨平台开发特性</strong></p>
<p>Kotlin除了可以用来开发移动Android App之外，还可以用来做服务端框架开发和Web浏览器开发。</p>
<p><strong>与IDE无缝融合</strong></p>
<p>在Google官方发布的最新版本的Android Studio 3.0上，已经默认集成了Kotlin，对于一些老版本，也可以通过插件的方式来集成Kotlin。所以，使用JetBrains提供的IDE，可以为Kotlin开发提供最佳的环境支持。</p>
</blockquote>
<h3 id="LinearLayout">LinearLayout</h3>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/ui/layout/linear?hl=zh-cn">推荐阅读</a></p>
<blockquote>
<p><code>LinearLayout</code> 是一个视图组，用于使所有子视图在单个方向（垂直或水平）保持对齐。您可以使用 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/widget/LinearLayout?hl=zh-cn#attr_android:orientation"><code>android:orientation</code></a> 属性指定布局方向。</p>
<p><code>LinearLayout</code> 的所有子视图依次堆叠，因此无论子视图有多宽，垂直列表每行均只有一个子视图，水平列表将只有一行高（最高子视图的高度加上内边距）。<code>LinearLayout</code> 会考虑子视图之间的边距以及每个子视图的对齐方式（右对齐、居中对齐或左对齐）。</p>
<p><code>LinearLayout</code> 还支持使用 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/widget/LinearLayout.LayoutParams?hl=zh-cn#attr_android:layout_weight"><code>android:layout_weight</code></a> 属性为各个子视图分配权重。此属性会根据视图应在屏幕上占据的空间大小，向视图分配“重要性”值。如果拥有更大的权重值，视图便可展开，填充父视图中的任何剩余空间。子视图可指定权重值，然后系统会按照子视图所声明的权重值比例，为其分配视图组中的任何剩余空间。默认权重为零。</p>
</blockquote>
<h3 id="MainActivity">MainActivity</h3>
<blockquote>
<p>我们新建一个 Android 项目时，通过会默认生成一个 Activity，叫 MainActivity，这个 MainActivity 就是此时这个项目唯一的页面，也是 APP 的启动页面，不过你可以根据自己的需求新建其它的 Activity。</p>
</blockquote>
<h3 id="MediaRecorder">MediaRecorder</h3>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/media/mediarecorder?hl=zh-cn">推荐阅读</a></p>
<blockquote>
<p>MediaRecorder类是Android sdk提供的一个专门用于音视频录制的类，一般利用手机麦克风采集音频，摄像头采集图片信息。</p>
<p>使用以下调用初始化 <code>MediaRecorder</code> 的新实例：</p>
<ul>
<li>
<p>使用<code>setAudioSource()</code>设置音频源。您可能会使用<code>MIC</code>。</p>
<p><strong>注意</strong>：大部分音频源（包括 <code>DEFAULT</code>）都会对音频信号进行处理。要录制原始音频，请选择 <code>UNPROCESSED</code>。有些设备不支持未经处理的输入。请先调用 <code>AudioManager.getProperty(AudioManager.PROPERTY_SUPPORT_AUDIO_SOURCE_UNPROCESSED)</code> 以验证其是否可用。如果不可用，请尝试使用 <code>VOICE_RECOGNITION</code>，VOICE_RECOGNITION 不会采用 AGC 或噪音抑制。即使在不支持该属性的情况下，您也可以将 <code>UNPROCESSED</code> 用作音频源，但不能保证在这种情况下信号是否未经处理。</p>
</li>
<li>
<p>使用<code>setOutputFormat()</code>设置输出文件格式。请注意，从 Android 8.0（API 级别 26）开始<code>MediaRecorder</code></p>
<p>支持 MPEG2_TS 格式，这对流式传输非常有用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_2_TS);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>使用 <code>setOutputFile()</code> 设置输出文件名。您必须指定代表实际文件的文件描述符。</p>
</li>
<li>
<p>使用 <code>setAudioEncoder()</code> 设置音频编码器。</p>
</li>
<li>
<p>通过调用 <code>prepare()</code> 完成初始化。</p>
</li>
</ul>
<p>通过分别调用 <code>start()</code> 和 <code>stop()</code> 来启动和停止录音功能。</p>
<p>使用完 <code>MediaRecorder</code> 实例后，请尽快调用 <code>release()</code> 来释放其资源。</p>
<p><strong>注意</strong>：在搭载 Android 9（API 级别 28）或更高版本的设备上，在后台运行的应用将无法访问麦克风。因此，您的应用只在以下两种情况下才应录制音频：当其位于前台时，或者您在<a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/services?hl=zh-cn#Foreground">前台服务</a>中添加了 <code>MediaRecorder</code> 实例时。</p>
</blockquote>
<h3 id="MIPS">MIPS</h3>
<blockquote>
<p><strong>MIPS</strong>（<strong>M</strong>icroprocessor without <strong>I</strong>nterlocked <strong>P</strong>ipeline <strong>S</strong>tages），是一种采取<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E7%B2%BE%E7%AE%80%E6%8C%87%E4%BB%A4%E9%9B%86">精简指令集</a>（RISC）的<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E6%8C%87%E4%BB%A4%E9%9B%86%E6%9E%B6%E6%A7%8B">指令集架构</a>（ISA）</p>
</blockquote>
<h3 id="MQ-MessageQueue">MQ(MessageQueue)</h3>
<p><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903476711915534">推荐阅读</a></p>
<blockquote>
<p>MessageQueue ，顾名思义，意为消息队列，其操作主要有插入和读取。插入对应的方法为 enqueueMessage()，即往消息队列中插入一条消息，而读取对应next()，该方法会从消息队列中取出一条消息并将其从消息队列中删除。虽然 MessageQueue 的名字包含队列（Queue），但是其底层实现采用的是单链表，这是因为链表在插入和删除方面的性能好。</p>
<hr>
<p>Handler消息机制的工作原理：</p>
<ol>
<li>创建与线程绑定的Looper，同时会创建一个与之关联的MessageQueue用于存放消息</li>
<li>开启消息循环，从MessageQueue中获取待处理消息，若无消息会阻塞线程</li>
<li>通过Handler发送消息，此时会将Message入队列到MessageQueue中，并且唤醒等待的Looper</li>
<li>Looper获取的消息会投递给对应的Handler处理</li>
</ol>
<p>可以看到其中与MessageQueue相关的也就两个操作，一个是入队列（MessageQueue是链表结构），一个是出队列。</p>
</blockquote>
<h3 id="sendMessage">sendMessage</h3>
<blockquote>
<p>Handler 有两种方式可以向MessageQueue 发送消息，一种是post ，另外一种是sendMessage。但其实post 实际上也是通过sendMessage来发送消息的。通过handler的sendMessage方法我们可以很轻易的将数据从子线程发送到主线程</p>
</blockquote>
<h3 id="MulticastSocket">MulticastSocket</h3>
<p><a target="_blank" rel="noopener" href="https://www.apiref.com/android-zh/java/net/MulticastSocket.html">推荐阅读</a>、<a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1731101">参考文档</a></p>
<blockquote>
<p><code>MulticastSocket</code>是一个（UDP）<code>DatagramSocket</code>，具有用于连接互联网上其他多播主机的“组”的附加功能。</p>
<p>多播组由D类IP地址和标准UDP端口号指定。 D类IP地址的范围是<code>224.0.0.0</code>到<code>239.255.255.255</code> （含）。 地址<code>224.0.0.0</code>被保留，不应该被使用。</p>
<p><code>DatagramSocket</code>只允许数据报发送给指定的目标地址，而<code>MulticastSocket</code>可以将数据报以广播的方式发送至多个客户端。其主要思想是设置一组特殊网络地址作为多点广播地址，每个多点广播地址都被看做一个组，当客户端需要发送，接收广播消息时，加入到该组即可。</p>
<p>IP协议为多点广播提供了这些特殊的IP地址，这些IP地址的范围是<code>224.0.0.0</code>至<code>239.255.255.255</code>。当<code>MulticastSocket</code>把一个<code>DatagramPacket</code>发送到多点广播IP地址时，该数据将被自动广播到加入该地址的所有<code>MulticastSocket</code>，同时也可以设置该<code>MulticastSocket</code>接收自身发送的数据。</p>
<p>如果仅仅是用于发送数据报的<code>MulticastSocket</code>对象，使用默认地址，随机端口即可。但如果创建接收用的<code>MulticastSocket</code>对象，则该<code>MulticastSocket</code>对象必须指定端口，否则发送方无法确定发送数据报的目标端口。</p>
</blockquote>
<h3 id="mDNS">mDNS</h3>
<blockquote>
<p>mdns 即多播dns（Multicast DNS），mDNS主要实现了在没有传统DNS服务器的情况下使局域网内的主机实现相互发现和通信，使用的端口为5353，遵从dns协议，使用现有的DNS信息结构、名语法和资源记录类型。并且没有指定新的操作代码或响应代码。</p>
<p>在局域网中，设备和设备之前相互通信需要知道对方的ip地址的，大多数情况，设备的ip不是静态ip地址，而是通过dhcp 协议动态分配的ip 地址，如何设备发现呢，就是要mdns大显身手，例如：现在物联网设备和app之间的通信，要么app通过广播，要么通过组播，发一些特定信息，感兴趣设备应答，实现局域网设备的发现，当然mdns 比这强大的多</p>
<p>组播地址: 组播地址使用的是D类地址，地址范围为：224.0.0.0—239.255.255.255</p>
<p>mdns 工作原理简单描述：</p>
<p>mdns 使用组播地址为： 224.0.0.251 （ipv6： FF02::FB） 端口为5353，mdns 是用于局域网内部的，并且主机的域名为.local 结尾,每个进入局域网的主机，如果开启了mDNS服务的话，都会向局域网内的所有主机组播一个消息，我是谁（域名），和我的IP地址是多少。然后其他有mdns服务的主机就会响应，也会告诉你，它是谁（域名），它的IP地址是多少。 当然设备需要服务时，就是使用mdns 查询域名对对应的ip地址，对应的设备收到该报文后同样通过组播方式应答，此时其他主机设备也是可以收到该应答报文，其他主机也会记录域名和ip 以及ttl 等，更新缓存<br>
————————————————<br>
版权声明：本文为CSDN博主「人生为棋我愿为卒行动虽慢未曾后退」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>
原文链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/wang112031/article/details/52772380">https://blog.csdn.net/wang112031/article/details/52772380</a></p>
</blockquote>
<h3 id="NDK">NDK</h3>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/ndk/guides/concepts?hl=zh-cn">推荐阅读</a></p>
<blockquote>
<p>Android NDK 是一组使您能将 C 或 C++（“原生代码”）嵌入到 Android 应用中的工具。能够在 Android 应用中使用原生代码对于想执行以下一项或多项操作的开发者特别有用：</p>
<ul>
<li>在平台之间移植其应用。</li>
<li>重复使用现有库，或者提供其自己的库供重复使用。</li>
<li>在特定情况下提高性能，特别是像游戏这种计算密集型应用。</li>
</ul>
</blockquote>
<blockquote>
<p><strong>NDK是什么</strong></p>
<ul>
<li>
<p>NDK是一系列工具的集合。</p>
<ul>
<li>NDK提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk。这些工具对开发者的帮助是巨大的。</li>
<li>NDK集成了交叉编译器，并提供了相应的mk文件隔离CPU、平台、ABI等差异，开发人员只需要简单修改mk文件（指出“哪些文件需要编译”、“编译特性要求”等），就可以创建出so。</li>
<li>NDK可以自动地将so和Java应用一起打包，极大地减轻了开发人员的打包工作。</li>
</ul>
</li>
<li>
<p>NDK提供了一份稳定、功能有限的API头文件声明。</p>
<ul>
<li>Google明确声明该API是稳定的，在后续所有版本中都稳定支持当前发布的API。从该版本的NDK中看出，这些API支持的功能非常有限，包含有：C标准库（libc）、标准数学库（libm）、压缩库（libz）、Log库（liblog）。</li>
</ul>
</li>
</ul>
<p>引自 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/leaven/archive/2010/05/27/1744855.html">https://www.cnblogs.com/leaven/archive/2010/05/27/1744855.html</a></p>
</blockquote>
<h3 id="onCreate">onCreate</h3>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/components/activities/activity-lifecycle?hl=zh-cn">推荐阅读</a></p>
<blockquote>
<h4 id="onCreate-2">onCreate()</h4>
<p>您必须实现此回调，<strong>它会在系统首次创建 Activity 时触发</strong>。Activity 会在创建后进入“已创建”状态。在 <code>onCreate()</code> 方法中，您需执行基本应用启动逻辑，该逻辑在 Activity 的整个生命周期中只应发生一次。例如，<a target="_blank" rel="noopener" href="https://developer.android.com/reference/android/app/Activity?hl=zh-cn#onCreate(android.os.Bundle)"><code>onCreate()</code></a> 的实现可能会将数据绑定到列表，将 Activity 与 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/ViewModel?hl=zh-cn"><code>ViewModel</code></a> 相关联，并实例化某些类作用域变量。此方法会接收 <code>savedInstanceState</code> 参数，后者是包含 Activity 先前保存状态的 <code>Bundle</code> 对象。如果 Activity 此前未曾存在，<code>Bundle</code> 对象的值为 null。</p>
<p>如果您有一个生命周期感知型组件与您的 Activity 生命周期相关联，该组件将收到 <a target="_blank" rel="noopener" href="https://developer.android.com/reference/androidx/lifecycle/Lifecycle.Event?hl=zh-cn#ON_CREATE"><code>ON_CREATE</code></a> 事件。系统将调用带有 @OnLifecycleEvent 注释的方法，以使您的生命周期感知型组件可以执行已创建状态所需的任何设置代码。</p>
<p><code>onCreate()</code> 方法的以下示例显示执行 Activity 某些基本设置的一些代码，例如声明界面（在 XML 布局文件中定义）、定义成员变量，以及配置某些界面。在本示例中，系统通过将文件的资源 ID <code>R.layout.main_activity</code> 传递给 <code>setContentView()</code> 来指定 XML 布局文件。</p>
<p>除了定义 XML 文件，然后将其传递给 <code>setContentView()</code>，您还可以在 Activity 代码中新建 <code>View</code> 对象，并将新建的 <code>View</code> 插入到 <code>ViewGroup</code> 中，以构建视图层次结构。然后，将根 <code>ViewGroup</code> 传递给 <code>setContentView()</code> 以使用该布局。如需详细了解如何创建界面，请参阅<a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/ui?hl=zh-cn">界面</a>文档。</p>
<p>您的 Activity 并未处于“已创建”状态。<code>onCreate()</code> 方法完成执行后，Activity 进入“已开始”状态，系统会相继调用 <code>onStart()</code> 和 <code>onResume()</code> 方法</p>
</blockquote>
<h3 id="opencv">opencv</h3>
<blockquote>
<p>OpenCV的全称是：Open Source Computer Vision Library</p>
<p>OpenCV是Intel开源计算机视觉库。它由一系列 C 函数和少量 C++ 类构成，实现了图像处理和计算机视觉方面的很多通用算法。</p>
<p><strong>优点：</strong></p>
<p>1、 OpenCV 对非商业应用和商业应用都是免费的；</p>
<p>2、 开源的；</p>
<p>3、 可以应用于工程实践中；</p>
<p><strong>缺点：</strong></p>
<p>相对于Matlab而言，OpenCV基于C语言开发，编程复杂，开发周期较长。</p>
<p>可以看出，OpenCV的优缺点正好与Matlab的优缺点相反，两者各有所长，根据不同的要求选择不同的编程环境。</p>
</blockquote>
<h3 id="P2P">P2P</h3>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/connectivity/wifip2p?hl=zh-cn">推荐阅读</a></p>
<blockquote>
<p>Wi-Fi peer-to-peer（P2P，对等网络），它同意具备对应硬件的Android 4.0（API level 14）或者更高版本号的设备能够直接通过wifi而不须要其他中间中转节点就能直接通信（Android的Wi-Fi P2P框架符合Wi-Fi联盟的Wi-Fi Direct™直连认证标志）。使用这些API。你能够搜索并连接其他相同支持Wi-Fi P2P的设备，然后再通过一个快速的连接进行互相通信，而且这个连接的有效距离要比蓝牙连接的有效距离要长的多。</p>
<p>这对于须要在用户之间共享数据的应用程序很实用，比如多玩家游戏或者照片分享之类应用。</p>
<p>Android的WLAN P2P API 包含以下主要部分：</p>
<ul>
<li>支持您发现、请求，以及连接到对等设备的方法（在 <code>WifiP2pManager</code> 类中定义）。</li>
<li>支持您获知 <code>WifiP2pManager</code> 方法调用成功与否的侦听器。调用 <code>WifiP2pManager</code> 方法时，每个方法均可收到作为参数传入的特定侦听器。</li>
<li>通知您 WLAN P2P 框架检测到的特定事件（例如连接断开或新发现对等设备）的 Intent。</li>
</ul>
</blockquote>
<h3 id="Sensor-etc">Sensor-etc</h3>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/sensors/sensors_overview?hl=zh-cn">推荐阅读：官网</a>、<a target="_blank" rel="noopener" href="https://www.twle.cn/l/yufei/android/android-basic-sensor.html">推荐博客</a></p>
<blockquote>
<p>手机上搭载的基本都是物理传感器</p>
<ul>
<li><strong>方向传感器 (Orientation sensor)</strong></li>
<li><strong>加速感应器（Accelerometer sensor）</strong></li>
<li><strong>陀螺仪传感器 (Gyroscope sensor)</strong></li>
<li><strong>磁场传感器 (Magnetic field sensor)</strong></li>
<li><strong>距离传感器 (Proximity sensor)</strong></li>
<li><strong>光线传感器 (Light sensor)</strong></li>
<li><strong>气压传感器 (Pressure sensor)</strong></li>
<li><strong>温度传感器 (Temperature sensor）</strong></li>
<li><strong>重力感应器 (Gravity sensor）</strong></li>
<li><strong>线性加速感应器 (Linear acceleration sensor）</strong></li>
<li><strong>旋转矢量传感器 (Rotation vector sensor）</strong></li>
<li><strong>相对湿度传感器 (Relative humidity sensor）</strong></li>
<li><strong>近场通信 (NFC) 传感，NFC 和其它不一样，具有读写功能</strong></li>
</ul>
</blockquote>
<h3 id="Smali">Smali</h3>
<blockquote>
<p><strong>Smali是Android虚拟机的反汇编语言。</strong><br>
我们都知道，Android代码一般是用java编写的，执行java程序一般需要用到java虚拟机，在Android平台上也不例外，但是出于性能上的考虑，并没有使用标准的JVM，而是使用专门的Android虚拟机（5.0以下为Dalvik，5.0以上为ART）。Android虚拟机的可执行文件并不是普通的class文件，而是再重新整合打包后生成的dex文件。dex文件反编译之后就是Smali代码，所以说，Smali语言是Android虚拟机的反汇编语言。</p>
<h4 id="掌握Smali有哪些好处">掌握Smali有哪些好处</h4>
<p>1、动态调试APK，通常静态分析APK是不够的，如果需要彻底分析APK的执行逻辑，需要通过动态调试来进行。<br>
具体教程参考：<a target="_blank" rel="noopener" href="https://link.jianshu.com?t=http%3A%2F%2Fblog.csdn.net%2Fhanchaohao2012%2Farticle%2Fdetails%2F63253725">http://blog.csdn.net/hanchaohao2012/article/details/63253725</a><br>
2、修改APK运行逻辑，通过修改Smali代码，再重新编译打包成新的APK，是Android逆向的基本操作。</p>
<p>作者：李全栋<br>
链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/9931a1e77066">https://www.jianshu.com/p/9931a1e77066</a><br>
来源：简书<br>
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>
<h3 id="socat">socat</h3>
<p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s?__biz=MzI3MTI2NzkxMA==&amp;mid=2247485897&amp;idx=1&amp;sn=555846ff170ac7799dde353271c06f98&amp;chksm=eac528e0ddb2a1f674ca4f9e99325fbccf26589a76b43594558eeb83ef5f65b64f84a116974c&amp;scene=178&amp;cur_album_id=1342632926051205120#rd">推荐阅读</a></p>
<blockquote>
<p>Socat 是 Linux 下的一个多功能的网络工具，名字来由是 「Socket CAT」。其功能与有瑞士军刀之称的 Netcat 类似，可以看做是 Netcat 的加强版。</p>
<p>Socat 的主要特点就是在两个数据流之间建立通道，且支持众多协议和链接方式。如 IP、TCP、 UDP、IPv6、PIPE、EXEC、System、Open、Proxy、Openssl、Socket等。</p>
</blockquote>
<h3 id="socket-api">socket api</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/159453129">推荐阅读</a></p>
<h3 id="Swift">Swift</h3>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/cn/swift/">推荐阅读</a></p>
<blockquote>
<p>Swift 是一种强大直观的编程语言，适用于 macOS、iOS、watchOS 和 Apple tvOS 等。</p>
</blockquote>
<h3 id="TextView">TextView</h3>
<blockquote>
<p><code>TextView</code>(文本框)，是<code>Android</code>中用于显示文本的一个控件。</p>
<h4 id="常用属性详解">常用属性详解</h4>
<ul>
<li><code>id</code>：为<code>TextView</code>设置一个组件id，根据id，我们可以在Java代码中通过<code>findViewById()</code>的方法获取到该对象，然后进行相关属性的设置。</li>
<li><code>layout_width</code>：控件的宽度，可以写成<code>wrap_content</code>或<code>match_parent</code>，前者是宽度自适应（控件中显示的内容多大，控件就多大），而后者宽度会填满该控件所在的父容器；也可以设置成特定的大小，如上200dp。</li>
<li><code>layout_height</code>：组件的宽度，内容同上。</li>
<li><code>gravity</code>：设置控件中内容的位置，如上<code>center</code>表示居中。</li>
<li><code>text</code>：设置显示的文本内容，一般我们是把字符串写到<code>string.xml</code>文件中，然后通过<code>@String/xxx</code>取得对应的字符串内容的，可避免图上黄色警告。</li>
<li><code>textColor</code>：设置字体颜色，同上，也需通过<code>colors.xml</code>资源来引用。</li>
<li><code>textStyle</code>：设置字体风格，三个可选值：<code>normal</code>(无效果)，<code>bold</code>(加粗)，<code>italic</code>(斜体)。</li>
<li><code>textSize</code>：字体大小，单位用<code>sp</code>。</li>
<li><code>backgroud</code>：控件的背景颜色，填充整个控件，也可以是图片或者<code>drawable</code>资源文件。</li>
</ul>
</blockquote>
<h3 id="Toast">Toast</h3>
<p><a target="_blank" rel="noopener" href="https://developer.android.com/guide/topics/ui/notifiers/toasts?hl=zh-cn">推荐阅读</a></p>
<blockquote>
<p>Android中的Toast是一种简易的消息提示框。</p>
<p>当视图显示给用户，在应用程序中显示为浮动。和Dialog不一样的是，它永远不会获得焦点，无法被点击。用户将可能是在中间键入别的东西。Toast类的思想就是尽可能不引人注意，同时还向用户显示信息，希望他们看到。而且Toast显示的时间有限，Toast会根据用户设置的显示时间后自动消失。</p>
</blockquote>
<h3 id="TYPE-GYROSCOPE">TYPE_GYROSCOPE</h3>
<p>陀螺仪传感器</p>
<blockquote>
<ol>
<li>
<p>TYPE_ACCELEROMETER：加速度传感器，单位是m/s²，测量应用于设备X、Y、Z轴上的加速度，又叫做G-sensor</p>
</li>
<li>
<p>TYPE_AMBIENT_TEMPERATURE：温度传感器，单位是℃，测量返回当前的温度。</p>
</li>
<li>
<p>TYPE_GRAVITY：重力传感器，单位是m/s²，测量应用于设备X、Y、Z轴上的重力，也叫GV-sensor，地球上的数值是9.8m/s²，也可以设置其他星球(呃，目测平时用不到吧)</p>
</li>
<li>
<p>TYPE_GYROSCOPE：陀螺仪传感器，单位是rad/s，测量设备x、y、z三轴的角加速度数据。</p>
</li>
<li>
<p>TYPE_LIGHT：光线感应传感器，单位lx，检测周围的光线强度，手机系统中主要是调节LCD亮度。</p>
</li>
<li>
<p>TYPE_LINEAR_ACCELERATION：线性加速度传感器，单位是m/s²，该传感器是获取加速度传感器去除重力的影响得到的数据。</p>
</li>
<li>
<p>TYPE_MAGNETIC_FIELD：磁力传感器，单位是uT(微特斯拉)，测量设备周围三个物理轴（x，y，z）的磁场(个人不了解哪些App上有应用)。</p>
</li>
<li>
<p>TYPE_ORIENTATION:方向传感器,测量设备围绕三个物理轴（x，y，z）的旋转角度,API显示使用 SensorManager.getOrientation()替代掉了。</p>
</li>
<li>
<p>TYPE_PRESSURE：压力传感器，单位是hPa(百帕斯卡)，返回当前环境下的压强。</p>
</li>
<li>
<p>TYPE_PROXIMITY：距离传感器，单位是cm，用来测量某个对象到屏幕的距离，可用于打电话时判断人耳到电话屏幕距离来进行关闭屏幕的省电功能。</p>
</li>
<li>
<p>TYPE_RELATIVE_HUMIDITY：湿度传感器，单位是%，来测量周围环境的相对湿度(估计很少设备有吧)。</p>
</li>
<li>
<p>TYPE_ROTATION_VECTOR：旋转矢量传感器，旋转矢量代表设备的方向，是一个将坐标轴和角度混合计算得到的数据(具体咋用不了解)。</p>
</li>
<li>
<p>TYPE_TEMPERATURE:温度传感器,新版本中被TYPE_AMBIENT_TEMPERATURE替换掉了。</p>
</li>
</ol>
</blockquote>
<h3 id="UITextView">UITextView</h3>
<blockquote>
<p>UITextView 是 iOS 中的文本输入、显示控件。与 UITextField 不同的是，UITextView 是多行的文本域，支持滚动，多用于显示长篇内容。而 UITextField 是文本框，多用于输入用户名、密码等。</p>
<p>值得一提的是，UITextView 是 UIScrollView 的子类，具有滚动视图的行为和属性。</p>
<p><strong>如果要在 UITextView 中输入文字，需要先设置 editable 为 true ，然后再将 textView 设置为第一响应者。</strong></p>
</blockquote>
<h3 id="NAT">NAT</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/140067897">推荐阅读：什么是NAT？</a>、<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/31332694">NAT转换是怎么工作的？</a></p>
<blockquote>
<p>引自推荐阅读。</p>
<h4 id="NAT简介：">NAT简介：</h4>
<blockquote>
<p>NAT（Network Address Translation，网络地址转换）是1994年提出的。当在专用网内部的一些主机本来已经分配到了本地IP地址（即仅在本专用网内使用的专用地址），但现在又想和因特网上的主机通信（并不需要加密）时，可使用NAT方法。<br>
这种方法需要在专用网连接到因特网的路由器上安装NAT软件。装有NAT软件的路由器叫做NAT路由器，它至少有一个有效的外部全球IP地址。这样，所有使用本地地址的主机在和外界通信时，都要在NAT路由器上将其本地地址转换成全球IP地址，才能和因特网连接。<br>
另外，这种通过使用少量的公有IP 地址代表较多的私有IP 地址的方式，将有助于减缓可用的IP地址空间的枯竭。在RFC中有对NAT的说明。<br>
​ ------来源于百度百科</p>
</blockquote>
<h4 id="NAT的功能：">NAT的功能：</h4>
<blockquote>
<p>NAT不仅能解决IP地址不足的问题，而且还能够有效地避免来自网络外部的攻击，隐藏并保护网络内部的计算机。<br>
1.宽带分享：这是 NAT 主机的最大功能。<br>
2.安全防护: NAT 之内的 PC 联机到 Internet 上面时，他所显示的 IP 是 NAT 主机的公共 IP，所以 Client 端的 PC 当然就具有一定程度的安全了，外界在进行 portscan（端口扫描） 的时候，就侦测不到源Client 端的 PC 。<br>
​ -------来源于百度百科</p>
</blockquote>
<h4 id="NAT的实现方式：">NAT的实现方式：</h4>
<blockquote>
<p>NAT的实现方式有三种，即静态转换Static Nat、动态转换Dynamic Nat和端口多路复用OverLoad。</p>
</blockquote>
<h4 id="NAT的优点：">NAT的优点：</h4>
<ol>
<li>节省合法的公有ip地址</li>
<li>地址重叠时，提供 解决办法</li>
<li>网络发生变化时，避免重新编址</li>
</ol>
<p><strong>NAT对我们来说最大的贡献就是帮助我们节省了大量的ip资源</strong></p>
<h4 id="NAT的缺点：">NAT的缺点：</h4>
<ol>
<li>无法进行端到端的ip跟踪（破坏了端对端通信的平等性）</li>
<li>很多应用层协议无法识别（比如ftp协议 ）</li>
</ol>
</blockquote>
<h3 id="UPnP">UPnP</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/40407669">推荐阅读：P2P 网络核心技术：UPnP 和 SSDP 协议</a></p>
<blockquote>
<h4 id="背景知识">背景知识</h4>
<p>UPnP， Universal Plug and Play，中文是 “通用即插即用”。在理解 UPnP 之前，我们先了解一下传统的 PnP 技术，因为 UPnP 是对于传统 PnP（即插即用）概念的扩展。</p>
<p>传统的 PnP <strong>“即插即用”<strong>是指 PC 电脑在添加硬件设备时可以自动处理的一种标准。在 PnP 技术出现以前，当需要为 PC 电脑安装新的硬件（比如：声卡，CD-ROM，打印机）时，这些设备需要用到 PC 电脑的 DMA 和 IRQ 等资源，为了避免硬件设备对计算机这些资源使用上的冲突，我们就需要</strong>手工为新添加的硬件设备设置中断和 I/O 端口</strong>（比如，想要为添加的声卡占用中断 5，就找一个小跳线在卡上标着中断 5的针脚上一插）。这样的操作需要用户了解中断和 I/O 端口的知识，并且能够自己分配中断地址而不发生冲突，对普通用户提出这样的要求是不切实际的。</p>
<p>PnP “即插即用”技术出现以后，可以<strong>自动为新添加的硬件分配中断和 I/O 端口，用户无须再做手工跳线，也不必使用软件配置程序</strong>。唯一的要求就是操作系统需要支持 PnP 标准，同时所安装的新硬件也符合 PnP 规范的。</p>
<h4 id="UPnP-协议介绍">UPnP 协议介绍</h4>
<p>现在我们讲 UPnP，在网络世界里，**当一个主机加入网络时，其行为模式跟我们上述的添加和删除设备是类似的。**尤其是在私有网络和公网交互的时候，私有网络中的主机使用的是内网 IP 地址，是无法被外网的主机直接访问的。必须借助 NAT 网关设备（本地路由器）把内网地址映射到网关的公网地址上。</p>
<p>简单来说就是， NAT 网关设备拥有一个公网 IP 地址（比如 10.59.116.19），内网中的主机（比如 192.168.1.101）想要与外界通信的话，NAT 网关设备可以为其做一个端口映射（比如：180.59.116.19 :80 —&gt; 192.168.1.101 :80），这样，外部的主机发往 NAT 网关的数据包都会被转发给内网的该主机，从而实现了内网中的主机与外部主机的通信。</p>
<p>当内网中的主机想要被外界主机直接访问（比如开放 80 端口，对外提供 HTTP 服务），我们就需要在 NAT 设备中为当前主机手工配置端口映射，如果内网中有多台主机都想要被外界主机直接访问的话，我们必须在同一个 NAT 设备上为这些主机分别做端口映射，它们之间不能使用有冲突的端口。这个过程需要用户手工一一配置，显然给用户带来了很大的麻烦。</p>
<p>UPnP 技术标准的出现就是为了解决这个问题，只要 NAT 设备（路由器）支持 UPnP，并开启。那么，当我们的主机（或主机上的应用程序）向 NAT 设备发出端口映射请求的时候，<strong>NAT 设备就可以自动为主机分配端口并进行端口映射</strong>。这样，我们的主机就能够像公网主机一样被网络中任何主机访问了。</p>
</blockquote>
<h3 id="VNC">VNC</h3>
<p><a target="_blank" rel="noopener" href="https://www.wangan.com/wenda/2146">来源</a></p>
<blockquote>
<p>VNC (Virtual Network Console) 是虚拟网络控制台的缩写。它是一款优秀的远程控制工具软件，由著名的 AT&amp;T 的欧洲研究实验室开发的。VNC 是在基于 UNIX 和 Linux 操作系统的免费的开源软件，远程控制能力强大，高效实用，其性能可以和 Windows 和 MAC 中的任何远程控制软件媲美。 在 Linux 中，VNC 包括以下四个命令：vncserver，vncviewer，vncpasswd，和 vncconnect。大多数情况下用户只需要其中的两个命令：vncserver 和 vncviewer。</p>
<p><strong>组成部分</strong></p>
<p>VNC 基本上是由两部分组成：一部分是客户端登录界面的应用程序 (vncviewer) ；另外一部分是服务器端的应用程序 (vncserver)。VNC 的基本运行原理和一些 Windows 下的远程控制软件很相像。VNC 的服务器端应用程序在 UNIX 和 Linux 操作系统中适应性很强，图形用户界面十分友好，看上去和 Windows 下的软件界面也很类似。在任何安装了客户端的应用程序 (vncviewer) 的 Linux 平台的计算机都能十分方便地和安装了服务器端的应用程序 (vncserver) 的计算机相互连接。另外，服务器端 (vncserver) 还内建了 Java Web 接口，这样用户通过服务器端对其他计算机的操作就能通过 Netscape 显示出来了，这样的操作过程和显示方式比较直观方便。</p>
<p><strong>特点</strong></p>
<p>同样可能远程连入 UNIX、Linux 进行图形化操作的还有流行的 Xmanager，VNC 与之相比 —— 两者工作原理不一样，前者（VNC）是远程连入操作系统，所有操作在 UNIX、Linux 主机服务端进行，即使操作过程中 “本地电脑与操作主机网络断开”，也不影响操作的顺利进行；而后者（Xmanager）是通过端口将主机服务器的 UI 界面引导到本地电脑进行展现，如操作过程出现 “本地电脑与操作主机网络断开”，操作将中断失败！如果操作中进行的工作任务非常重要，不能中断，如 ORACLE RAC 实施，结果是灾难性的！更重要的是，VNC 是免费的、开源的，Xmanager 你可能用的是注册版的。</p>
</blockquote>
<h3 id="WebView">WebView</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/142800148">推荐阅读</a>，以下全部来自这篇文章。</p>
<blockquote>
<p><strong>Webview 是一个基于webkit的引擎，可以解析DOM 元素，展示html页面的控件，它和浏览器展示页面的原理是相同的，所以可以把它当做浏览器看待。</strong>（chrome浏览器也是基于webkit引擎开发的，Mozilla浏览器是基于Gecko引擎开发的）</p>
<h4 id="webview主要用于什么地方？或者说什么需求下会使用到webview"><strong>webview主要用于什么地方？或者说什么需求下会使用到webview?</strong></h4>
<p>个人理解，电脑上展示html页面，通过浏览器打开页面即可浏览，而手机系统层面，如果没有webview支持，是无法展示html页面，所以webview的作用即用于手机系统来展示html界面的</p>
<p>所以它主要在需要在手机系统上加载html文件时被需要</p>
<h4 id="一个原生应用调用html页面的过程？"><strong>一个原生应用调用html页面的过程？</strong></h4>
<p>1.原生应用加载html页面（加载页面的方式可能有多种，比如加载本地写好的html文件，或者放置在服务器的文件）</p>
<p>2.加载完成，展示就是通过webview来渲染展示的，如果系统没有webview，则是无法渲染展示html的</p>
<p>2步其实一个原生应用调用html页面过程已经完成了，那么页面不光展示，有时候可能还需要交互，这里的话就需要写一些方法了，比如html界面的按钮需要调用系统原生的东西（比如：拍照，系统的文件，相册之类的）。原生端就负责维护html调用的接口，然后按照需要返回（原生端充当一个server的角色，html充当一个client角色）</p>
<h4 id="使用webview的好处？"><strong>使用webview的好处？</strong></h4>
<p>原生APP是将页面的布局设计，以及业务代码打包然后用户下载安装使用，而webview是通过加载html文件来进行页面的展示，当需要更新页面布局的或者业务逻辑变更时，如果是原生的APP就需要修改前端内容，升级打包，重新发布才可以使用最新的。</p>
<p>而通过webview方式的页面则只需要修改html代码或者js文件（如果是从服务器端获取，只要新的文件部署完成），用户重新刷新就可以使用更新后的，无需通过下载安装的方式完成升级。</p>
</blockquote>
<h3 id="wget">wget</h3>
<p><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-hans/Wget">推荐阅读</a></p>
<blockquote>
<p><strong>GNU Wget</strong>（常简称为<strong>Wget</strong>）是一个在网络上进行下载的简单而强大的<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%87%AA%E7%94%B1%E8%BD%AF%E4%BB%B6">自由软件</a>，其本身也是<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/GNU%E8%A8%88%E5%8A%83">GNU计划</a>的一部分。它的名字是“<strong><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E8%B3%87%E8%A8%8A%E7%B6%B2">World Wide Web</a></strong>”和“<strong>Get</strong>”的结合，同时也隐含了软件的主要功能。目前它支持通过<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/HTTP">HTTP</a>、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/HTTPS">HTTPS</a>，以及<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E6%96%87%E4%BB%B6%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE">FTP</a>这三个最常见的<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/TCP/IP%E5%8D%8F%E8%AE%AE">TCP/IP协议</a>协议下载。</p>
<p>它的主要特点包括：</p>
<ul>
<li>支持递归下载</li>
<li>恰当的转换页面中的链接</li>
<li>生成可在本地浏览的页面镜像</li>
<li>支持代理服务器</li>
</ul>
</blockquote>
<h3 id="WIFIDirect">WIFIDirect</h3>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/300975829">推荐阅读</a></p>
<blockquote>
<p>2010年10月，Wi-Fi Alliance（wi-fi联盟）发布Wi-Fi Direct白皮书，白皮书中介绍了有关于这种技术的基本信息、这种技术的特点和这种技术的功能，</p>
<p>Wi-Fi Direct标准是指允许无线网络中的设备无需通过无线路由器即可相互连接。与蓝牙技术类似，这种标准允许无线设备以点对点形式互连，而且在传输速度与传输距离方面则比蓝牙有大幅提升。</p>
<h4 id="WIFI-Direct有什么好处？（特点）">WIFI Direct有什么好处？（特点）</h4>
<p>1、无线网络中的设备无需通过无线路由器即可相互连接；</p>
<p>2、以支持一对一直连，也可以实现多台设备同时连接；</p>
<p>3、支持所有的Wi-Fi设备，从11a/b/g至11n，不同标准的Wi-Fi设备之间也可以直接互联；</p>
<p>4、移动性与便携性：Wi-Fi Direct设备能够随时随地实现互相连接。由于不需要Wi-Fi路由器或接入点，因此<strong>Wi-Fi</strong>设备可以在任何地点实现连接。</p>
<p>5、即时可用性：用户将得以利用带回家的第一部Wi-Fi Direct认证设备建立直接连接。例如，一部新购买的Wi-Fi Direct笔记本可以与用户已有的传统Wi-Fi设备创建直接连接。</p>
<p>6、易用性：Wi-Fi Direct设备发现（Device Discovery）与服务发现（Service Discovery）功能帮助用户确定可用的设备与服务，然后建立连接。例如，如果用户想要打印文件，他们可以通过上述服务连接到哪个Wi-Fi网络拥有打印机。</p>
<p>7、简单而安全的连接：Wi-Fi Direct设备采用Wi-Fi Protected Setup™简化了在设备之间创建安全连接的过程。用户可以按下任一设备上的按钮，也可以输入PIN码（即设备显示的PIN码），轻松创建安全连接。</p>
</blockquote>
<h3 id="WXSS">WXSS</h3>
<p><a target="_blank" rel="noopener" href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html">推荐阅读</a></p>
<blockquote>
<p>WXSS (WeiXin Style Sheets)是一套样式语言，用于描述 WXML 的组件样式。</p>
<p>WXSS 用来决定 WXML 的组件应该怎么显示。</p>
<p>为了适应广大的前端开发者，WXSS 具有 CSS 大部分特性。同时为了更适合开发微信小程序，WXSS 对 CSS 进行了扩充以及修改。</p>
</blockquote>
<h3 id="Xcode">Xcode</h3>
<p><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/Xcode">参考</a></p>
<blockquote>
<p>Xcode是苹果的集成开发环境（IDE）。你使用Xcode来为苹果设备创建app，比如，iPad、iPhone、Apple Watch、Apple TV、Mac。在app的创建、测试、优化、发布到AppStore这整个开发流程中，Xcode提供了一套工具来方便你进行管理。</p>
<p>Xcode前身是继承自<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/NeXT">NeXT</a>的<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/w/index.php?title=Project_Builder&amp;action=edit&amp;redlink=1">Project Builder</a>。</p>
<p>The Xcode suite包含有<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/GNU_Compiler_Collection">GNU Compiler Collection</a>自由软件（GCC、LLVM（默认是后者）），并支持<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/C%E8%AA%9E%E8%A8%80">C语言</a>、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/C%2B%2B">C++</a>、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Fortran">Fortran</a>、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Objective-C">Objective-C</a>、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Objective-C%2B%2B">Objective-C++</a>、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Java">Java</a>、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/AppleScript">AppleScript</a>、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Python">Python</a>、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Ruby">Ruby</a>和<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Swift_(%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80)">Swift</a>，还提供<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Cocoa">Cocoa</a>、<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Carbon_(API)">Carbon</a>以及Java等编程模式。协力厂商更提供了<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/w/index.php?title=GNU_Pascal&amp;action=edit&amp;redlink=1">GNU Pascal</a>，[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/Xcode#cite_note-1">1]</a><a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Free_Pascal">Free Pascal</a>[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/Xcode#cite_note-2">2]</a>, <a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Ada">Ada</a>[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/Xcode#cite_note-3">3]</a>, <a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/C_Sharp">C#</a>[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/Xcode#cite_note-4">4]</a>, <a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Perl">Perl</a>[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/Xcode#cite_note-5">5]</a>, <a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/Haskell">Haskell</a>[<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/zh-sg/Xcode#cite_note-6">6]</a>和<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/D%E8%AA%9E%E8%A8%80">D语言</a>。Xcode包使用<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/GDB">GDB</a>作为其后台<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E8%AA%BF%E8%A9%A6%E5%B7%A5%E5%85%B7">调试工具</a>。</p>
<p>从Xcode 3.1开始附带iOS SDK，作为<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/IOS">iOS</a>的开发环境。</p>
</blockquote>
<h3 id="zxing">zxing</h3>
<p><a target="_blank" rel="noopener" href="https://github.com/zxing/zxing">github</a>、<a target="_blank" rel="noopener" href="https://github.com/journeyapps/zxing-android-embedded">样例github仓库</a></p>
<blockquote>
<p>Zxing是一个开放源码的，用java实现的多种格式的1D/2D条码图像处理库，它包含了联系到其他语言的接口；Zxing可以实现使用手机的内置的摄像头完成条形码和二维码的扫描与解码；Zxing可以实现条形码和二维码的编码与解码。</p>
<h4 id="基于zxing的二维码扫码可能会出现扫码速率比较低的问题。">基于zxing的二维码扫码可能会出现扫码速率比较低的问题。</h4>
<p>zxing源码是截取的扫码聚焦框里面的图像数据信息来解码，这里可以改成获取全屏的图像信息。实现代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> PlanarYUVLuminanceSource <span class="title">buildLuminanceSource</span><span class="params">(<span class="keyword">byte</span>[] data, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> PlanarYUVLuminanceSource(data, width, height, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尽量减少支持的扫码类型。zxing源码默认是支持所有的扫码类型。我们项目中使用的话，一般不需要支持这么多。仅支持<code>BarcodeFormat.QR_CODE</code>（二维码）、<code>BarcodeFormat.CODE_128</code>（一维码）就可以应对很多场景了。</p>
<p>添加 <code>hints.put(DecodeHintType.TRY_HARDER, true);</code>语句，能够提高扫码精确度，准确率。</p>
<p>以上参考 <a target="_blank" rel="noopener" href="http://www.xmamiga.com/1237/">http://www.xmamiga.com/1237/</a></p>
</blockquote>
<h3 id="北斗">北斗</h3>
<p><a target="_blank" rel="noopener" href="http://www.beidou.gov.cn/xt/xtjs/201710/t20171011_280.html">官网介绍</a></p>
<blockquote>
<p>北斗卫星导航系统（以下简称北斗系统）是中国着眼于国家安全和经济社会发展需要，自主建设运行的全球卫星导航系统，是为全球用户提供全天候、全天时、高精度的定位、导航和授时服务的国家重要时空基础设施。</p>
<p><strong>发展特色</strong></p>
<p>北斗系统具有以下特点：一是北斗系统空间段采用三种轨道卫星组成的混合星座，与其他卫星导航系统相比高轨卫星更多，抗遮挡能力强，尤其低纬度地区性能优势更为明显。二是北斗系统提供多个频点的导航信号，能够通过多频信号组合使用等方式提高服务精度。三是北斗系统创新融合了导航与通信能力，具备定位导航授时、星基增强、地基增强、精密单点定位、短报文通信和国际搜救等多种服务能力。</p>
<hr>
<p>以上引自官网，以下引自<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8C%97%E6%96%97%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F">维基百科</a></p>
<p><strong>北斗卫星导航系统</strong>（简称<strong>北斗系统</strong>）是一个<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F">卫星导航系统</a>，能为全球用户提供全天候、全天时、高精度的定位、导航和授时服务。北斗系统发展共有三代，自第二代开始的北斗系统被正式称为“北斗卫星导航系统”。</p>
<p><strong>北斗一号系统</strong>（第一代北斗系统）由三颗卫星提供区域定位服务。从2000年开始，该系统主要在中国境内提供导航服务。2012年12月，北斗一号的最后一颗卫星寿命到期，北斗卫星导航试验系统停止运作。</p>
<p><strong>北斗二号系统</strong>（第二代北斗系统）是一个包含16颗卫星的全球卫星导航系统，分别为6颗<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%9D%9C%E6%AD%A2%E8%BB%8C%E9%81%93">静止轨道</a>卫星、6颗<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%9C%B0%E7%90%83%E5%90%8C%E6%AD%A5%E8%BD%A8%E9%81%93">倾斜地球同步轨道</a>卫星、4颗<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%B0%E7%90%83%E8%BD%A8%E9%81%93">中地球轨道</a>卫星。2012年11月，第二代北斗系统开始在亚太地区为用户提供区域定位服务。</p>
<p><strong>北斗三号系统</strong>（第三代北斗系统）由三种不同轨道的卫星组成，包括24颗地球<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%B8%AD%E5%9C%B0%E7%90%83%E8%BD%A8%E9%81%93">中圆轨道</a>卫星（覆盖全球），3颗倾斜地球同步轨道卫星（覆盖亚太大部分地区）和3颗地球静止轨道卫星（覆盖中国）。北斗三号于2018年提前开放了北斗系统的全球定位功能。北斗三号系统于2020年7月31日完整开通。</p>
<p>北斗卫星导航系统（BDS）、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BE%8E%E5%9B%BD">美国</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%B5%B1">全球定位系统</a>（GPS）、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BF%84%E7%BD%97%E6%96%AF">俄罗斯</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%B4%9B%E7%BA%B3%E6%96%AF%E7%B3%BB%E7%BB%9F">全球导航卫星系统</a>（GLONASS）和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%AC%A7%E7%9B%9F">欧盟</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E4%BC%BD%E5%88%A9%E7%95%A5%E5%AE%9A%E4%BD%8D%E7%B3%BB%E7%B5%B1">伽利略定位系统</a>（Galileo）为<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%81%94%E5%90%88%E5%9B%BD">联合国</a><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%85%A8%E7%90%83%E5%8D%AB%E6%98%9F%E5%AF%BC%E8%88%AA%E7%B3%BB%E7%BB%9F%E5%9B%BD%E9%99%85%E5%A7%94%E5%91%98%E4%BC%9A">卫星导航委员会</a>认定的全球卫星导航系统四大核心供应商。</p>
</blockquote>
<h3 id="打包党">打包党</h3>
<p><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/41368839">推荐阅读</a></p>
<blockquote>
<p>“Android APP二次打包”则是盗版正规Android APP，破解后植入恶意代码重新打包。不管从性能、用户体验、外观它都跟正规APP一模一样但是背后它确悄悄运行着可怕的程序，它会在不知不觉中浪费手机电量、流量，恶意扣费、偷窥隐私等等行为。</p>
<p>二次打包问题只是Android应用安全风险中的一部分， 一般是通过反编译工具向应用中插入广告代码与相关配置，再在第三方应用市场、论坛发布。</p>
<p>对于打包党对于移动App带来的危害有以下几种：</p>
<ul>
<li>插入自己广告或者删除原来广告；</li>
<li>恶意代码, 恶意扣费、木马等；</li>
<li>修改原来支付逻辑。</li>
</ul>
<h5 id="一、混淆代码">一、混淆代码</h5>
<p>Java代码是非常容易反编译的，作为一种跨平台的、解释型语言，Java 源代码被编译成中间“字节码”存储于class文件中。由于跨平台的需要，这些字节码带有许多的语义信息，很容易被反编译成Java源代码。为了很好地保护Java源代码，开发者往往会对编译好的class文件进行混淆处理。</p>
<p>混淆就是对发布出去的程序进行重新组织和处理，使得处理后的代码与处理前代码完成相同的功能，而混淆后的代码很难被反编译，即使反编译成功也很难得出程序的真正语义。ProGuard就是一个混淆代码的开源项目，能够对字节码进行混淆、缩减体积、优化等处理。</p>
<h5 id="二、整体Dex加固">二、整体Dex加固</h5>
<p>Dex加固是对Dex文件进行加壳防护，防止被静态反编译工具破解而泄露源码，最刚开始出现的是整体加固技术方案。整体加固技术的原理包括替换application/classes.dex、解密/动态加载原classes.dex、调用原application相关方法、将原application对象/名称设置到系统内部相关变量四大环节。其中最为关键的一步就是解密/动态加载原classes.dex，通过加密编译好的最终ex源码文件，然后在一个新项目中用新项目的application启动来解密原项目代码并加载到内存中，再把当前进程替换为解密后的代码，能够很好地隐藏源码并防止直接性的反编译。</p>
<h5 id="三、拆分Dex加固">三、拆分Dex加固</h5>
<p>随着业务规模发展到一定程度，不断地加入新功能、添加新的类库，代码在急剧膨胀的同时，相应的apk包的大小也急剧增加，那么简单的整体加固方案就不能很好地满足安全需求，在整体加固方案之外又出现了拆分加固的技术方案。</p>
<p>但是Dex文件在加固时，针对中间缺失的一部分数据会以解密后的数据来替换，有的时候这种拆分替换也会导致数据不准确。那么到底应该拆分什么样的数据呢？就需要了解一下Dex文件的数据结构。</p>
<p>Dex文件结构极为复杂，以下图示选取了其中较为重要的内容。事实上，Dex文件是一个以class为核心组装起来的文件，其中最重要的是classdata和classcode两部分，有其特定的接口和指令数据，选取这两部分来拆分的话，即使拆分出来也不会泄露class数据和字节码数据，反编译出来也不完整，安全性较高。</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://ZWN2001.github.io">洛雪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwn2001.github.io/2022/05/30/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E8%AF%8D/">https://zwn2001.github.io/2022/05/30/%E7%A7%BB%E5%8A%A8%E4%BA%92%E8%81%94%E7%BD%91%E5%90%8D%E8%AF%8D/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ZWN2001.github.io" target="_blank">ZWN's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E4%B9%A0/">学习</a></div><div class="post_share"><div class="social-share" data-image="/img/cover3/15-min.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2022/05/26/%E8%AE%A9Onedrive%E4%BA%91%E7%9B%98%E5%90%8C%E6%AD%A5%E6%9C%AC%E5%9C%B0%E4%BB%BB%E6%84%8F%E4%B8%80%E4%B8%AA%E6%96%87%E4%BB%B6%E5%A4%B9%EF%BC%88%E9%80%82%E7%94%A8%E4%BA%8EWindows%EF%BC%89/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/13.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">让Onedrive云盘同步本地任意一个文件夹（适用于Windows）</div></div></a></div><div class="next-post pull-right"><a href="/2022/06/08/%E8%8B%B1%E8%AF%AD%E7%A7%91%E6%8A%80%E6%96%87%E7%8C%AE%E4%BD%9C%E4%B8%9A%E7%A8%BF/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/4-min.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">英语科技文献综述稿</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/27/%E6%9A%91%E6%9C%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BC%95%E8%AE%BA/" title="暑期机器学习引论"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/6-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-27</div><div class="title">暑期机器学习引论</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">洛雪</div><div class="author-info__description">我虽无意逐鹿，却知苍生苦楚</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">111</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">13</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZWN2001"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZWN2001" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">新域名：https://www.zwn-blog.xyz/,建议使用无痕模式以更快地得到更新，或者访问https://zwn-2001-github-io.vercel.app/,或者https://zwn2001.github.io</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">移动互联网名词</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%8D%E4%B9%A0%E9%A2%98%E7%9B%AE%E5%92%8C%E8%8C%83%E5%9B%B4"><span class="toc-number">1.1.</span> <span class="toc-text">复习题目和范围</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%AF%E8%AF%AD%E5%92%8C%E7%BA%BF%E7%B4%A2%E8%AF%8D%E6%B1%87"><span class="toc-number">1.2.</span> <span class="toc-text">术语和线索词汇</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity"><span class="toc-number">1.2.1.</span> <span class="toc-text">Activity</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Activity-%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">Activity 的概念</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#adb"><span class="toc-number">1.2.2.</span> <span class="toc-text">adb</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#adb-%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">adb 的工作原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#android-onClick"><span class="toc-number">1.2.3.</span> <span class="toc-text">android:onClick</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AnimationDrawable"><span class="toc-number">1.2.4.</span> <span class="toc-text">AnimationDrawable</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-AnimationDrawable"><span class="toc-number">1.2.4.1.</span> <span class="toc-text">使用 AnimationDrawable</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#aosp"><span class="toc-number">1.2.5.</span> <span class="toc-text">aosp</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HarmonyOS"><span class="toc-number">1.2.6.</span> <span class="toc-text">HarmonyOS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%BD%E4%BA%A7%E5%8E%82%E5%95%86%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%B7%9F%E8%BF%9B%EF%BC%9F"><span class="toc-number">1.2.6.1.</span> <span class="toc-text">国产厂商为什么不跟进？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#apk"><span class="toc-number">1.2.7.</span> <span class="toc-text">apk</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ARM"><span class="toc-number">1.2.8.</span> <span class="toc-text">ARM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#X86%E6%9E%B6%E6%9E%84"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">X86架构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ARM-%E5%92%8Cx86%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">ARM 和x86的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#RISC-V"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">RISC-V</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOT"><span class="toc-number">1.2.9.</span> <span class="toc-text">AOT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AOT%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84"><span class="toc-number">1.2.9.1.</span> <span class="toc-text">AOT是干嘛的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AOT%E7%9A%84%E7%BC%BA%E9%99%B7"><span class="toc-number">1.2.9.2.</span> <span class="toc-text">AOT的缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JIT"><span class="toc-number">1.2.10.</span> <span class="toc-text">JIT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JIT%E6%98%AF%E5%B9%B2%E5%98%9B%E7%9A%84"><span class="toc-number">1.2.10.1.</span> <span class="toc-text">JIT是干嘛的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JIT%E7%BC%BA%E9%99%B7"><span class="toc-number">1.2.10.2.</span> <span class="toc-text">JIT缺陷</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dex"><span class="toc-number">1.2.11.</span> <span class="toc-text">dex</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#dex%E5%A5%BD%E5%A4%84"><span class="toc-number">1.2.11.1.</span> <span class="toc-text">dex好处</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E8%88%AC%E7%9A%84%E5%8F%8D%E7%BC%96%E8%AF%91%E6%B5%81%E7%A8%8B%E6%98%AF%E4%BB%80%E4%B9%88%E6%A0%B7%E5%AD%90%E7%9A%84"><span class="toc-number">1.2.11.2.</span> <span class="toc-text">一般的反编译流程是什么样子的</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DVM"><span class="toc-number">1.2.12.</span> <span class="toc-text">DVM</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFDalvik"><span class="toc-number">1.2.12.1.</span> <span class="toc-text">什么是Dalvik?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Dalvik%E5%92%8CJVM%E6%9C%89%E5%95%A5%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-number">1.2.12.2.</span> <span class="toc-text">Dalvik和JVM有啥关系？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ART"><span class="toc-number">1.2.13.</span> <span class="toc-text">ART</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AVD"><span class="toc-number">1.2.14.</span> <span class="toc-text">AVD</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Camera2"><span class="toc-number">1.2.15.</span> <span class="toc-text">Camera2</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CGI"><span class="toc-number">1.2.16.</span> <span class="toc-text">CGI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LLVM"><span class="toc-number">1.2.17.</span> <span class="toc-text">LLVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clang"><span class="toc-number">1.2.18.</span> <span class="toc-text">clang</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFclang%E7%BC%96%E8%AF%91%E5%99%A8%EF%BC%9F"><span class="toc-number">1.2.18.1.</span> <span class="toc-text">什么是clang编译器？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#clang%E7%BC%96%E8%AF%91%E5%99%A8%E7%9A%84%E4%BC%98%E5%8A%BF%E4%B8%8E%E5%8A%A3%E5%8A%BF"><span class="toc-number">1.2.18.2.</span> <span class="toc-text">clang编译器的优势与劣势</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dex2jar"><span class="toc-number">1.2.19.</span> <span class="toc-text">dex2jar</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#findViewById"><span class="toc-number">1.2.20.</span> <span class="toc-text">findViewById</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Flutter"><span class="toc-number">1.2.21.</span> <span class="toc-text">Flutter</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-1-Flutter-%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.</span> <span class="toc-text">1.2.1 Flutter 简介</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%B7%A8%E5%B9%B3%E5%8F%B0%E8%87%AA%E7%BB%98%E5%BC%95%E6%93%8E"><span class="toc-number">1.3.1.</span> <span class="toc-text">1. 跨平台自绘引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E9%AB%98%E6%80%A7%E8%83%BD"><span class="toc-number">1.3.2.</span> <span class="toc-text">2. 高性能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E9%87%87%E7%94%A8Dart%E8%AF%AD%E8%A8%80%E5%BC%80%E5%8F%91"><span class="toc-number">1.3.3.</span> <span class="toc-text">3. 采用Dart语言开发</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#git"><span class="toc-number">1.3.4.</span> <span class="toc-text">git</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Git%E7%89%B9%E7%82%B9"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">Git特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPS"><span class="toc-number">1.3.5.</span> <span class="toc-text">GPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTML5"><span class="toc-number">1.3.6.</span> <span class="toc-text">HTML5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HttpURLConnection"><span class="toc-number">1.3.7.</span> <span class="toc-text">HttpURLConnection</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HUAWEI-DevEco-Studio"><span class="toc-number">1.3.8.</span> <span class="toc-text">HUAWEI DevEco Studio</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HAXM"><span class="toc-number">1.3.9.</span> <span class="toc-text">HAXM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ImageView"><span class="toc-number">1.3.10.</span> <span class="toc-text">ImageView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Intent"><span class="toc-number">1.3.11.</span> <span class="toc-text">Intent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Intent-%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.3.11.1.</span> <span class="toc-text">Intent 类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jar"><span class="toc-number">1.3.12.</span> <span class="toc-text">jar</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JAR-%E5%8C%85%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">1.3.12.1.</span> <span class="toc-text">JAR 包是什么</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JAR-%E5%8C%85%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">1.3.12.2.</span> <span class="toc-text">JAR 包的用途</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JAR-%E5%8C%85%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">1.3.12.3.</span> <span class="toc-text">JAR 包的优点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JNI"><span class="toc-number">1.3.13.</span> <span class="toc-text">JNI</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ssh-L-R-D"><span class="toc-number">1.3.14.</span> <span class="toc-text">ssh&#x2F;-L-R-D</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JSch"><span class="toc-number">1.3.15.</span> <span class="toc-text">JSch</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#SSH%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.15.1.</span> <span class="toc-text">SSH的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JSCH%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.15.2.</span> <span class="toc-text">JSCH的介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kotlin"><span class="toc-number">1.3.16.</span> <span class="toc-text">Kotlin</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LinearLayout"><span class="toc-number">1.3.17.</span> <span class="toc-text">LinearLayout</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MainActivity"><span class="toc-number">1.3.18.</span> <span class="toc-text">MainActivity</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MediaRecorder"><span class="toc-number">1.3.19.</span> <span class="toc-text">MediaRecorder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MIPS"><span class="toc-number">1.3.20.</span> <span class="toc-text">MIPS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MQ-MessageQueue"><span class="toc-number">1.3.21.</span> <span class="toc-text">MQ(MessageQueue)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#sendMessage"><span class="toc-number">1.3.22.</span> <span class="toc-text">sendMessage</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MulticastSocket"><span class="toc-number">1.3.23.</span> <span class="toc-text">MulticastSocket</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#mDNS"><span class="toc-number">1.3.24.</span> <span class="toc-text">mDNS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NDK"><span class="toc-number">1.3.25.</span> <span class="toc-text">NDK</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onCreate"><span class="toc-number">1.3.26.</span> <span class="toc-text">onCreate</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#onCreate-2"><span class="toc-number">1.3.26.1.</span> <span class="toc-text">onCreate()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#opencv"><span class="toc-number">1.3.27.</span> <span class="toc-text">opencv</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#P2P"><span class="toc-number">1.3.28.</span> <span class="toc-text">P2P</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Sensor-etc"><span class="toc-number">1.3.29.</span> <span class="toc-text">Sensor-etc</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Smali"><span class="toc-number">1.3.30.</span> <span class="toc-text">Smali</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%8C%E6%8F%A1Smali%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A5%BD%E5%A4%84"><span class="toc-number">1.3.30.1.</span> <span class="toc-text">掌握Smali有哪些好处</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socat"><span class="toc-number">1.3.31.</span> <span class="toc-text">socat</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket-api"><span class="toc-number">1.3.32.</span> <span class="toc-text">socket api</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Swift"><span class="toc-number">1.3.33.</span> <span class="toc-text">Swift</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TextView"><span class="toc-number">1.3.34.</span> <span class="toc-text">TextView</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E7%94%A8%E5%B1%9E%E6%80%A7%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.3.34.1.</span> <span class="toc-text">常用属性详解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Toast"><span class="toc-number">1.3.35.</span> <span class="toc-text">Toast</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TYPE-GYROSCOPE"><span class="toc-number">1.3.36.</span> <span class="toc-text">TYPE_GYROSCOPE</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UITextView"><span class="toc-number">1.3.37.</span> <span class="toc-text">UITextView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NAT"><span class="toc-number">1.3.38.</span> <span class="toc-text">NAT</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NAT%E7%AE%80%E4%BB%8B%EF%BC%9A"><span class="toc-number">1.3.38.1.</span> <span class="toc-text">NAT简介：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NAT%E7%9A%84%E5%8A%9F%E8%83%BD%EF%BC%9A"><span class="toc-number">1.3.38.2.</span> <span class="toc-text">NAT的功能：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NAT%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%EF%BC%9A"><span class="toc-number">1.3.38.3.</span> <span class="toc-text">NAT的实现方式：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NAT%E7%9A%84%E4%BC%98%E7%82%B9%EF%BC%9A"><span class="toc-number">1.3.38.4.</span> <span class="toc-text">NAT的优点：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NAT%E7%9A%84%E7%BC%BA%E7%82%B9%EF%BC%9A"><span class="toc-number">1.3.38.5.</span> <span class="toc-text">NAT的缺点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#UPnP"><span class="toc-number">1.3.39.</span> <span class="toc-text">UPnP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%83%8C%E6%99%AF%E7%9F%A5%E8%AF%86"><span class="toc-number">1.3.39.1.</span> <span class="toc-text">背景知识</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#UPnP-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.3.39.2.</span> <span class="toc-text">UPnP 协议介绍</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#VNC"><span class="toc-number">1.3.40.</span> <span class="toc-text">VNC</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WebView"><span class="toc-number">1.3.41.</span> <span class="toc-text">WebView</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#webview%E4%B8%BB%E8%A6%81%E7%94%A8%E4%BA%8E%E4%BB%80%E4%B9%88%E5%9C%B0%E6%96%B9%EF%BC%9F%E6%88%96%E8%80%85%E8%AF%B4%E4%BB%80%E4%B9%88%E9%9C%80%E6%B1%82%E4%B8%8B%E4%BC%9A%E4%BD%BF%E7%94%A8%E5%88%B0webview"><span class="toc-number">1.3.41.1.</span> <span class="toc-text">webview主要用于什么地方？或者说什么需求下会使用到webview?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8%E8%B0%83%E7%94%A8html%E9%A1%B5%E9%9D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.3.41.2.</span> <span class="toc-text">一个原生应用调用html页面的过程？</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8webview%E7%9A%84%E5%A5%BD%E5%A4%84%EF%BC%9F"><span class="toc-number">1.3.41.3.</span> <span class="toc-text">使用webview的好处？</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#wget"><span class="toc-number">1.3.42.</span> <span class="toc-text">wget</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WIFIDirect"><span class="toc-number">1.3.43.</span> <span class="toc-text">WIFIDirect</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#WIFI-Direct%E6%9C%89%E4%BB%80%E4%B9%88%E5%A5%BD%E5%A4%84%EF%BC%9F%EF%BC%88%E7%89%B9%E7%82%B9%EF%BC%89"><span class="toc-number">1.3.43.1.</span> <span class="toc-text">WIFI Direct有什么好处？（特点）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#WXSS"><span class="toc-number">1.3.44.</span> <span class="toc-text">WXSS</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Xcode"><span class="toc-number">1.3.45.</span> <span class="toc-text">Xcode</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zxing"><span class="toc-number">1.3.46.</span> <span class="toc-text">zxing</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E4%BA%8Ezxing%E7%9A%84%E4%BA%8C%E7%BB%B4%E7%A0%81%E6%89%AB%E7%A0%81%E5%8F%AF%E8%83%BD%E4%BC%9A%E5%87%BA%E7%8E%B0%E6%89%AB%E7%A0%81%E9%80%9F%E7%8E%87%E6%AF%94%E8%BE%83%E4%BD%8E%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82"><span class="toc-number">1.3.46.1.</span> <span class="toc-text">基于zxing的二维码扫码可能会出现扫码速率比较低的问题。</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%97%E6%96%97"><span class="toc-number">1.3.47.</span> <span class="toc-text">北斗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%8C%85%E5%85%9A"><span class="toc-number">1.3.48.</span> <span class="toc-text">打包党</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E6%B7%B7%E6%B7%86%E4%BB%A3%E7%A0%81"><span class="toc-number">1.3.48.0.1.</span> <span class="toc-text">一、混淆代码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E3%80%81%E6%95%B4%E4%BD%93Dex%E5%8A%A0%E5%9B%BA"><span class="toc-number">1.3.48.0.2.</span> <span class="toc-text">二、整体Dex加固</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E6%8B%86%E5%88%86Dex%E5%8A%A0%E5%9B%BA"><span class="toc-number">1.3.48.0.3.</span> <span class="toc-text">三、拆分Dex加固</span></a></li></ol></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/12/09/KalmanFilters-theory-and-demo/" title="KalmanFilters-theory-and-demo"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/10-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="KalmanFilters-theory-and-demo"/></a><div class="content"><a class="title" href="/2022/12/09/KalmanFilters-theory-and-demo/" title="KalmanFilters-theory-and-demo">KalmanFilters-theory-and-demo</a><time datetime="2022-12-09T02:51:09.000Z" title="发表于 2022-12-09 10:51:09">2022-12-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/12/06/How-to-use-gitbook/" title="How-to-use-gitbook"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/3-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="How-to-use-gitbook"/></a><div class="content"><a class="title" href="/2022/12/06/How-to-use-gitbook/" title="How-to-use-gitbook">How-to-use-gitbook</a><time datetime="2022-12-06T11:51:32.000Z" title="发表于 2022-12-06 19:51:32">2022-12-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/29/%E5%AE%89%E5%8D%93%E4%BB%8E%E8%BF%9B%E9%98%B6%E5%88%B0%E6%8E%98%E5%A2%93/" title="安卓从进阶到掘墓"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/22-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="安卓从进阶到掘墓"/></a><div class="content"><a class="title" href="/2022/10/29/%E5%AE%89%E5%8D%93%E4%BB%8E%E8%BF%9B%E9%98%B6%E5%88%B0%E6%8E%98%E5%A2%93/" title="安卓从进阶到掘墓">安卓从进阶到掘墓</a><time datetime="2022-10-29T13:27:37.000Z" title="发表于 2022-10-29 21:27:37">2022-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/18/%E4%BC%97%E6%99%BA%E5%AE%9E%E9%AA%8C/" title="众智实验"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/5-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="众智实验"/></a><div class="content"><a class="title" href="/2022/10/18/%E4%BC%97%E6%99%BA%E5%AE%9E%E9%AA%8C/" title="众智实验">众智实验</a><time datetime="2022-10-18T10:06:30.000Z" title="发表于 2022-10-18 18:06:30">2022-10-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/10/05/%E5%9B%BE%E8%A7%A3TCP-IP%E6%8B%BE%E9%81%97/" title="图解TCP/IP拾遗"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/33.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="图解TCP/IP拾遗"/></a><div class="content"><a class="title" href="/2022/10/05/%E5%9B%BE%E8%A7%A3TCP-IP%E6%8B%BE%E9%81%97/" title="图解TCP/IP拾遗">图解TCP/IP拾遗</a><time datetime="2022-10-05T13:53:35.000Z" title="发表于 2022-10-05 21:53:35">2022-10-05</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('/img/cover3/15-min.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By 洛雪</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">喵喵喵？</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '7MlJqmD9Ceux2bxiKqPqsMHW-gzGzoHsz',
      appKey: '3oP9XaednBAwtfMk2q28dwGP',
      avatar: 'retro',
      serverURLs: 'https://7mljqmd9.lc-cn-n1-shared.com',
      emojiMaps: "",
      path: window.location.pathname,
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="app-refresh" id="app-refresh"> <div class="app-refresh-wrap"> <label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" onclick="location.reload()">点击刷新</a> </div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"点击刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script></div></body></html>