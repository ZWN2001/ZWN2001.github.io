<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>Python进阶语法记录-OOP、IO、网络 | ZWN's blog</title><meta name="author" content="洛雪"><meta name="copyright" content="洛雪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="面向对象 类和实例 以Student类为例，在Python中，定义类是通过class关键字： 12class Student(object):    pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，可以省略。通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 定义好了Student"><meta property="og:type" content="article"><meta property="og:title" content="Python进阶语法记录-OOP、IO、网络"><meta property="og:url" content="https://zwn2001.space/posts/47dff421.html"><meta property="og:site_name" content="ZWN&#39;s blog"><meta property="og:description" content="面向对象 类和实例 以Student类为例，在Python中，定义类是通过class关键字： 12class Student(object):    pass class后面紧接着是类名，即Student，类名通常是大写开头的单词，紧接着是(object)，表示该类是从哪个类继承下来的，可以省略。通常，如果没有合适的继承类，就使用object类，这是所有类最终都会继承的类。 定义好了Student"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zwn2001.space/img/cover3/6-min.jpg"><meta property="article:published_time" content="2022-01-13T14:02:52.000Z"><meta property="article:modified_time" content="2023-08-02T05:39:47.546Z"><meta property="article:author" content="洛雪"><meta property="article:tag" content="转载与汇总"><meta property="article:tag" content="Python"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://zwn2001.space/img/cover3/6-min.jpg"><link rel="shortcut icon" href="/img/favicon.webp"><link rel="canonical" href="https://zwn2001.space/posts/47dff421.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:-1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:{limitDay:200,position:"top",messagePrev:"距离上次更新已经过去",messageNext:"天啦！注意内容可能过时。"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://unpkg.com/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://unpkg.com/flickr-justified-gallery/dist/fjGallery.css"}},isPhotoFigcaption:!0,islazyload:!0,isAnchor:!0,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"Python进阶语法记录-OOP、IO、网络",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-08-02 13:39:47"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/rightmenu.css"><link rel="stylesheet" href="/css/loadimg.css"><link rel="stylesheet" href="/css/project.css"><link type="text/html" rel="stylesheet" href="/css/wide_screen.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"><style>#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags:before{content:"\A";white-space:pre}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags>.article-meta__separator{display:none}</style><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.png"><div class="loading-image-dot"></div><div id="loading-percentage"></div></div></div><script>const loadingPercentage=document.getElementById("loading-percentage");loadingPercentage.style.color="black";let loadingPercentageTimer=setInterval(function(){var e=document.querySelector(".pace-progress");e&&(e=e.getAttribute("data-progress-text"))!==loadingPercentage.textContent&&"60%"===(loadingPercentage.textContent=e)&&clearInterval(loadingPercentageTimer)},100);const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",()=>{preloader.endLoading()})</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">130</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/cover3/6-min.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="ZWN's blog"><span class="site-name">ZWN's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Python进阶语法记录-OOP、IO、网络</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-01-13T14:02:52.000Z" title="发表于 2022-01-13 22:02:52">2022-01-13</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-02T05:39:47.546Z" title="更新于 2023-08-02 13:39:47">2023-08-02</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E7%BC%96%E7%A8%8B%E7%9F%A5%E8%AF%86/">编程知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">16.4k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>59分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>面向对象</h1><h2 id="类和实例">类和实例</h2><p>以Student类为例，在Python中，定义类是通过<code>class</code>关键字：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><code>class</code>后面紧接着是类名，即<code>Student</code>，类名通常是大写开头的单词，紧接着是<code>(object)</code>，<strong>表示该类是从哪个类继承下来的，可以省略</strong>。通常，如果没有合适的继承类，就使用<code>object</code>类，这是所有类最终都会继承的类。</p><p>定义好了<code>Student</code>类，就可以根据<code>Student</code>类创建出<code>Student</code>的实例，<strong>创建实例是通过类名+()实现的</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart</span><br><span class="line">&lt;__main__.Student <span class="built_in">object</span> at <span class="number">0x10a67a590</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Student</span><br><span class="line">&lt;<span class="keyword">class</span> <span class="string">&#x27;__main__.Student&#x27;</span>&gt;</span><br></pre></td></tr></table></figure><p>可以看到，变量<code>bart</code>指向的就是一个<code>Student</code>的实例，后面的<code>0x10a67a590</code>是内存地址，每个object的地址都不一样，而<code>Student</code>本身则是一个类。</p><p>可以使用点号 <strong>.</strong> 来访问对象的属性，同时可以自由地给一个实例变量绑定属性，比如，给实例<code>bart</code>绑定一个<code>name</code>属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name = <span class="string">&#x27;Bart Simpson&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name</span><br><span class="line"><span class="string">&#x27;Bart Simpson&#x27;</span></span><br></pre></td></tr></table></figure><p>由于类可以起到模板的作用，因此，可以在创建实例的时候，把一些我们认为必须绑定的属性强制填写进去。通过定义一个特殊的<code>__init__</code>方法，在创建实例的时候，就把<code>name</code>，<code>score</code>等属性绑上去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br></pre></td></tr></table></figure><p><strong>注意到<code>__init__</code>方法的第一个参数永远是<code>self</code>，表示创建的实例本身</strong>，因此，在<code>__init__</code>方法内部，就可以把各种属性绑定到<code>self</code>，因为<code>self</code><strong>就指向创建的实例本身</strong>。</p><p>有了<code>__init__</code>方法，在创建实例的时候，就不能传入空的参数了，必须传入与<code>__init__</code>方法匹配的参数，但<code>self</code><strong>不需要传</strong>，Python解释器自己会把实例变量传进去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.name</span><br><span class="line"><span class="string">&#x27;Bart Simpson&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.score</span><br><span class="line"><span class="number">59</span></span><br></pre></td></tr></table></figure><p>和普通的函数相比，在类中定义的函数只有一点不同，就是第一个参数永远是实例变量<code>self</code>，并且，调用时，不用传递该参数。除此之外，类的方法和普通函数没有什么区别，所以，你仍然可以用默认参数、可变参数、关键字参数和命名关键字参数。</p><p> </p><h3 id="self代表类的实例，而非类">self代表类的实例，而非类</h3><p>类的方法与普通的函数只有一个特别的区别——它们必须有一个额外的<strong>第一个参数名称</strong>, 按照惯例它的名称是 self。</p><p>从执行结果可以很明显的看出，self 代表的是类的实例，代表当前对象的地址，而 <code>self.__class__</code>则指向类。</p><p>self 不是 python 关键字，我们把他换成 runoop 也是可以正常执行的。</p><p> </p><h3 id="类属性与方法">类属性与方法</h3><h4 id="类的私有属性">类的私有属性</h4><p><code>__private_attrs</code>：两个下划线开头，声明该属性为私有，不能在类的外部被使用或直接访问。在类内部的方法中使用时 <strong>self.__private_attrs</strong>。</p><h4 id="类的私有方法">类的私有方法</h4><p><code>__private_method</code>：两个下划线开头，声明该方法为私有方法，不能在类的外部调用。在类的内部调用 <strong>self.__private_methods</strong></p><h4 id="单下划线、双下划线、头尾双下划线说明：">单下划线、双下划线、头尾双下划线说明：</h4><ul><li><code>__foo__</code>: 定义的是特殊方法，一般是系统定义名字 ，类似 <strong><strong>init</strong>()</strong> 之类的。</li><li><code>_foo</code>: 以单下划线开头的表示的是 protected 类型的变量，即保护类型只能允许其本身与子类进行访问，不能用于 <strong>from module import *</strong></li><li><code>__foo</code>: 双下划线的表示的是私有类型(private)的变量, 只能是允许这个类本身进行访问了。</li></ul><p> </p><h3 id="数据封装">数据封装</h3><p>既然<code>Student</code>实例本身就拥有数据，要访问这些数据，就没有必要从外面的函数去访问，可以直接在<code>Student</code>类的内部定义访问数据的函数，这样，就把“数据”给封装起来了。这些封装数据的函数是和<code>Student</code>类本身是关联起来的，我们称之为类的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, score</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">print_score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))</span><br></pre></td></tr></table></figure><p><strong>要定义一个方法，除了第一个参数是<code>self</code>外，其他和普通函数一样</strong>。<strong>要调用一个方法，只需要在实例变量上直接调用，除了<code>self</code>不用传递，其他参数正常传入</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bart.print_score()</span><br><span class="line">Bart Simpson: <span class="number">59</span></span><br></pre></td></tr></table></figure><p>这样一来，我们从外部看<code>Student</code>类，就只需要知道，创建实例需要给出<code>name</code>和<code>score</code>，而如何打印，都是在<code>Student</code>类的内部定义的，这些数据和逻辑被“封装”起来了，调用很容易，但却不用知道内部实现的细节。</p><p> </p><h2 id="python对象销毁-垃圾回收">python对象销毁(垃圾回收)</h2><p>Python 使用了引用计数这一简单技术来跟踪和回收垃圾。一个内部跟踪变量，称为一个引用计数器。在 Python 内部记录着所有使用中的对象各有多少引用。</p><p>当对象被创建时， 就创建了一个引用计数， 当这个对象不再需要时， 也就是说， 这个对象的引用计数变为0 时， 它被垃圾回收。但是回收不是&quot;立即&quot;的， 由解释器在适当的时机，将垃圾对象占用的内存空间回收。</p><p>垃圾回收机制不仅针对引用计数为0的对象，同样也可以处理循环引用的情况。循环引用指的是，两个对象相互引用，但是没有其他变量引用他们。这种情况下，仅使用引用计数是不够的。Python 的垃圾收集器实际上是一个引用计数器和一个循环垃圾收集器。作为引用计数的补充， 垃圾收集器也会留心被分配的总量很大（即未通过引用计数销毁的那些）的对象。 在这种情况下， 解释器会暂停下来， 试图清理所有未引用的循环。</p><p>析构函数 <code>__del__</code> ，<code>__del__</code>在对象销毁的时候被调用，当对象不再被使用时，<code>__del__</code>方法运行</p><p><strong>注意</strong>：通常你需要在单独的文件中定义一个类。</p><p> </p><h2 id="继承和多态">继承和多态</h2><p>在OOP程序设计中，当我们定义一个class的时候，可以从某个现有的class继承，新的class称为子类（Subclass），而被继承的class称为基类、父类或超类（Base class、Super class）。</p><p>比如，我们已经编写了一个名为<code>Animal</code>的class，有一个<code>run()</code>方法可以直接打印：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当我们需要编写<code>Dog</code>和<code>Cat</code>类时，就可以直接从<code>Animal</code>类继承：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>对于<code>Dog</code>来说，<code>Animal</code>就是它的父类，对于<code>Animal</code>来说，<code>Dog</code>就是它的子类。<code>Cat</code>和<code>Dog</code>类似。</p><p>继承有什么好处？最大的好处是子类获得了父类的全部功能。由于<code>Animial</code>实现了<code>run()</code>方法，因此，<code>Dog</code>和<code>Cat</code>作为它的子类，什么事也没干，就自动拥有了<code>run()</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dog = Dog()</span><br><span class="line">dog.run()</span><br><span class="line"></span><br><span class="line">cat = Cat()</span><br><span class="line">cat.run()</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Animal is running...</span><br><span class="line">Animal is running...</span><br></pre></td></tr></table></figure><p>当然，也可以对子类增加一些方法，比如Dog类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Dog is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">eat</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Eating meat...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>继承的第二个好处需要我们对代码做一点改进。你看到了，无论是<code>Dog</code>还是<code>Cat</code>，它们<code>run()</code>的时候，显示的都是<code>Animal is running...</code>，符合逻辑的做法是分别显示<code>Dog is running...</code>和<code>Cat is running...</code>，因此，对<code>Dog</code>和<code>Cat</code>类改进如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Dog is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Cat is running...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>再次运行，结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Dog is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure><p>当子类和父类都存在相同的<code>run()</code>方法时，我们说，子类的<code>run()</code>覆盖了父类的<code>run()</code>，在代码运行的时候，总是会调用子类的<code>run()</code>。这样，我们就获得了继承的另一个好处：多态。</p><p>要理解什么是多态，我们首先要对数据类型再作一点说明。当我们定义一个class的时候，我们实际上就定义了一种数据类型。我们定义的数据类型和Python自带的数据类型，比如str、list、dict没什么两样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="built_in">list</span>() <span class="comment"># a是list类型</span></span><br><span class="line">b = Animal() <span class="comment"># b是Animal类型</span></span><br><span class="line">c = Dog() <span class="comment"># c是Dog类型</span></span><br></pre></td></tr></table></figure><p><strong>判断一个变量是否是某个类型可以用<code>isinstance()</code>判断：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(a, <span class="built_in">list</span>)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(b, Animal)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, Dog)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>看来<code>a</code>、<code>b</code>、<code>c</code>确实对应着<code>list</code>、<code>Animal</code>、<code>Dog</code>这3种类型。</p><p>但是等等，试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(c, Animal)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>看来<code>c</code>不仅仅是<code>Dog</code>，<code>c</code>还是<code>Animal</code>！</p><p>不过仔细想想，这是有道理的，因为<code>Dog</code>是从<code>Animal</code>继承下来的，当我们创建了一个<code>Dog</code>的实例<code>c</code>时，我们认为<code>c</code>的数据类型是<code>Dog</code>没错，但<code>c</code>同时也是<code>Animal</code>也没错，<code>Dog</code>本来就是<code>Animal</code>的一种！</p><p>所以，<strong>在继承关系中，如果一个实例的数据类型是某个子类，那它的数据类型也可以被看做是父类。但是，反过来就不行</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = Animal()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(b, Dog)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure><p><code>Dog</code>可以看成<code>Animal</code>，但<code>Animal</code>不可以看成<code>Dog</code>。</p><p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个<code>Animal</code>类型的变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">run_twice</span>(<span class="params">animal</span>):</span><br><span class="line">    animal.run()</span><br><span class="line">    animal.run()</span><br></pre></td></tr></table></figure><p>当我们传入<code>Animal</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>run_twice(Animal())</span><br><span class="line">Animal <span class="keyword">is</span> running...</span><br><span class="line">Animal <span class="keyword">is</span> running...</span><br></pre></td></tr></table></figure><p>当我们传入<code>Dog</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Dog())</span><br><span class="line">Dog is running...</span><br><span class="line">Dog is running...</span><br></pre></td></tr></table></figure><p>当我们传入<code>Cat</code>的实例时，<code>run_twice()</code>就打印出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Cat())</span><br><span class="line">Cat is running...</span><br><span class="line">Cat is running...</span><br></pre></td></tr></table></figure><p>看上去没啥意思，但是仔细想想，现在，如果我们再定义一个<code>Tortoise</code>类型，也从<code>Animal</code>派生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Tortoise</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Tortoise is running slowly...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当我们调用<code>run_twice()</code>时，传入<code>Tortoise</code>的实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; run_twice(Tortoise())</span><br><span class="line">Tortoise is running slowly...</span><br><span class="line">Tortoise is running slowly...</span><br></pre></td></tr></table></figure><p>你会发现，新增一个<code>Animal</code>的子类，不必对<code>run_twice()</code>做任何修改，实际上，任何依赖<code>Animal</code>作为参数的函数或者方法都可以不加修改地正常运行，原因就在于多态。</p><p>多态的好处就是，当我们需要传入<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……时，我们只需要接收<code>Animal</code>类型就可以了，因为<code>Dog</code>、<code>Cat</code>、<code>Tortoise</code>……都是<code>Animal</code>类型，然后，按照<code>Animal</code>类型进行操作即可。由于<code>Animal</code>类型有<code>run()</code>方法，因此，传入的任意类型，只要是<code>Animal</code>类或者子类，就会自动调用实际类型的<code>run()</code>方法，这就是多态的意思：</p><p>对于一个变量，我们只需要知道它是<code>Animal</code>类型，无需确切地知道它的子类型，就可以放心地调用<code>run()</code>方法，而具体调用的<code>run()</code>方法是作用在<code>Animal</code>、<code>Dog</code>、<code>Cat</code>还是<code>Tortoise</code>对象上，由运行时该对象的确切类型决定，这就是多态真正的威力：<strong>调用方只管调用，不管细节，而当我们新增一种<code>Animal</code>的子类时，只要确保<code>run()</code>方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</strong></p><p><strong>对扩展开放：允许新增<code>Animal</code>子类；</strong></p><p><strong>对修改封闭：不需要修改依赖<code>Animal</code>类型的<code>run_twice()</code>等函数。</strong></p><p>继承还可以一级一级地继承下来，就好比从爷爷到爸爸、再到儿子这样的关系。而任何类，最终都可以追溯到根类object，这些继承关系看上去就像一颗倒着的树。比如如下的继承树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">                ┌───────────────┐</span><br><span class="line">                │    object     │</span><br><span class="line">                └───────────────┘</span><br><span class="line">                        │</span><br><span class="line">           ┌────────────┴────────────┐</span><br><span class="line">           │                         │</span><br><span class="line">           ▼                         ▼</span><br><span class="line">    ┌─────────────┐           ┌─────────────┐</span><br><span class="line">    │   Animal    │           │    Plant    │</span><br><span class="line">    └─────────────┘           └─────────────┘</span><br><span class="line">           │                         │</span><br><span class="line">     ┌─────┴──────┐            ┌─────┴──────┐</span><br><span class="line">     │            │            │            │</span><br><span class="line">     ▼            ▼            ▼            ▼</span><br><span class="line">┌─────────┐  ┌─────────┐  ┌─────────┐  ┌─────────┐</span><br><span class="line">│   Dog   │  │   Cat   │  │  Tree   │  │ Flower  │</span><br><span class="line">└─────────┘  └─────────┘  └─────────┘  └─────────┘</span><br></pre></td></tr></table></figure><h3 id="静态语言-vs-动态语言">静态语言 vs 动态语言</h3><p>对于静态语言（例如Java）来说，如果需要传入<code>Animal</code>类型，则传入的对象必须是<code>Animal</code>类型或者它的子类，否则，将无法调用<code>run()</code>方法。</p><p>对于Python这样的动态语言来说，则不一定需要传入<code>Animal</code>类型。我们只需要保证传入的对象有一个<code>run()</code>方法就可以了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Timer</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">run</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;Start...&#x27;</span>)</span><br></pre></td></tr></table></figure><p><strong>这就是动态语言的“鸭子类型”，它并不要求严格的继承体系，一个对象只要“看起来像鸭子，走起路来像鸭子”，那它就可以被看做是鸭子。</strong></p><p>Python的“file-like object“就是一种鸭子类型。对真正的文件对象，它有一个<code>read()</code>方法，返回其内容。但是，许多对象，只要有<code>read()</code>方法，都被视为“file-like object“。许多函数接收的参数就是“file-like object“，你不一定要传入真正的文件对象，完全可以传入任何实现了<code>read()</code>方法的对象。</p><p> </p><h2 id="实例属性和类属性">实例属性和类属性</h2><p>由于Python是动态语言，根据类创建的实例可以任意绑定属性。动态绑定允许我们在程序运行的过程中动态给class加上功能，这在静态语言中很难实现。</p><p><strong>给实例绑定属性的方法是通过实例变量，或者通过<code>self</code>变量</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name</span>):</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">s = Student(<span class="string">&#x27;Bob&#x27;</span>)</span><br><span class="line">s.score = <span class="number">90</span></span><br></pre></td></tr></table></figure><p>但是，如果<code>Student</code>类本身需要绑定一个属性呢？<strong>可以直接在class中定义属性，这种属性是类属性，归<code>Student</code>类所有</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    name = <span class="string">&#x27;Student&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>当我们定义了一个类属性后，这个属性虽然归类所有，但类的所有实例都可以访问到</strong>。</p><p>实例属性属于各个实例所有，互不干扰；</p><p>类属性属于类所有，所有实例共享一个属性；</p><p>不要对实例属性和类属性使用相同的名字，否则将产生难以发现的错误。</p><h3 id="使用-slots">使用<code>__slots__</code></h3><p>但是，如果我们想要限制实例的属性怎么办？比如，只允许对Student实例添加<code>name</code>和<code>age</code>属性。</p><p><strong>为了达到限制的目的，Python允许在定义class的时候，定义一个特殊的<code>__slots__</code>变量，来限制该class实例能添加的属性</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;age&#x27;</span>) <span class="comment"># 用tuple定义允许绑定的属性名称</span></span><br></pre></td></tr></table></figure><p>然后，我们试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student() <span class="comment"># 创建新的实例</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.name = <span class="string">&#x27;Michael&#x27;</span> <span class="comment"># 绑定属性&#x27;name&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.age = <span class="number">25</span> <span class="comment"># 绑定属性&#x27;age&#x27;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">99</span> <span class="comment"># 绑定属性&#x27;score&#x27;</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">&#x27;Student&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;score&#x27;</span></span><br></pre></td></tr></table></figure><p>由于<code>'score'</code>没有被放到<code>__slots__</code>中，所以不能绑定<code>score</code>属性，试图绑定<code>score</code>将得到<code>AttributeError</code>的错误。</p><p><strong>使用<code>__slots__</code>要注意，<code>__slots__</code>定义的属性仅对当前类实例起作用，对继承的子类是不起作用的</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">class</span> <span class="title class_">GraduateStudent</span>(<span class="title class_ inherited__">Student</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">pass</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g = GraduateStudent()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>g.score = <span class="number">9999</span></span><br></pre></td></tr></table></figure><p>除非在子类中也定义<code>__slots__</code>，这样，<strong>子类实例允许定义的属性就是自身的<code>__slots__</code>加上父类的<code>__slots__</code></strong>。</p><h3 id="使用-property">使用@property</h3><p>在绑定属性时，如果我们直接把属性暴露出去，虽然写起来很简单，但是，没办法检查参数，导致可以把成绩随便改：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = Student()</span><br><span class="line">s.score = <span class="number">9999</span></span><br></pre></td></tr></table></figure><p>这显然不合逻辑。为了限制score的范围，可以通过一个<code>set_score()</code>方法来设置成绩，再通过一个<code>get_score()</code>来获取成绩，这样，在<code>set_score()</code>方法里，就可以检查参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_score</span>(<span class="params">self</span>):</span><br><span class="line">         <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">set_score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><p>现在，对任意的Student实例进行操作，就不能随心所欲地设置score了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">60</span>) <span class="comment"># ok!</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.get_score()</span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.set_score(<span class="number">9999</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure><p>但是，上面的调用方法又略显复杂，没有直接用属性这么直接简单。</p><p>有没有既能检查参数，又可以用类似属性这样简单的方式来访问类的变量呢？对于追求完美的Python程序员来说，这是必须要做到的！</p><p>还记得装饰器（decorator）可以给函数动态加上功能吗？对于类的方法，装饰器一样起作用。<strong>Python内置的<code>@property</code>装饰器就是负责把一个方法变成属性调用</strong>的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._score</span><br><span class="line"></span><br><span class="line"><span class="meta">    @score.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">score</span>(<span class="params">self, value</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must be an integer!&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span> value &lt; <span class="number">0</span> <span class="keyword">or</span> value &gt; <span class="number">100</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;score must between 0 ~ 100!&#x27;</span>)</span><br><span class="line">        self._score = value</span><br></pre></td></tr></table></figure><p><code>@property</code>的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上<code>@property</code>就可以了，此时，<code>@property</code>本身又创建了另一个装饰器<code>@score.setter</code>，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = Student()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">60</span> <span class="comment"># OK，实际转化为s.set_score(60)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score <span class="comment"># OK，实际转化为s.get_score()</span></span><br><span class="line"><span class="number">60</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>s.score = <span class="number">9999</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: score must between <span class="number">0</span> ~ <span class="number">100</span>!</span><br></pre></td></tr></table></figure><p>注意到这个神奇的<code>@property</code>，我们在对实例属性操作的时候，就知道该属性很可能不是直接暴露的，而是通过getter和setter方法来实现的。</p><p>还可以定义只读属性，只定义getter方法，不定义setter方法就是一个只读属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._birth</span><br><span class="line"></span><br><span class="line"><span class="meta">    @birth.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self, value</span>):</span><br><span class="line">        self._birth = value</span><br><span class="line"></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">age</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2015</span> - self._birth</span><br></pre></td></tr></table></figure><p>上面的<code>birth</code>是可读写属性，而<code>age</code>就是一个只读属性，因为<code>age</code>可以根据<code>birth</code>和当前时间计算出来。</p><p>要特别注意：<strong>属性的方法名不要和实例变量重名</strong>。例如，以下的代码是错误的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 方法名称和实例变量均为birth:</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">birth</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.birth</span><br></pre></td></tr></table></figure><p>这是因为调用<code>s.birth</code>时，首先转换为方法调用，在执行<code>return self.birth</code>时，又视为访问<code>self</code>的属性，于是又转换为方法调用，造成无限递归，最终导致栈溢出报错<code>RecursionError</code>。</p><p> </p><h2 id="枚举类">枚举类</h2><p>当我们需要定义常量时，一个办法是用大写变量通过整数来定义，例如月份：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">JAN = <span class="number">1</span></span><br><span class="line">FEB = <span class="number">2</span></span><br><span class="line">MAR = <span class="number">3</span></span><br><span class="line">...</span><br><span class="line">NOV = <span class="number">11</span></span><br><span class="line">DEC = <span class="number">12</span></span><br></pre></td></tr></table></figure><p>好处是简单，缺点是类型是<code>int</code>，并且仍然是变量。</p><p>更好的方法是为这样的枚举类型定义一个class类型，然后，每个常量都是class的一个唯一实例。Python提供了<code>Enum</code>类来实现这个功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line">Month = Enum(<span class="string">&#x27;Month&#x27;</span>, (<span class="string">&#x27;Jan&#x27;</span>, <span class="string">&#x27;Feb&#x27;</span>, <span class="string">&#x27;Mar&#x27;</span>, <span class="string">&#x27;Apr&#x27;</span>, <span class="string">&#x27;May&#x27;</span>, <span class="string">&#x27;Jun&#x27;</span>, <span class="string">&#x27;Jul&#x27;</span>, <span class="string">&#x27;Aug&#x27;</span>, <span class="string">&#x27;Sep&#x27;</span>, <span class="string">&#x27;Oct&#x27;</span>, <span class="string">&#x27;Nov&#x27;</span>, <span class="string">&#x27;Dec&#x27;</span>))</span><br></pre></td></tr></table></figure><p>这样我们就获得了<code>Month</code>类型的枚举类，可以直接使用<code>Month.Jan</code>来引用一个常量，或者枚举它的所有成员：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name, member <span class="keyword">in</span> Month.__members__.items():</span><br><span class="line">    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member, <span class="string">&#x27;,&#x27;</span>, member.value)</span><br></pre></td></tr></table></figure><p><code>value</code>属性则是自动赋给成员的<code>int</code>常量，默认从<code>1</code>开始计数。</p><p>如果需要更精确地控制枚举类型，可以从<code>Enum</code>派生出自定义类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum, unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Weekday</span>(<span class="title class_ inherited__">Enum</span>):</span><br><span class="line">    Sun = <span class="number">0</span> <span class="comment"># Sun的value被设定为0</span></span><br><span class="line">    Mon = <span class="number">1</span></span><br><span class="line">    Tue = <span class="number">2</span></span><br><span class="line">    Wed = <span class="number">3</span></span><br><span class="line">    Thu = <span class="number">4</span></span><br><span class="line">    Fri = <span class="number">5</span></span><br><span class="line">    Sat = <span class="number">6</span></span><br></pre></td></tr></table></figure><p><code>@unique</code>装饰器可以帮助我们检查保证没有重复值。</p><p>访问这些枚举类型可以有若干种方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>day1 = Weekday.Mon</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1)</span><br><span class="line">Weekday.Mon</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday.Tue)</span><br><span class="line">Weekday.Tue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday[<span class="string">&#x27;Tue&#x27;</span>])</span><br><span class="line">Weekday.Tue</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday.Tue.value)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday.Mon)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday.Tue)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(Weekday(<span class="number">1</span>))</span><br><span class="line">Weekday.Mon</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(day1 == Weekday(<span class="number">1</span>))</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Weekday(<span class="number">7</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  ...</span><br><span class="line">ValueError: <span class="number">7</span> <span class="keyword">is</span> <span class="keyword">not</span> a valid Weekday</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> name, member <span class="keyword">in</span> Weekday.__members__.items():</span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(name, <span class="string">&#x27;=&gt;&#x27;</span>, member)</span><br><span class="line">...</span><br><span class="line">Sun =&gt; Weekday.Sun</span><br><span class="line">Mon =&gt; Weekday.Mon</span><br><span class="line">Tue =&gt; Weekday.Tue</span><br><span class="line">Wed =&gt; Weekday.Wed</span><br><span class="line">Thu =&gt; Weekday.Thu</span><br><span class="line">Fri =&gt; Weekday.Fri</span><br><span class="line">Sat =&gt; Weekday.Sat</span><br></pre></td></tr></table></figure><p>可见，<strong>既可以用成员名称引用枚举常量，又可以直接根据value的值获得枚举常量</strong>。</p><p> </p><h1>IO</h1><p><strong>IO编程中，Stream（流）是一个很重要的概念，可以把流想象成一个水管，数据就是水管里的水，但是只能单向流动</strong>。Input Stream就是数据从外面（磁盘、网络）流进内存，Output Stream就是数据从内存流到外面去。</p><p>由于CPU和内存的速度远远高于外设的速度，所以，在IO编程中，就存在速度严重不匹配的问题。举个例子来说，比如要把100M的数据写入磁盘，CPU输出100M的数据只需要0.01秒，可是磁盘要接收这100M数据可能需要10秒，怎么办呢？有两种办法：</p><p>第一种是CPU等着，也就是程序暂停执行后续代码，等100M的数据在10秒后写入磁盘，再接着往下执行，这种模式称为<strong>同步IO</strong>；</p><p>另一种方法是CPU不等待，只是告诉磁盘，“您老慢慢写，不着急，我接着干别的事去了”，于是，后续代码可以立刻接着执行，这种模式称为<strong>异步IO</strong>。</p><p>同步和异步的区别就在于是否等待IO执行的结果。好比你去麦当劳点餐，你说“来个汉堡”，服务员告诉你，对不起，汉堡要现做，需要等5分钟，于是你站在收银台前面等了5分钟，拿到汉堡再去逛商场，这是同步IO。</p><p>你说“来个汉堡”，服务员告诉你，汉堡需要等5分钟，你可以先去逛商场，等做好了，我们再通知你，这样你可以立刻去干别的事情（逛商场），这是异步IO。</p><p>很明显，使用异步IO来编写程序性能会远远高于同步IO，但是异步IO的缺点是编程模型复杂。想想看，你得知道什么时候通知你“汉堡做好了”，而通知你的方法也各不相同。如果是服务员跑过来找到你，这是回调模式，如果服务员发短信通知你，你就得不停地检查手机，这是轮询模式。总之，异步IO的复杂度远远高于同步IO。</p><p>操作IO的能力都是由操作系统提供的，每一种编程语言都会把操作系统提供的低级C接口封装起来方便使用，Python也不例外。我们后面会详细讨论Python的IO编程接口。</p><p>注意，本章的IO编程都是同步模式。</p><p> </p><h2 id="文件读写">文件读写</h2><p>读写文件是最常见的IO操作。Python内置了读写文件的函数，用法和C是兼容的。</p><p>读写文件前，我们先必须了解一下，<strong>在磁盘上读写文件的功能都是由操作系统提供的，现代操作系统不允许普通的程序直接操作磁盘，所以，读写文件就是请求操作系统打开一个文件对象（通常称为文件描述符），然后，通过操作系统提供的接口从这个文件对象中读取数据（读文件），或者把数据写入这个文件对象（写文件）</strong>。</p><h3 id="打开和关闭文件">打开和关闭文件</h3><p>Python 提供了必要的函数和方法进行默认情况下的文件基本操作。你可以用 <strong>file</strong> 对象做大部分的文件操作。</p><h4 id="open-函数">open 函数</h4><p>你必须先用Python内置的open()函数打开一个文件，创建一个file对象，相关的方法才可以调用它进行读写。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file = <span class="built_in">open</span>(file_name [, access_mode][, buffering])</span><br></pre></td></tr></table></figure><p>各个参数的细节如下：</p><ul><li><code>file_name</code>：file_name变量是一个包含了你<strong>要访问的文件名称的字符串值</strong>。</li><li><code>access_mode</code>：<strong><code>access_mode</code>决定了打开文件的模式</strong>：只读，写入，追加等。所有可取值见如下的完全列表。这个参数是非强制的，<strong>默认文件访问模式为只读®</strong>。</li><li>``buffering<code>:**如果</code>buffering`的值被设为0，就不会有寄存。如果buffering的值取1，访问文件时会寄存行。如果将buffering的值设为大于1的整数，表明了这就是的寄存区的缓冲大小。如果取负值，寄存区的缓冲大小则为系统默认。**</li></ul><p>实际上参数还有很多，包括：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(file: <span class="type">Union</span>[<span class="built_in">str</span>, <span class="built_in">bytes</span>, PathLike[<span class="built_in">str</span>], PathLike[<span class="built_in">bytes</span>], <span class="built_in">int</span>], mode: <span class="built_in">str</span>, buffering: <span class="built_in">int</span>, encoding: <span class="type">Optional</span>[<span class="built_in">str</span>], errors: <span class="type">Optional</span>[<span class="built_in">str</span>], newline: <span class="type">Optional</span>[<span class="built_in">str</span>], closefd: <span class="built_in">bool</span>, opener: <span class="type">Optional</span>[(<span class="built_in">str</span>, <span class="built_in">int</span>) -&gt; <span class="built_in">int</span>]) -&gt; IO </span><br></pre></td></tr></table></figure><p>不同模式打开文件的完全列表：</p><table><thead><tr><th style="text-align:left">模式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">t</td><td style="text-align:left">文本模式 (默认)。</td></tr><tr><td style="text-align:left">x</td><td style="text-align:left">写模式，新建一个文件，如果该文件已存在则会报错。</td></tr><tr><td style="text-align:left">b</td><td style="text-align:left">二进制模式。</td></tr><tr><td style="text-align:left">+</td><td style="text-align:left"><strong>打开一个文件进行更新(可读可写)</strong>。</td></tr><tr><td style="text-align:left">U</td><td style="text-align:left">通用换行模式（不推荐）。</td></tr><tr><td style="text-align:left">r</td><td style="text-align:left">以只读方式打开文件。文件的指针将会放在文件的开头。这是默认模式。</td></tr><tr><td style="text-align:left">rb</td><td style="text-align:left">以二进制格式打开一个文件用于只读。文件指针将会放在文件的开头。这是默认模式。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">r+</td><td style="text-align:left"><strong>打开一个文件用于读写。文件指针将会放在文件的开头。</strong></td></tr><tr><td style="text-align:left">rb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。文件指针将会放在文件的开头。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">w</td><td style="text-align:left">打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即<strong>原有内容会被删除</strong>。如果该文件不存在，创建新文件。</td></tr><tr><td style="text-align:left">wb</td><td style="text-align:left">以二进制格式打开一个文件只用于写入。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">w+</td><td style="text-align:left"><strong>打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。</strong></td></tr><tr><td style="text-align:left">wb+</td><td style="text-align:left">以二进制格式打开一个文件用于读写。如果该文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。一般用于非文本文件如图片等。</td></tr><tr><td style="text-align:left">a</td><td style="text-align:left"><strong>打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</strong></td></tr><tr><td style="text-align:left">ab</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。也就是说，新的内容将会被写入到已有内容之后。如果该文件不存在，创建新文件进行写入。</td></tr><tr><td style="text-align:left">a+</td><td style="text-align:left">打开一个文件用于读写。如果该文件已存在，文件指针将会放在文件的结尾。文件打开时会是追加模式。如果该文件不存在，创建新文件用于读写。</td></tr><tr><td style="text-align:left">ab+</td><td style="text-align:left">以二进制格式打开一个文件用于追加。如果该文件已存在，文件指针将会放在文件的结尾。如果该文件不存在，创建新文件用于读写。</td></tr></tbody></table><p>下图很好的总结了这几种模式：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/404.webp" data-original="/posts/47dff421/1.png" alt></p><table><thead><tr><th style="text-align:center">模式</th><th style="text-align:center">r</th><th style="text-align:center">r+</th><th style="text-align:center">w</th><th style="text-align:center">w+</th><th style="text-align:center">a</th><th style="text-align:center">a+</th></tr></thead><tbody><tr><td style="text-align:center">读</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center"></td><td style="text-align:center">+</td><td style="text-align:center"></td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">写</td><td style="text-align:center"></td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">创建</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td></tr><tr><td style="text-align:center">覆盖</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指针在开始</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center">+</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">指针在结尾</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">+</td><td style="text-align:center">+</td></tr></tbody></table><p> </p><h2 id="File对象的属性">File对象的属性</h2><p>一个文件被打开后，你有一个file对象，你可以得到有关该文件的各种信息。</p><p>以下是和file对象相关的所有属性的列表：</p><table><thead><tr><th style="text-align:left">属性</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">file.closed</td><td style="text-align:left">返回true如果文件已被关闭，否则返回false。</td></tr><tr><td style="text-align:left">file.mode</td><td style="text-align:left">返回被打开文件的访问模式。</td></tr><tr><td style="text-align:left"><a target="_blank" rel="noopener external nofollow noreferrer" href="http://file.name">file.name</a></td><td style="text-align:left">返回文件的名称。</td></tr><tr><td style="text-align:left">file.softspace</td><td style="text-align:left">如果用print输出后，必须跟一个空格符，则返回false。否则返回true。</td></tr></tbody></table><p>如下实例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;文件名: &quot;</span>, fo.name</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;是否已关闭 : &quot;</span>, fo.closed</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;访问模式 : &quot;</span>, fo.mode</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;末尾是否强制加空格 : &quot;</span>, fo.softspace</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">文件名:  foo.txt</span><br><span class="line">是否已关闭 :  False</span><br><span class="line">访问模式 :  w</span><br><span class="line">末尾是否强制加空格 :  0</span><br></pre></td></tr></table></figure><h3 id="write-方法">write()方法</h3><p>write()方法可将任何字符串写入一个打开的文件。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。<strong>write()方法不会在字符串的结尾添加换行符(‘\n’)：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.write(string)</span><br></pre></td></tr></table></figure><p>在这里，被传递的参数是要写入到已打开文件的内容。</p><p>例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;w&quot;</span>)</span><br><span class="line">fo.write( <span class="string">&quot;www.runoob.com!\nVery good site!\n&quot;</span>)</span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure><p>上述方法会创建foo.txt文件，并将收到的内容写入该文件，并最终关闭文件。如果你打开这个文件，将看到以下内容:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat foo.txt </span><br><span class="line">www.runoob.com!</span><br><span class="line">Very good site!</span><br></pre></td></tr></table></figure><h3 id="read-方法">read()方法</h3><p><code>read（）</code>方法从一个打开的文件中读取一个字符串。需要重点注意的是，Python字符串可以是二进制数据，而不是仅仅是文字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.read([count])</span><br></pre></td></tr></table></figure><p>在这里，<strong>被传递的参数是要从已打开文件中读取的字节计数</strong>。该方法从文件的开头开始读入，如果没有传入count，它会尝试尽可能多地读取更多的内容，很可能是直到文件的末尾。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;读取的字符串是 : &quot;</span>, <span class="built_in">str</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">读取的字符串是 :  www.runoob</span><br></pre></td></tr></table></figure><p>由于文件读写时都有可能产生<code>IOError</code>，一旦出错，后面的<code>f.close()</code>就不会调用。所以，为了保证无论是否出错都能正确地关闭文件，我们可以使用<code>try ... finally</code>来实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    f = <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="keyword">if</span> f:</span><br><span class="line">        f.close()</span><br></pre></td></tr></table></figure><p>但是每次都这么写实在太繁琐，所以，<strong>Python引入了<code>with</code>语句来自动帮我们调用<code>close()</code>方法</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;/path/to/file&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="built_in">print</span>(f.read())</span><br></pre></td></tr></table></figure><p>这和前面的<code>try ... finally</code>是一样的，但是代码更佳简洁，并且不必调用<code>f.close()</code>方法。</p><p>调用<code>read()</code>会一次性读取文件的全部内容，如果文件有10G，内存就爆了，所以，<strong>要保险起见，可以反复调用<code>read(size)</code>方法，每次最多读取size个字节的内容。另外，调用<code>readline()</code>可以每次读取一行内容，调用<code>readlines()</code>一次读取所有内容并按行返回<code>list</code></strong>。因此，要根据需要决定怎么调用。</p><p>如果文件很小，<code>read()</code>一次性读取最方便；如果不能确定文件大小，反复调用<code>read(size)</code>比较保险；如果是配置文件，调用<code>readlines()</code>最方便：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f.readlines():</span><br><span class="line">    <span class="built_in">print</span>(line.strip()) <span class="comment"># 把末尾的&#x27;\n&#x27;删掉</span></span><br></pre></td></tr></table></figure><h3 id="close-方法">close()方法</h3><p>File 对象的<code>close（）</code>方法<strong>刷新缓冲区里任何还没写入的信息，并关闭该文件，这之后便不能再进行写入</strong>。</p><p><strong>当一个文件对象的引用被重新指定给另一个文件时，Python 会关闭之前的文件</strong>。用 close（）方法关闭文件是一个很好的习惯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fileObject.close()</span><br></pre></td></tr></table></figure><p> </p><h3 id="另：">另：</h3><h4 id="字符编码">字符编码</h4><p>要读取非UTF-8编码的文本文件，需要给<code>open()</code>函数传入<code>encoding</code>参数，例如，读取GBK编码的文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">&#x27;测试&#x27;</span></span><br></pre></td></tr></table></figure><p>遇到有些编码不规范的文件，你可能会遇到<code>UnicodeDecodeError</code>，因为在文本文件中可能夹杂了一些非法编码的字符。遇到这种情况，<code>open()</code>函数还接收一个<code>errors</code>参数，表示如果遇到编码错误后如何处理。最简单的方式是直接忽略：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = <span class="built_in">open</span>(<span class="string">&#x27;/Users/michael/gbk.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>, encoding=<span class="string">&#x27;gbk&#x27;</span>, errors=<span class="string">&#x27;ignore&#x27;</span>)</span><br></pre></td></tr></table></figure><h4 id="StringIO和BytesIO">StringIO和BytesIO</h4><p><code>StringIO</code>和<code>BytesIO</code>是在<strong>内存</strong>中操作string和bytes的方法，使得和读写文件具有一致的接口。</p><h5 id="StringIO">StringIO</h5><p>很多时候，数据读写不一定是文件，也可以在内存中读写。StringIO顾名思义就是在内存中读写str。</p><p>要把str写入StringIO，我们需要先创建一个StringIO，然后，像文件一样写入即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27; &#x27;</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;world!&#x27;</span>)</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f.getvalue())</span><br><span class="line">hello world!</span><br></pre></td></tr></table></figure><p><code>getvalue()</code>方法用于获得写入后的str。</p><p>要读取StringIO，可以用一个str初始化StringIO，然后，像读文件一样读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> StringIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = StringIO(<span class="string">&#x27;Hello!\nHi!\nGoodbye!&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line"><span class="meta">... </span>    s = f.readline()</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> s == <span class="string">&#x27;&#x27;</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">break</span></span><br><span class="line"><span class="meta">... </span>    <span class="built_in">print</span>(s.strip())</span><br><span class="line">...</span><br><span class="line">Hello!</span><br><span class="line">Hi!</span><br><span class="line">Goodbye!</span><br></pre></td></tr></table></figure><h5 id="BytesIO">BytesIO</h5><p>StringIO操作的只能是str，如果要操作二进制数据，就需要使用BytesIO。</p><p>BytesIO实现了在内存中读写bytes，我们创建一个BytesIO，然后写入一些bytes：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.write(<span class="string">&#x27;中文&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"><span class="number">6</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span>(f.getvalue())</span><br><span class="line"><span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br></pre></td></tr></table></figure><p>请注意，写入的不是str，而是经过UTF-8编码的bytes。</p><p>和StringIO类似，可以用一个bytes初始化BytesIO，然后，像读文件一样读取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = BytesIO(<span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f.read()</span><br><span class="line"><span class="string">b&#x27;\xe4\xb8\xad\xe6\x96\x87&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="文件定位">文件定位</h4><p><code>tell()</code>方法告诉你<strong>文件内</strong>的当前位置, 换句话说，<strong>下一次的读写会发生在文件开头这么多字节之后</strong>。</p><p><code>seek（offset [,from]）</code>方法<strong>改变当前文件内的位置</strong>。Offset变量表示要移动的字节数。From变量指定开始移动字节的参考位置。</p><p><strong>如果from被设为0，这意味着将文件的开头作为移动字节的参考位置。如果设为1，则使用当前的位置作为参考位置。如果它被设为2，那么该文件的末尾将作为参考位置。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">fo = <span class="built_in">open</span>(<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;r+&quot;</span>)</span><br><span class="line"><span class="built_in">str</span> = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;读取的字符串是 : &quot;</span>, <span class="built_in">str</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查找当前位置</span></span><br><span class="line">position = fo.tell()</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;当前文件位置 : &quot;</span>, position</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 把指针再次重新定位到文件开头</span></span><br><span class="line">position = fo.seek(<span class="number">0</span>, <span class="number">0</span>)</span><br><span class="line"><span class="built_in">str</span> = fo.read(<span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;重新读取字符串 : &quot;</span>, <span class="built_in">str</span></span><br><span class="line">fo.close()</span><br></pre></td></tr></table></figure><p>以上实例输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">读取的字符串是 :  www.runoob</span><br><span class="line">当前文件位置 :  <span class="number">10</span></span><br><span class="line">重新读取字符串 :  www.runoob</span><br></pre></td></tr></table></figure><p> </p><h2 id="重命名和删除文件">重命名和删除文件</h2><p>Python的os模块提供了帮你执行文件处理操作的方法，比如重命名和删除文件。</p><p>要使用这个模块，你必须先导入它，然后才可以调用相关的各种功能。</p><h3 id="rename-方法">rename() 方法</h3><p><code>rename()</code> 方法需要两个参数，当前的文件名和新文件名。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.rename(current_file_name, new_file_name)</span><br></pre></td></tr></table></figure><h3 id="remove-方法">remove()方法</h3><p>你可以用<code>remove()</code>方法删除文件，需要提供要删除的文件名作为参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.remove(file_name)</span><br></pre></td></tr></table></figure><p> </p><h2 id="Python里的目录：">Python里的目录：</h2><p>所有文件都包含在各个不同的目录下，不过Python也能轻松处理。os模块有许多方法能帮你创建，删除和更改目录。</p><h3 id="mkdir-方法">mkdir()方法</h3><p>可以使用os模块的<code>mkdir()</code>方法在当前目录下创建新的目录们。你需要提供一个包含了要创建的目录名称的参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.mkdir(<span class="string">&quot;newdir&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="chdir-方法">chdir()方法</h3><p>可以用<code>chdir()</code>方法来<strong>改变当前的目录</strong>。<code>chdir()</code>方法需要的一个参数是你想设成当前目录的目录名称。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.chdir(<span class="string">&quot;newdir&quot;</span>)</span><br></pre></td></tr></table></figure><p>下例将进入&quot;/home/newdir&quot;目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 将当前目录改为&quot;/home/newdir&quot;</span></span><br><span class="line">os.chdir(<span class="string">&quot;/home/newdir&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="getcwd-方法：">getcwd()方法：</h3><p><code>getcwd()</code>方法显示当前的工作目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.getcwd()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="built_in">print</span> os.getcwd()</span><br></pre></td></tr></table></figure><h3 id="rmdir-方法">rmdir()方法</h3><p><code>rmdir()</code>方法删除目录，目录名称以参数传递。</p><p><strong>在删除这个目录之前，它的所有内容应该先被清除。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">os.rmdir(<span class="string">&#x27;dirname&#x27;</span>)</span><br></pre></td></tr></table></figure><p>以下是删除&quot; /tmp/test&quot;目录的例子。目录的完全合规的名称必须被给出，否则会在当前目录下搜索该目录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除”/tmp/test”目录</span></span><br><span class="line">os.rmdir( <span class="string">&quot;/tmp/test&quot;</span>  )</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.runoob.com/python/os-file-methods.html">Python OS 文件/目录方法</a></p><p> </p><h1>网络：从0到1，Python网络编程的入门之路</h1><p>来自<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/people/mrlwt">tonnie</a>的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/question/48509984">从0到1，Python网络编程的入门之路</a></p><p>有删改但不多，只是加了一些标题用来划分不同内容以及一些加粗标注，写的挺好的，不过看之前建议看看《图解TCP/IP》这类的基础知识书。</p><p>最近在学习Python网络编程时看了一些相关的文章，发现大多数要么讲的晦涩难懂，要么讲的比较浅显，我就想为什么不在学习的过程中写一篇心得呢，于是有了这篇文章。我相信技术不全是冰冷的，从人的角度出发，才能更好地领悟编程的乐趣，本文将尝试以简洁的文字分享如何入门Python中的网络编程。</p><p>在Python世界里，喜欢用Python做爬虫的人不在少数，那么在请求页面的过程中发生了什么呢？</p><p> </p><h2 id="网络请求过程：TCP-IP的小例子">网络请求过程：TCP/IP的小例子</h2><p>现在编写一个最简单的Client/Server程序：</p><ol><li><p>首先执行下面的命令开启一个监听8000端口的HTTP服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8000</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 ...</span><br></pre></td></tr></table></figure></li><li><p>接着编写一个程序，来对这个服务器发起HTTP请求：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line">r = requests.get(<span class="string">&#x27;http://127.0.0.1:8000/&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(r)</span><br></pre></td></tr></table></figure></li><li><p>再执行这个程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ python test.py</span><br><span class="line">&lt;Response [200]&gt;</span><br></pre></td></tr></table></figure></li></ol><p>可以看到，服务器返回了一个200成功响应。</p><p>好，现在我们来总结请求过程：</p><ol><li>客户端向服务器端发起了一个HTTP(GET)请求。</li><li>服务器端向客户端返回了一个HTTP(200)响应。</li></ol><p>这是我们能看到的最抽象的过程，下面再用tcpdump细看发生了什么：</p><p>在命令行用tcpdump来监听本地网卡的tcp连接，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i lo0 port 8000</span><br></pre></td></tr></table></figure><p>或者你也可以用-w参数把信息写出到文件，再通过wireshark来观察结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tcpdump -i lo0 port 8000 -w test.cap</span><br></pre></td></tr></table></figure><p>现在执行程序：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bash-3.2$ python test.py</span><br><span class="line">&lt;Response [200]&gt;</span><br></pre></td></tr></table></figure><p>不出意外的话，我们就能观察到tcpdump输出类似如下的结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">tcpdump: verbose output suppressed, use -v or -vv for full protocol decode</span><br><span class="line">listening on lo0, link-type NULL (BSD loopback), capture size 262144 bytes</span><br><span class="line">23:46:06.464962 IP localhost.49329 &gt; localhost.irdmi: Flags [S], seq 1191154495, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 178410641 ecr 0,sackOK,eol], length 0</span><br><span class="line">23:46:06.465018 IP localhost.irdmi &gt; localhost.49329: Flags [S.], seq 1405387906, ack 1191154496, win 65535, options [mss 16344,nop,wscale 5,nop,nop,TS val 178410641 ecr 178410641,sackOK,eol], length 0</span><br><span class="line">23:46:06.465029 IP localhost.49329 &gt; localhost.irdmi: Flags [.], ack 1, win 12759, options [nop,nop,TS val 178410641 ecr 178410641], length 0</span><br><span class="line">23:46:06.465039 IP localhost.irdmi &gt; localhost.49329: Flags [.], ack 1, win 12759, options [nop,nop,TS val 178410641 ecr 178410641], length 0</span><br><span class="line">23:46:06.465065 IP localhost.49329 &gt; localhost.irdmi: Flags [P.], seq 1:146, ack 1, win 12759, options [nop,nop,TS val 178410641 ecr 178410641], length 145</span><br><span class="line">23:46:06.465079 IP localhost.irdmi &gt; localhost.49329: Flags [.], ack 146, win 12754, options [nop,nop,TS val 178410641 ecr 178410641], length 0</span><br><span class="line">23:46:06.467141 IP localhost.irdmi &gt; localhost.49329: Flags [P.], seq 1:156, ack 146, win 12754, options [nop,nop,TS val 178410642 ecr 178410641], length 155</span><br><span class="line">23:46:06.467171 IP localhost.49329 &gt; localhost.irdmi: Flags [.], ack 156, win 12754, options [nop,nop,TS val 178410643 ecr 178410642], length 0</span><br><span class="line">23:46:06.467231 IP localhost.irdmi &gt; localhost.49329: Flags [P.], seq 156:5324, ack 146, win 12754, options [nop,nop,TS val 178410643 ecr 178410643], length 5168</span><br><span class="line">23:46:06.467245 IP localhost.49329 &gt; localhost.irdmi: Flags [.], ack 5324, win 12593, options [nop,nop,TS val 178410643 ecr 178410643], length 0</span><br><span class="line">23:46:06.467313 IP localhost.irdmi &gt; localhost.49329: Flags [F.], seq 5324, ack 146, win 12754, options [nop,nop,TS val 178410643 ecr 178410643], length 0</span><br><span class="line">23:46:06.467331 IP localhost.49329 &gt; localhost.irdmi: Flags [.], ack 5325, win 12593, options [nop,nop,TS val 178410643 ecr 178410643], length 0</span><br><span class="line">23:46:06.468442 IP localhost.49329 &gt; localhost.irdmi: Flags [F.], seq 146, ack 5325, win 12593, options [nop,nop,TS val 178410644 ecr 178410643], length 0</span><br><span class="line">23:46:06.468479 IP localhost.irdmi &gt; localhost.49329: Flags [.], ack 147, win 12754, options [nop,nop,TS val 178410644 ecr 178410644], length 0</span><br></pre></td></tr></table></figure><p>通过结果能看到：</p><ol><li>客户端发起一个SYN报文，向服务器请求建立一个TCP连接。</li><li>服务器端返回一个SYN+ACK报文，表示服务器收到了客户端传来的请求，并同意与客户端建立TCP连接。</li><li>客户端返回一个ACK报文，表示已经知道服务器同意建立TCP连接，这时候双方开始通信。</li><li>客户端和服务器端不断地交换信息，接收报文，返回应答。</li><li>最后数据传输完毕，服务器发起一个FIN报文，表示要结束通信，客户端返回一个ACK应答，接着又发送一个FIN报文，最后服务器端返回一个ACK应答，此时连接过程结束。</li></ol><p>仔细一想，这个过程跟现实世界中的“打电话”是非常相似的，与之代替的不就是拨打电话、建立连接、确认应答、交换信息、关闭连接吗，我们经常说TCP是面向连接的也是这个道理。</p><p>现在再来看服务器端的状态，通过lsof命令来查看绑定8000端口的描述符信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">lsof -n -i:8000          </span><br><span class="line">COMMAND    PID   USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME</span><br><span class="line">python3.4 1128 tonnie    4u  IPv4 0x17036ae156ec58cf      0t0  TCP *:irdmi (LISTEN)</span><br></pre></td></tr></table></figure><p>通过结果可以观察到服务器的进程的一些信息，服务器进程处于<strong>LISTEN</strong>阶段，说明服务器处于保持着监听连接的状态：</p><p>现在用刚才的例子来解释TCP中状态迁移的概念，这时候，如果从客户端到来一个请求：</p><ol><li>服务器端接收到客户端的SYN报文，返回SYN+ACK报文，服务器端进入<strong>SYN_RCVD</strong>状态。</li><li>服务器端收到客户端返回的ACK应答后，连接建立，进入<strong>ESTABLISHED</strong>状态。</li><li>服务器端的数据传输完毕，给客户端发送FIN报文，进入<strong>FIN_WAIT_1</strong>状态。</li><li>服务器端接收到客户端返回的ACK应答后，进入<strong>FIN_WAIT_2</strong>状态。</li><li>服务器端接收到客户端的FIN报文，接着返回一个ACK应答，等待连接关闭，进入<strong>TIME_WAIT</strong>状态。</li><li>服务器端经过<strong>2MSL</strong>时间后进入<strong>CLOSED</strong>状态，此时连接关闭。</li></ol><p>至于客户端，在每个阶段也有各自的状态，下图表示了TCP状态迁移的过程：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/404.webp" data-original="/posts/47dff421/2.jpg" alt></p><p>下面来看TCP/IP的四层模型：</p><ol><li>应用层，在这一层上的有HTTP、DNS、FTP、SSH等。</li><li>传输层，在这一层上的有TCP、UDP等。</li><li>网络层，在这一层上的有IP、ARP等。</li><li>网络接口层，在这一层上的有以太网、PPP等。</li></ol><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/404.webp" data-original="/posts/47dff421/3.jpg" alt></p><p><strong>编者注</strong>:TCP/IP模型是由 OSI 模型演化而来，TCP/IP 模型将 OSI 模型由七层简化为五层（一开始为四层），应用层、表示层、会话层统一为应用层。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/404.webp" data-original="/posts/47dff421/8.jpg" alt></p><p>在上面的程序中，客户端与服务器端的通信都要经过这四个层来打交道。那么这段Python程序是如何操作连接的建立和关闭以及数据的传输呢？答案是<strong>通过socket提供的一系列方法</strong>。</p><p> </p><h2 id="socket">socket</h2><p><strong>socket是一种IPC方法，它使得同一主机或不同主机的应用程序能交换数据，socket在上图中处于第三层和第四层之间，所以可以把socket理解为在传输层和应用层之间的一组通信接口，或者是一个抽象的通信设备，应用程序借助socket就能方便地与其他应用程序进行交流。</strong></p><p>现在把客户端的代码简化为用socket表现的最简形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line">sock.send(<span class="string">b&#x27;GET / HTTP/1.1\r\nHost: 127.0.0.1:8000\r\n\r\n&#x27;</span>)</span><br><span class="line">data = sock.recv(<span class="number">4096</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure><p>是不是感觉跟上面TCP的连接过程十分相似？只是用代码的方式把这一具现过程给抽象表现出来罢了。</p><p>再看服务器端的最简化代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8000</span>))</span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">    cli_sock, cli_addr = sock.accept()</span><br><span class="line">    req = cli_sock.recv(<span class="number">4096</span>)</span><br><span class="line">    cli_sock.send(<span class="string">b&#x27;hello world&#x27;</span>)</span><br><span class="line">    cli_sock.close()</span><br></pre></td></tr></table></figure><p>过程同样很简单，总结一下它们的过程：</p><p><strong>服务器端：</strong></p><ol><li>调用<code>socket.socket</code>建立一个socket对象，指定<strong>域(domain)和协议(protocol)</strong>，此时一个文件描述符会绑定到这个socket对象。</li><li>调用<code>sock.setsockopt</code>设置这个socket选项，本例中把socket.SO_REUSEADDR设置为1，表示服务器端进程终止后，操作系统会为它绑定的端口保留一段时间，以防其他进程在它结束后抢占这个端口。</li><li>调用<code>sock.bind</code>为这个socket对象绑定到一个地址上，它需要一个主机地址和端口组成的元组作为参数。</li><li>调用<code>sock.listen</code>通知系统开始侦听来自客户端的连接，参数是在队列中最大的未决连接数量。</li><li>调用<code>sock.accept</code>阻塞调用直至返回一个元组，里面包含了用于与客户端进行对话的socket对象以及客户端的地址信息。</li><li>调用<code>cli_sock.recv</code>方法接受来自客户端发来的数据，在这个例子中拿到的是<code>b’GET / HTTP/1.1\r\nHost: 127.0.0.1:8000\r\n\r\n’</code>。</li><li>调用<code>cli_sock.send</code>方法把数据发送给客户端。</li><li>调用<code>cli_sock.close</code>结束连接。</li></ol><p><strong>客户端：</strong></p><ol><li>调用<code>socket.socket</code>建立一个socket对象，指定域(domain)和协议(protocol)，此时一个文件描述符会绑定到这个socket对象。</li><li>调用<code>sock.connect</code>通过指定的主机和端口连接到对端的服务器进程。</li><li>调用<code>sock.send</code>给服务器端发送数据。</li><li>调用<code>sock.recv</code>接收服务器端发来的数据。</li><li>调用<code>sock.close</code>关闭连接。</li></ol><p>socket的数据是通过内核维护的读写缓冲区来获取的，如下图中的表示：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/404.webp" data-original="/posts/47dff421/4.png" alt></p><p>每次从缓冲区写入或读入数据都会发起标准的系统调用，如：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">read</span><span class="params">(fd, buf, bufsize)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">write</span><span class="params">(fd, buf, bufwrite)</span>;</span><br></pre></td></tr></table></figure><p>来进行数据的写或读。当然对于大文件来说，执行多次read、write等系统调用的耗费是相当可观的，这时候就要用到<strong>sendfile</strong>系统调用：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/404.webp" data-original="/posts/47dff421/5.png" alt></p><h3 id="socket的域"><strong>socket的域</strong></h3><p>在上面的程序中我们建立socket对象都是使用了<strong>AF_INET</strong>这个参数，它表示这个socket是通过IPV4的方式进行通信的。</p><p>这种socket也被叫做<strong>Internet Domain Socket</strong>，它定义的地址形式是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">     <span class="type">in_addr_t</span> s_addr;     <span class="comment">//32位无符号整数。</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">     <span class="type">sa_family_t</span> sin_family;     <span class="comment">//AF_INET</span></span><br><span class="line">     <span class="type">in_port_t</span> sin_port;     <span class="comment">//端口号</span></span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>     <span class="comment">//ipv4地址</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">char</span> __pad[X];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>与之相对的，还有一种socket类型为<strong>Unix Domain Socket</strong>，它通过<strong>AF_UNIX</strong>这个参数来创建。它定义的地址形式是这样的：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">     <span class="type">sa_family_t</span> sun_family;     <span class="comment">//AF_UNIX</span></span><br><span class="line">     <span class="type">char</span> sun_path[<span class="number">108</span>];     <span class="comment">//socket路径名</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>当用Unix Domain Socket发起bind操作时，会在文件系统中创建一个条目，socket和路径名为一对一关系</strong>。一般来说，Unix Domain Socket只针对在同一主机下应用程序下的网络通信，<strong>它还有一个特点是可以使用目录权限来控制socket的访问</strong>。（例如我们使用mysql时用到的<code>mysql.sock</code>就是使用<code>unix domain sokcet</code>的载体）</p><h3 id="socket的协议"><strong>socket的协议</strong></h3><p>在protocol上我们使用了SOCK_STREAM，表示这是个流式套接字（即TCP），除此之外我们还可以把它指定为SOCK_DGRAM，表示这是个数据报套接字（即UDP）。</p><p><strong>TCP跟UDP的一些基本区别：</strong></p><blockquote><ol><li>TCP面向连接，UDP不面向连接。</li><li>TCP面向字节，不存在消息边界，可能存在粘包问题。UDP则面向报文。</li><li>TCP会尽力保证数据的可靠交付，而UDP默认不做保证。</li><li>TCP头部20字节，UDP头部8字节。</li></ol></blockquote><p><strong>编者注</strong>：如何理解1和3：</p><p>TCP协议是一种可靠的通信协议，<strong>它要求传输的过程是可靠的，因此需要经过三次握手的环节，确立连接关系之后，才可以进行传输</strong>。除此之外，TCP还有超时重传机制，还有排序的机制，有发送的窗口，有窗口大小等等，保证接收方接收到的就是发送方发送过去的。</p><p>UDP是一种不可靠的通信协议，它<strong>不需要建立连接</strong>，不需要对连接进行确认ACK的操作，不需要重传，不需要排序，它<strong>只管传输</strong>。</p><p>比如：</p><blockquote><p>“我给你讲一个关于TCP的笑话。”</p><p>“好的你给我讲一个关于TCP的笑话。”</p><p>“好的。”</p><p><strong>------确立连接关系，进行传输------</strong></p><p>“苟。这是第一个字。”</p><p>“第一个字收到，请发第二个字。”</p><p>“利。这是第二个字。”</p><p>“第二个字收到，请发第三个字。”</p><p>“国。这是第三个字。”</p><p><strong>------超时重传-------</strong></p><p>“国。这是第三个字。”</p><p>“第三个字收到，请发第四个字。”</p><p>“家……”</p><p>……</p><p>“我讲完了。”</p><p>“好的。我听完了。”</p><p>“好的。”</p><p><strong>------关闭连接------</strong></p><p>“我给你讲一个关于UDP的笑话。”</p><p>“咦我好像听见一个关笑P话的U……？咦这苟啊国家啊这什么什么之是啥玩意？我让应用层看看……应用层说应该是两句诗？”</p></blockquote><p>TCP 最适合用于对时序不太关心的，且要求高可靠性的应用程序。</p><ul><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E4%B8%87%E7%BB%B4%E7%BD%91&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1883510114%7D">万维网</a>（HTTP/HTTPS）</li><li>安全外壳（SSH）</li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1883510114%7D">电子邮件</a>（SMTP，IMAP / POP）</li><li>文件传输协议（FTP）</li></ul><p>UDP 最适合需要速度和效率的应用程序。</p><ul><li>串流影片</li><li>线上游戏</li><li>现场直播</li><li>域名系统（DNS）</li><li><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E4%BA%92%E8%81%94%E7%BD%91%E5%8D%8F%E8%AE%AE&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1883510114%7D">互联网协议</a>语音（VoIP）</li><li>普通文件传输协议（TFTP）</li></ul><h3 id="socket的通道"><strong>socket的通道</strong></h3><p>一般来说，socket的信道是双向的，即一个socket既能读又能写。有时候你需要建立一个半开放的socket，这时候就要使用socket的shutdown调用，它接收一个标记，其中：</p><ul><li><strong>SHUT_RD代表关闭连接的读端。</strong></li><li><strong>SHUT_WR代表关闭连接的写端。</strong></li><li><strong>SHUT_RDWR代表关闭连接的读端跟写端。</strong></li></ul><p>shutdown()不会显式关闭文件描述符，需要另外调用close()。</p><h3 id="socket服务器">socket服务器</h3><p>现在你应该对socket有一个大致的了解了，现在我们再来探讨一个socket服务器是怎么编写的。</p><p>再回到最开始的那段代码：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 -m http.server 8000</span><br><span class="line">Serving HTTP on 0.0.0.0 port 8000 ...</span><br></pre></td></tr></table></figure><p>我们直接用python内置的HTTPServer绑定了8000这个端口上。</p><p>查看python3的<code>http.server</code>所在的源码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">test</span>(<span class="params">HandlerClass=BaseHTTPRequestHandler,</span></span><br><span class="line"><span class="params">         ServerClass=HTTPServer, protocol=<span class="string">&quot;HTTP/1.0&quot;</span>, port=<span class="number">8000</span>, bind=<span class="string">&quot;&quot;</span></span>):</span><br><span class="line">    server_address = (bind, port)</span><br><span class="line"></span><br><span class="line">    HandlerClass.protocol_version = protocol</span><br><span class="line">    httpd = ServerClass(server_address, HandlerClass)</span><br><span class="line"></span><br><span class="line">    sa = httpd.socket.getsockname()</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Serving HTTP on&quot;</span>, sa[<span class="number">0</span>], <span class="string">&quot;port&quot;</span>, sa[<span class="number">1</span>], <span class="string">&quot;...&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        httpd.serve_forever()</span><br><span class="line">    <span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;\nKeyboard interrupt received, exiting.&quot;</span>)</span><br><span class="line">        httpd.server_close()</span><br><span class="line">        sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>当<code>http.server</code>以模块方式运行时会调用test方法，创建一个测试服务器，这个服务器默认使用了<strong>HTTPServer</strong>作为服务器的类，<strong>BaseHTTPRequestHandler</strong>作为请求的处理类。</p><p>看HTTPServer，也就是我们一开始使用的服务器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">HTTPServer</span>(socketserver.TCPServer):</span><br><span class="line"></span><br><span class="line">    allow_reuse_address = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">server_bind</span>(<span class="params">self</span>):</span><br><span class="line">        socketserver.TCPServer.server_bind(self)</span><br><span class="line">        host, port = self.socket.getsockname()[:<span class="number">2</span>]</span><br><span class="line">        self.server_name = socket.getfqdn(host)</span><br><span class="line">        self.server_port = port</span><br></pre></td></tr></table></figure><p>它继承了<strong>socketserver.TCPServer</strong>这个类，找到socketserver所在的源码，发现有一段注释，说明了几个服务器类之间的关系。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">+------------+</span><br><span class="line">| BaseServer |</span><br><span class="line">+------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">| TCPServer |-------&gt;| UnixStreamServer |</span><br><span class="line">+-----------+        +------------------+</span><br><span class="line">      |</span><br><span class="line">      v</span><br><span class="line">+-----------+        +--------------------+</span><br><span class="line">| UDPServer |-------&gt;| UnixDatagramServer |</span><br><span class="line">+-----------+        +--------------------+</span><br></pre></td></tr></table></figure><p>可以看到，<strong>TCPServer</strong>继承自<strong>BaseServer</strong>，而<strong>UDPServer</strong>又继承自<strong>TCPServer</strong>。</p><p>找到TCPServer这个类，可以看到它默认使用<code>socket.AF_INET(IPV4)</code>和<code>socket.SOCK_STREAM(TCP)</code>协议，并会在初始化的时候建立一个socket对象，注意这时候这个socket对象仅仅只是被创建处理，它还没有做任何的绑定。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TCPServer</span>(<span class="title class_ inherited__">BaseServer</span>):</span><br><span class="line">    address_family = socket.AF_INET</span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_STREAM</span><br><span class="line"></span><br><span class="line">    request_queue_size = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    allow_reuse_address = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, server_address, RequestHandlerClass, bind_and_activate=<span class="literal">True</span></span>):</span><br><span class="line">        BaseServer.__init__(self, server_address, RequestHandlerClass)</span><br><span class="line">        self.socket = socket.socket(self.address_family,</span><br><span class="line">                                    self.socket_type)</span><br><span class="line">        <span class="keyword">if</span> bind_and_activate:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.server_bind()</span><br><span class="line">                self.server_activate()</span><br><span class="line">            <span class="keyword">except</span>:</span><br><span class="line">                self.server_close()</span><br><span class="line">                <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>真正的绑定操作发生在<code>self.server_bind()</code>这行代码里，现在我们查看这个方法，它把socket对象绑定到<code>__init__</code>初始化中得到的地址上，并获取服务端的地址：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">server_bind</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">if</span> self.allow_reuse_address:</span><br><span class="line">        self.socket.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    self.socket.bind(self.server_address)</span><br><span class="line">    self.server_address = self.socket.getsockname()</span><br></pre></td></tr></table></figure><p>绑定后的监听动作则发生在<code>self.server_activate()</code>这行里，它紧跟着binding后进行，在这个方法里socket会在绑定的地址上监听到来的连接。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">server_activate</span>(<span class="params">self</span>):</span><br><span class="line">    self.socket.listen(self.request_queue_size)</span><br></pre></td></tr></table></figure><p>现在我们关心的是，如果现在有一个客户端发起了连接请求，服务器类会怎么处理呢？我们可以在<strong>TCPServer</strong>继承的<strong>BaseServer</strong>找到答案。</p><p>找到BaseServer的<code>serve_forever</code>方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">serve_forever</span>(<span class="params">self, poll_interval=<span class="number">0.5</span></span>):</span><br><span class="line">    self.__is_shut_down.clear()</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">not</span> self.__shutdown_request:</span><br><span class="line">            r, w, e = _eintr_retry(select.select, [self], [], [],</span><br><span class="line">                                    poll_interval)</span><br><span class="line">            <span class="keyword">if</span> self <span class="keyword">in</span> r:</span><br><span class="line">                self._handle_request_noblock()</span><br><span class="line"></span><br><span class="line">            self.service_actions()</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        self.__shutdown_request = <span class="literal">False</span></span><br><span class="line">        self.__is_shut_down.<span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><p>当服务器没被shutdown时，就会在while循环中用select去轮询活跃的socket，返回活跃的文件描述符，当检测到当前有可读事件时，就会调用<code>_handle_request_noblock</code>方法来处理socket：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_request</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> self.socket.accept()</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_handle_request_noblock</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        request, client_address = self.get_request()</span><br><span class="line">    <span class="keyword">except</span> OSError:</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    <span class="keyword">if</span> self.verify_request(request, client_address):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.process_request(request, client_address)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            self.handle_error(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br></pre></td></tr></table></figure><p>在<code>_handle_request_noblock</code>方法中，服务器拿到可读的socket（request），调用<em>process_request</em>方法来处理请求，当发生异常时调用<code>handle_error</code>处理错误，接着调用<code>shutdown_request</code>关闭请求。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request, client_address</span>):</span><br><span class="line">    self.finish_request(request, client_address)</span><br><span class="line">    self.shutdown_request(request)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">finish_request</span>(<span class="params">self, request, client_address</span>):</span><br><span class="line">    self.RequestHandlerClass(request, client_address, self)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">shutdown_request</span>(<span class="params">self, request</span>):</span><br><span class="line">    self.close_request(request)</span><br></pre></td></tr></table></figure><p>最后来看<code>process_request</code>方法做了什么事情，首先它调用<code>finish_request</code>方法，实例化出一个<code>RequestHandlerClass</code>（请求处理类）来处理本次请求，处理完成后调用<code>shutdown_request</code>方法来结束请求。</p><p>看看<strong>UDPServer</strong>，几乎是换汤不换药，只修改了TCPServer的几个重要的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UDPServer</span>(<span class="title class_ inherited__">TCPServer</span>):</span><br><span class="line">    allow_reuse_address = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    socket_type = socket.SOCK_DGRAM</span><br><span class="line"></span><br><span class="line">    max_packet_size = <span class="number">8192</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">get_request</span>(<span class="params">self</span>):</span><br><span class="line">        data, client_addr = self.socket.recvfrom(self.max_packet_size)</span><br><span class="line">        <span class="keyword">return</span> (data, self.socket), client_addr</span><br></pre></td></tr></table></figure><p>服务器类差不多就这样了，再来看RequestHandler。</p><p>先看最原始的<strong>BaseRequestHandler</strong>类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BaseRequestHandler</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, request, client_address, server</span>):</span><br><span class="line">        self.request = request</span><br><span class="line">        self.client_address = client_address</span><br><span class="line">        self.server = server</span><br><span class="line">        self.setup()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.handle()</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            self.finish()</span><br></pre></td></tr></table></figure><p>它接收一个请求(socket)作为参数，调用<code>self.setup()</code>建立用于读写的文件描述符，接着调用<code>self.handle()</code>来处理这次请求，最终调用<code>self.finish()</code>结束处理。</p><p>现在看<strong>StreamRequestHandler</strong>类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StreamRequestHandler</span>(<span class="title class_ inherited__">BaseRequestHandler</span>):</span><br><span class="line">    rbufsize = -<span class="number">1</span></span><br><span class="line">    wbufsize = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    timeout = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    disable_nagle_algorithm = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">setup</span>(<span class="params">self</span>):</span><br><span class="line">        self.connection = self.request</span><br><span class="line">        <span class="keyword">if</span> self.timeout <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            self.connection.settimeout(self.timeout)</span><br><span class="line">        <span class="keyword">if</span> self.disable_nagle_algorithm:</span><br><span class="line">            self.connection.setsockopt(socket.IPPROTO_TCP,</span><br><span class="line">                                       socket.TCP_NODELAY, <span class="literal">True</span>)</span><br><span class="line">        self.rfile = self.connection.makefile(<span class="string">&#x27;rb&#x27;</span>, self.rbufsize)</span><br><span class="line">        self.wfile = self.connection.makefile(<span class="string">&#x27;wb&#x27;</span>, self.wbufsize)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">finish</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> self.wfile.closed:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                self.wfile.flush()</span><br><span class="line">            <span class="keyword">except</span> socket.error:</span><br><span class="line">                <span class="keyword">pass</span></span><br><span class="line">        self.wfile.close()</span><br><span class="line">        self.rfile.close()</span><br></pre></td></tr></table></figure><p>在<code>setup</code>过程为socket建立了一个用于读的文件描述符以及一个用于写的文件描述符，在<code>finish</code>的过程中会把写缓冲区刷新，关闭读写两个文件描述符。</p><p>从上面得知<code>handle</code>是处理请求的核心过程，在<strong>BaseHTTPRequestHandler</strong>中是这样实现的，handler会处理一个socket请求，如果该请求是断续请求而且没有超时或异常的话，就会继续处理下一个请求（例如keep-alive、大数据传输）：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class BaseHTTPRequestHandler(socketserver.StreamRequestHandler):</span><br><span class="line">    def handle(self):</span><br><span class="line">        self.handle_one_request()</span><br><span class="line">        while not self.close_connection:</span><br><span class="line">            self.handle_one_request()</span><br></pre></td></tr></table></figure><p>其他部分太琐碎就不贴了，完成这一步后，服务器端就完成了一个来自客户端的请求的处理。</p><p>有的人还是可能觉得<strong>BaseHTTPRequestHandler</strong>和<strong>SimpleHTTPRequestHandler</strong>这类的处理类太挫太不灵活了，针对这个<code>http.server</code>模块还提供了一种处理类：<strong>CGIHTTPRequestHandler</strong>，它可以通过请求信息选择执行指向的cgi脚本。cgi虽然更灵活，但也有一些弊端，于是后面又有了各种方案：fastcgi、mod_python、wsgi…有兴趣的可以看<a href="https://link.zhihu.com/?target=https%3A//docs.python.org/3/howto/webservers.html" rel="external nofollow noreferrer">HOWTO Use Python in the web</a>。但在不复杂的情况下，这些自带的请求处理类也勉强够用了。</p><p>再谈到之前说的HTTPServer，在线上环境中一般没有人会这么傻，直接使用这个内置的HTTPServer的。因为它是单进程而且在请求的生命周期内都只能处理同一个请求，不过好在socketserver这个模块也提供了<strong>ThreadingMixIn</strong>以及<strong>ForkingMixIn</strong>，他们的目的是当一个请求到来时使用新建一个线程或一个进程去处理它。</p><p>使用方法十分简单，用<code>ThreadingMixIn</code>或<code>ForkingMixIn</code>与Server类组成混合类就行了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadingHTTPServer</span>(ThreadingMixIn, HTTPServer):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>通过ThreadingMixIn的源码确实可以看到它重写了<code>process_request</code>这个方法，它会覆盖混合类中Server类的<code>process_request</code>方法，当Server处理请求时就会调用到这个方法，在ThreadingMixIn的处理中，会新起一个线程来处理请求。这样一来，服务器的并发能力就比原来有了很大的提升了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ThreadingMixIn</span>:</span><br><span class="line">    daemon_threads = <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request_thread</span>(<span class="params">self, request, client_address</span>):</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.finish_request(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            self.handle_error(request, client_address)</span><br><span class="line">            self.shutdown_request(request)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">process_request</span>(<span class="params">self, request, client_address</span>):</span><br><span class="line">        t = threading.Thread(target = self.process_request_thread,</span><br><span class="line">                             args = (request, client_address))</span><br><span class="line">        t.daemon = self.daemon_threads</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>但有的人看到这里不一定会满意，一个请求一个线程，一百个请求一百个线程，一万个、十万个…还不得上天啊。在实际环境中，一般需要把线程控制在一定的数量内（例如线程池）以降低系统负载。</p><p>现在继续把目光转移到我们一开始讨论的socket上，再来扯IO模型的问题。</p><p>我们知道socket的输入需要两个阶段：</p><ol><li>等待数据准备好。</li><li>从内核向进程复制数据。</li></ol><p>因为等待的过程是阻塞式，所以我们上面使用多线程就是降低这个阻塞所带来的影响。</p><h3 id="五种IO模型：">五种IO模型：</h3><h4 id="阻塞IO模型"><strong>阻塞IO模型</strong></h4><p>recv-&gt;无数据报准备好-&gt;等待数据-&gt;数据报准备好-&gt;数据从内核复制到用户空间-&gt;复制完成-&gt;返回成功指示</p><p><strong>非阻塞IO模型</strong></p><p>recv-&gt;无数据报准备好-&gt;返回EWOULDBLOCK-&gt;recv-&gt;无数据报准备好-&gt;返回EWOULDBLOCK-&gt;数据报准备好-&gt;数据从内核复制到用户空间-&gt;复制完成-&gt;返回成功指示</p><p>特点：轮询操作，大量占用cpu时间。</p><h4 id="IO复用模型"><strong>IO复用模型</strong></h4><p>select-&gt;无数据报准备好-&gt;据报准备好-&gt;返回可读条件-&gt;recv-&gt;数据从内核复制到用户空间-&gt;复制完成-&gt;返回成功指示</p><h4 id="信号驱动模型"><strong>信号驱动模型</strong></h4><p>建立信号处理程序(sigaction)-&gt;递交SIGIO-&gt;recv-&gt;数据从内核复制到用户空间-&gt;复制完成-&gt;返回成功指示</p><h4 id="异步IO模型"><strong>异步IO模型</strong></h4><p>aio_read-&gt;无数据准备好-&gt;数据报准备好-&gt;数据从内核复制到用户空间-&gt;复制完成-&gt;递交aio_read中指定的信号</p><p>特点：直到数据复制完成产生信号的过程中进程都不被阻塞。</p><p>毫无疑问，我们从开始一直使用着阻塞的IO模型，这个效率是低下的。</p><p>为了获取更好的性能，我们一般采用IO多路复用模型，例如<em>select</em>和<em>poll</em>操作，运行进程同时检查多个文件描述符以找出它们任意一个是否可以进行IO操作，内核一旦发现进程指定的一个或多个IO条件就绪（输入准备被读取，或描述符能承接更多的输出），它就通知进程。</p><p>但前面说了<em>select</em>和<em>poll</em>有一个弊端就是他们在检查可用描述符的时候都是不断地遍历又遍历，当要监听的socket的文件描述符数量庞大时，性能会急剧下降，CPU消耗严重。</p><p>信号驱动模型比他们优越的地方在于，当有输入数据来到指定的文件描述符时，内核向请求数据的进程发送一个信号，进程可以处理其他任务，通过接收信号以获得通知。</p><p>而<em>epoll</em>则更进一步，用事件驱动的方式来监听fd，避免了信号处理的繁琐，在文件描述符上注册事件函数，由系统监视这些文件描述符，当在文件描述符可就绪时，内核通知应用进程。</p><p>在一些高并发的网络操作上，<em>epoll</em>的性能通常比<em>select</em>跟<em>poll</em>好几个数量级。</p><p>IO调用中有两个概念：</p><ul><li>水平触发：如果文件描述符可以非阻塞地进行io调用，此时认为他已经就绪）。（支持模型：select，poll，epoll等）</li><li>边缘触发：如果文件描述符自上次来的时候有了新的io活动（新的输入），触发通知。（支持模型：信号驱动，epoll等）</li></ul><p>在实际开发中要注意他们的区别，知道边缘触发为什么可能产生socket饥饿问题，怎么解决。</p><p>用一张图总结5个IO模型是这样的：</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/404.webp" data-original="/posts/47dff421/6.png" alt></p><p>使用多路IO复用模型能有效提高网络编程的质量。</p><p> </p><h3 id="HTTP"><strong>HTTP</strong></h3><p>现在再来看HTTP，<strong>HTTP是在TCP之上的无状态的协议，处于四层模型中的应用层，HTTP使用TCP来传输报文数据</strong>。</p><p>以浏览器输入一个网址打开为例，看HTTP的请求过程：</p><ol><li><strong>浏览器首先从URL中解析出主机名，端口等信息，URL的通用格式为：*://:@:/;?#*。</strong></li><li><strong>浏览器把主机名转换为IP地址（DNS）。</strong></li><li><strong>浏览器与服务器建立一条TCP连接。</strong></li><li><strong>浏览器在TCP连接上发送一条HTTP请求报文。</strong></li><li><strong>服务器在TCP连接上返回一条HTTP响应报文。</strong></li><li><strong>关闭连接，浏览器渲染文档。</strong></li></ol><p>HTTP的请求信息包括几个要素：</p><ol><li>请求行，例如*<strong>GET /index.html HTTP/1.1*</strong>，表示要请求index.html这个文件。</li><li>请求头（首部）。</li><li>空行。</li><li>消息体。</li></ol><p>例如在第一个例子中，我们向8000端口发起请求：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1 （请求行）</span><br><span class="line">Host: 127.0.0.1:8000 （请求头）</span><br></pre></td></tr></table></figure><p>会得到以下回应：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK （响应行）</span><br><span class="line">Content-Length: 5252</span><br><span class="line">Content-type: text/html; charset=utf-8</span><br><span class="line">Date: Tue, 21 Feb 2017 08:36:01 GMT</span><br><span class="line">Server: SimpleHTTP/0.6 Python/3.4.5</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;Directory listing for /&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;Directory listing for /&lt;/h1&gt;</span><br><span class="line">....</span><br></pre></td></tr></table></figure><p>HTTP的关键之处在于它的首部，HTTP的首部信息决定了客户端和服务器端能做什么事情。</p><h4 id="HTTP状态码"><strong>HTTP状态码</strong></h4><blockquote><ul><li><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%231xx.E6.B6.88.E6.81.AF" rel="external nofollow noreferrer">1xx消息</a>——请求已被服务器接收，继续处理</li><li><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%232xx.E6.88.90.E5.8A.9F" rel="external nofollow noreferrer">2xx成功</a>——请求已成功被服务器接收、理解、并接受</li><li><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%233xx.E9.87.8D.E5.AE.9A.E5.90.91" rel="external nofollow noreferrer">3xx重定向</a>——需要后续操作才能完成这一请求</li><li><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%234xx.E8.AF.B7.E6.B1.82.E9.94.99.E8.AF.AF" rel="external nofollow noreferrer">4xx请求错误</a>——请求含有词法错误或者无法被执行</li><li><a href="https://link.zhihu.com/?target=https%3A//zh.wikipedia.org/wiki/HTTP%E7%8A%B6%E6%80%81%E7%A0%81%235xx.E6.9C.8D.E5.8A.A1.E5.99.A8.E9.94.99.E8.AF.AF" rel="external nofollow noreferrer">5xx服务器错误</a>——服务器在处理某个正确请求时发生错误</li></ul></blockquote><h4 id="HTTP-DOM"><strong>HTTP &amp; DOM</strong></h4><p>DOM，又称Document Object Module，即文档对象模型。我们在写爬虫的时候通常都需要对html页面进行解析，这时候就需要dom解析器来对抓取的页面进行分析。</p><p>平时我们用lxml和BeautifulSoup用得爽了，但他们是怎么去解析html的呢？</p><p>在python的<em>html.parser</em>模块中就带了一个HTML解析器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> html.parser <span class="keyword">import</span> HTMLParser</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyHTMLParser</span>(<span class="title class_ inherited__">HTMLParser</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_starttag</span>(<span class="params">self, tag, attrs</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Encountered a start tag:&quot;</span>, tag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_endtag</span>(<span class="params">self, tag</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Encountered an end tag :&quot;</span>, tag)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">handle_data</span>(<span class="params">self, data</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Encountered some data  :&quot;</span>, data)</span><br><span class="line"></span><br><span class="line">parser = MyHTMLParser()</span><br><span class="line">parser.feed(<span class="string">&#x27;&lt;html&gt;&lt;head&gt;&lt;title&gt;Test&lt;/title&gt;&lt;/head&gt;&#x27;</span></span><br><span class="line">            <span class="string">&#x27;&lt;body&gt;&lt;h1&gt;Parse me!&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;&#x27;</span>)</span><br><span class="line"><span class="comment"># ------------------------------------------------------------------</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">Encountered a start tag: html</span></span><br><span class="line"><span class="string">Encountered a start tag: head</span></span><br><span class="line"><span class="string">Encountered a start tag: title</span></span><br><span class="line"><span class="string">Encountered some data  : Test</span></span><br><span class="line"><span class="string">Encountered an end tag : title</span></span><br><span class="line"><span class="string">Encountered an end tag : head</span></span><br><span class="line"><span class="string">Encountered a start tag: body</span></span><br><span class="line"><span class="string">Encountered a start tag: h1</span></span><br><span class="line"><span class="string">Encountered some data  : Parse me!</span></span><br><span class="line"><span class="string">Encountered an end tag : h1</span></span><br><span class="line"><span class="string">Encountered an end tag : body</span></span><br><span class="line"><span class="string">Encountered an end tag : html</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>可以通过它的源码中来观察dom是如何被解析的。</p><h4 id="HTTP-RESTful"><strong>HTTP &amp; RESTful</strong></h4><p>推荐阅读：<a href="https://link.zhihu.com/?target=http%3A//blog.jobbole.com/41233/" rel="external nofollow noreferrer">RESTful API 设计最佳实践</a></p><h4 id="DNS"><strong>DNS</strong></h4><p>主机到IP的转换通常要经过DNS查询，DNS是一个庞大的分布式数据库，它将主机名组织在一个层级的空间中，一个节点的域名由该节点到根的路径所有节点组成的名字连接而成。</p><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/404.webp" data-original="/posts/47dff421/7.png" alt></p><p>使用dnspython包可以方便地进行dns查询：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> dns.resolver</span><br><span class="line"></span><br><span class="line">domain = <span class="string">&#x27;baidu.com&#x27;</span></span><br><span class="line">A = dns.resolver.query(domain, <span class="string">&#x27;A&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> answer <span class="keyword">in</span> A.response.answer:</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> answer.items:</span><br><span class="line">        <span class="built_in">print</span>(item.address)</span><br></pre></td></tr></table></figure><h4 id="FTP"><strong>FTP</strong></h4><p>在python世界里，使用ftp非常简单，只需要使用内置的ftplib模块就可以使用ftp协议对远端机器进行操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ftplib <span class="keyword">import</span> FTP</span><br><span class="line"><span class="keyword">with</span> FTP(<span class="string">&quot;ftp1.at.proftpd.org&quot;</span>) <span class="keyword">as</span> ftp:</span><br><span class="line">    ftp.login()</span><br><span class="line">    ftp.<span class="built_in">dir</span>()</span><br><span class="line"><span class="string">&#x27;230 Anonymous login ok, restrictions apply.&#x27;</span></span><br><span class="line">dr-xr-xr-x   <span class="number">9</span> ftp      ftp           <span class="number">154</span> May  <span class="number">6</span> <span class="number">10</span>:<span class="number">43</span> .</span><br><span class="line">dr-xr-xr-x   <span class="number">9</span> ftp      ftp           <span class="number">154</span> May  <span class="number">6</span> <span class="number">10</span>:<span class="number">43</span> ..</span><br><span class="line">dr-xr-xr-x   <span class="number">5</span> ftp      ftp          <span class="number">4096</span> May  <span class="number">6</span> <span class="number">10</span>:<span class="number">43</span> CentOS</span><br><span class="line">dr-xr-xr-x   <span class="number">3</span> ftp      ftp            <span class="number">18</span> Jul <span class="number">10</span>  <span class="number">2008</span> Fedora</span><br></pre></td></tr></table></figure><h4 id="XML-RPC"><strong>XML-RPC</strong></h4><p>建立一个XML-RPC的服务器跟客户端同样很简单。</p><p>Server</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xmlrpc.server <span class="keyword">import</span> SimpleXMLRPCServer</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ExampleService</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">getData</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;42&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">currentTime</span>:</span><br><span class="line"><span class="meta">        @staticmethod</span></span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">getCurrentTime</span>():</span><br><span class="line">            <span class="keyword">return</span> datetime.datetime.now()</span><br><span class="line"></span><br><span class="line">server = SimpleXMLRPCServer((<span class="string">&quot;localhost&quot;</span>, <span class="number">8000</span>))</span><br><span class="line">server.register_function(<span class="built_in">pow</span>)</span><br><span class="line">server.register_function(<span class="keyword">lambda</span> x,y: x+y, <span class="string">&#x27;add&#x27;</span>)</span><br><span class="line">server.register_instance(ExampleService(), allow_dotted_names=<span class="literal">True</span>)</span><br><span class="line">server.register_multicall_functions()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Serving XML-RPC on localhost port 8000&#x27;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    server.serve_forever()</span><br><span class="line"><span class="keyword">except</span> KeyboardInterrupt:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;\nKeyboard interrupt received, exiting.&quot;</span>)</span><br><span class="line">    sys.exit(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>Client</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> xmlrpc.client <span class="keyword">import</span> ServerProxy, MultiCall</span><br><span class="line">server = ServerProxy(<span class="string">&quot;http://localhost:8000&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(server.currentTime.getCurrentTime())</span><br><span class="line"><span class="keyword">except</span> Error <span class="keyword">as</span> v:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ERROR&quot;</span>, v)</span><br><span class="line"></span><br><span class="line">multi = MultiCall(server)</span><br><span class="line">multi.getData()</span><br><span class="line">multi.<span class="built_in">pow</span>(<span class="number">2</span>,<span class="number">9</span>)</span><br><span class="line">multi.add(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">for</span> response <span class="keyword">in</span> multi():</span><br><span class="line">        <span class="built_in">print</span>(response)</span><br><span class="line"><span class="keyword">except</span> Error <span class="keyword">as</span> v:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;ERROR&quot;</span>, v)</span><br></pre></td></tr></table></figure><h1>参考：</h1><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.liaoxuefeng.com/">廖雪峰的博客</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.runoob.com/python3">菜鸟</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/tonnie">知乎-四条鱼</a></p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zwn2001.space">洛雪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwn2001.space/posts/47dff421.html">https://zwn2001.space/posts/47dff421.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zwn2001.space" target="_blank">ZWN's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%BD%AC%E8%BD%BD%E4%B8%8E%E6%B1%87%E6%80%BB/">转载与汇总</a><a class="post-meta__tags" href="/tags/Python/">Python</a></div><div class="post_share"><div class="social-share" data-image="/img/cover3/6-min.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/352a06d7.html" title="数据结构课设:霍夫曼编码译码"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/1-min.jpg" onerror='onerror=null,src="/img/404.webp"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构课设:霍夫曼编码译码</div></div></a></div><div class="next-post pull-right"><a href="/posts/cb043cd6.html" title="Python基础语法记录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/10-min.jpg" onerror='onerror=null,src="/img/404.webp"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Python基础语法记录</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/6d38cc46.html" title="Python小抄"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/33.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-06</div><div class="title">Python小抄</div></div></a></div><div><a href="/posts/cb043cd6.html" title="Python基础语法记录"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/10-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-11</div><div class="title">Python基础语法记录</div></div></a></div><div><a href="/posts/d76fdb53.html" title="CAS指令与MESI缓存一致性协议"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/17.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-13</div><div class="title">CAS指令与MESI缓存一致性协议</div></div></a></div><div><a href="/posts/7d689df3.html" title="How-To-Use-Hexo Hexo建站小教程"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover1/34.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-20</div><div class="title">How-To-Use-Hexo Hexo建站小教程</div></div></a></div><div><a href="/posts/86e45e2.html" title="KalmanFilters-theory-and-demo"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/27.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-09</div><div class="title">KalmanFilters-theory-and-demo</div></div></a></div><div><a href="/posts/87541845.html" title="JetBrains系列常用快捷键汇总"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/4-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-02</div><div class="title">JetBrains系列常用快捷键汇总</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/favicon.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">洛雪</div><div class="author-info__description">我虽无意逐鹿，却知苍生苦楚</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">130</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">39</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ZWN2001"><i class="fab fa-github"></i><span>我的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZWN2001" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">新域名：www.zwn2001.space，有效期：10年。https://www.zwn-blog.xyz已过期。访问时建议科学上网，否则博客内公式渲染会出现问题且速度慢。Ctrl+shift+r可强制刷新网站以避免浏览器缓存造成的更新不及时</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B1%BB%E5%92%8C%E5%AE%9E%E4%BE%8B"><span class="toc-number">1.1.</span> <span class="toc-text">类和实例</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#self%E4%BB%A3%E8%A1%A8%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B%EF%BC%8C%E8%80%8C%E9%9D%9E%E7%B1%BB"><span class="toc-number">1.1.1.</span> <span class="toc-text">self代表类的实例，而非类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B1%BB%E5%B1%9E%E6%80%A7%E4%B8%8E%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.</span> <span class="toc-text">类属性与方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E5%B1%9E%E6%80%A7"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">类的私有属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E7%9A%84%E7%A7%81%E6%9C%89%E6%96%B9%E6%B3%95"><span class="toc-number">1.1.2.2.</span> <span class="toc-text">类的私有方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%95%E4%B8%8B%E5%88%92%E7%BA%BF%E3%80%81%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E3%80%81%E5%A4%B4%E5%B0%BE%E5%8F%8C%E4%B8%8B%E5%88%92%E7%BA%BF%E8%AF%B4%E6%98%8E%EF%BC%9A"><span class="toc-number">1.1.2.3.</span> <span class="toc-text">单下划线、双下划线、头尾双下划线说明：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%B0%81%E8%A3%85"><span class="toc-number">1.1.3.</span> <span class="toc-text">数据封装</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#python%E5%AF%B9%E8%B1%A1%E9%94%80%E6%AF%81-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="toc-number">1.2.</span> <span class="toc-text">python对象销毁(垃圾回收)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E5%92%8C%E5%A4%9A%E6%80%81"><span class="toc-number">1.3.</span> <span class="toc-text">继承和多态</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80-vs-%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80"><span class="toc-number">1.3.1.</span> <span class="toc-text">静态语言 vs 动态语言</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7%E5%92%8C%E7%B1%BB%E5%B1%9E%E6%80%A7"><span class="toc-number">1.4.</span> <span class="toc-text">实例属性和类属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-slots"><span class="toc-number">1.4.1.</span> <span class="toc-text">使用__slots__</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8-property"><span class="toc-number">1.4.2.</span> <span class="toc-text">使用@property</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">1.5.</span> <span class="toc-text">枚举类</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">IO</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E8%AF%BB%E5%86%99"><span class="toc-number">2.1.</span> <span class="toc-text">文件读写</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%93%E5%BC%80%E5%92%8C%E5%85%B3%E9%97%AD%E6%96%87%E4%BB%B6"><span class="toc-number">2.1.1.</span> <span class="toc-text">打开和关闭文件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#open-%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.1.</span> <span class="toc-text">open 函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="toc-number">2.2.</span> <span class="toc-text">File对象的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#write-%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.1.</span> <span class="toc-text">write()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#read-%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.2.</span> <span class="toc-text">read()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#close-%E6%96%B9%E6%B3%95"><span class="toc-number">2.2.3.</span> <span class="toc-text">close()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%A6%EF%BC%9A"><span class="toc-number">2.2.4.</span> <span class="toc-text">另：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">2.2.4.1.</span> <span class="toc-text">字符编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#StringIO%E5%92%8CBytesIO"><span class="toc-number">2.2.4.2.</span> <span class="toc-text">StringIO和BytesIO</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#StringIO"><span class="toc-number">2.2.4.2.1.</span> <span class="toc-text">StringIO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#BytesIO"><span class="toc-number">2.2.4.2.2.</span> <span class="toc-text">BytesIO</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E5%AE%9A%E4%BD%8D"><span class="toc-number">2.2.4.3.</span> <span class="toc-text">文件定位</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%87%8D%E5%91%BD%E5%90%8D%E5%92%8C%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6"><span class="toc-number">2.3.</span> <span class="toc-text">重命名和删除文件</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#rename-%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.1.</span> <span class="toc-text">rename() 方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#remove-%E6%96%B9%E6%B3%95"><span class="toc-number">2.3.2.</span> <span class="toc-text">remove()方法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Python%E9%87%8C%E7%9A%84%E7%9B%AE%E5%BD%95%EF%BC%9A"><span class="toc-number">2.4.</span> <span class="toc-text">Python里的目录：</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mkdir-%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.1.</span> <span class="toc-text">mkdir()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#chdir-%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.2.</span> <span class="toc-text">chdir()方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#getcwd-%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">2.4.3.</span> <span class="toc-text">getcwd()方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rmdir-%E6%96%B9%E6%B3%95"><span class="toc-number">2.4.4.</span> <span class="toc-text">rmdir()方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">网络：从0到1，Python网络编程的入门之路</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%EF%BC%9ATCP-IP%E7%9A%84%E5%B0%8F%E4%BE%8B%E5%AD%90"><span class="toc-number">3.1.</span> <span class="toc-text">网络请求过程：TCP&#x2F;IP的小例子</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#socket"><span class="toc-number">3.2.</span> <span class="toc-text">socket</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E7%9A%84%E5%9F%9F"><span class="toc-number">3.2.1.</span> <span class="toc-text">socket的域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E7%9A%84%E5%8D%8F%E8%AE%AE"><span class="toc-number">3.2.2.</span> <span class="toc-text">socket的协议</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E7%9A%84%E9%80%9A%E9%81%93"><span class="toc-number">3.2.3.</span> <span class="toc-text">socket的通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#socket%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-number">3.2.4.</span> <span class="toc-text">socket服务器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94%E7%A7%8DIO%E6%A8%A1%E5%9E%8B%EF%BC%9A"><span class="toc-number">3.2.5.</span> <span class="toc-text">五种IO模型：</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9EIO%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.5.1.</span> <span class="toc-text">阻塞IO模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#IO%E5%A4%8D%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.5.2.</span> <span class="toc-text">IO复用模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%A9%B1%E5%8A%A8%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.5.3.</span> <span class="toc-text">信号驱动模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%AD%A5IO%E6%A8%A1%E5%9E%8B"><span class="toc-number">3.2.5.4.</span> <span class="toc-text">异步IO模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#HTTP"><span class="toc-number">3.2.6.</span> <span class="toc-text">HTTP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP%E7%8A%B6%E6%80%81%E7%A0%81"><span class="toc-number">3.2.6.1.</span> <span class="toc-text">HTTP状态码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-DOM"><span class="toc-number">3.2.6.2.</span> <span class="toc-text">HTTP &amp; DOM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-RESTful"><span class="toc-number">3.2.6.3.</span> <span class="toc-text">HTTP &amp; RESTful</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#DNS"><span class="toc-number">3.2.6.4.</span> <span class="toc-text">DNS</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#FTP"><span class="toc-number">3.2.6.5.</span> <span class="toc-text">FTP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XML-RPC"><span class="toc-number">3.2.6.6.</span> <span class="toc-text">XML-RPC</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">参考：</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a18275b6.html" title="2023数据库课设经验分享"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/14-min.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="2023数据库课设经验分享"></a><div class="content"><a class="title" href="/posts/a18275b6.html" title="2023数据库课设经验分享">2023数据库课设经验分享</a><time datetime="2023-08-18T08:01:49.000Z" title="发表于 2023-08-18 16:01:49">2023-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/7328da20.html" title="删除gitignore修改前提交的大文件"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover3/26.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="删除gitignore修改前提交的大文件"></a><div class="content"><a class="title" href="/posts/7328da20.html" title="删除gitignore修改前提交的大文件">删除gitignore修改前提交的大文件</a><time datetime="2023-07-10T13:50:49.000Z" title="发表于 2023-07-10 21:50:49">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/54161dd4.html" title="记一次博客公式渲染排查"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/6-min.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="记一次博客公式渲染排查"></a><div class="content"><a class="title" href="/posts/54161dd4.html" title="记一次博客公式渲染排查">记一次博客公式渲染排查</a><time datetime="2023-06-23T01:21:51.000Z" title="发表于 2023-06-23 09:21:51">2023-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/88a0f6f.html" title="A-star路径规划"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/24-min.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="A-star路径规划"></a><div class="content"><a class="title" href="/posts/88a0f6f.html" title="A-star路径规划">A-star路径规划</a><time datetime="2023-06-19T13:17:15.000Z" title="发表于 2023-06-19 21:17:15">2023-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/14ee3806.html" title="PID算法"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/img/cover2/12-min.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="PID算法"></a><div class="content"><a class="title" href="/posts/14ee3806.html" title="PID算法">PID算法</a><time datetime="2023-06-17T12:06:22.000Z" title="发表于 2023-06-17 20:06:22">2023-06-17</time></div></div></div></div></div></div></main><footer id="footer" style="background:0 0"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();" rel="external nofollow noreferrer"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());" rel="external nofollow noreferrer"><i class="iconfont icon-baidu"></i><span>搜索</span></a><a class="rightMenu-item" href="javascript:rmf.searchinThisPage();" rel="external nofollow noreferrer"><i class="fas fa-search"></i><span>站内搜索</span></a><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()" rel="external nofollow noreferrer"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()" rel="external nofollow noreferrer"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.translate();" rel="external nofollow noreferrer"><i class="iconfont icon-fanti"></i><span>繁简转换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="javascript:fullScreen();" rel="external nofollow noreferrer"><i class="fas fa-expand"></i><span>进入全屏</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://unpkg.com/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://unpkg.com/katex/dist/katex.min.css"><script src="https://unpkg.com/katex/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach(a=>{btf.wrap(a,"div",{class:"katex-wrap"})})</script><script>function getGiscusTheme(e){return"dark"===e?"dark":"light"}function loadGiscus(){var e,t=Object.assign({src:"https://giscus.app/client.js","data-repo":"ZWN2001/ZWN2001.github.io","data-repo-id":"R_kgDOGH1XWg","data-category-id":"DIC_kwDOGH1XWs4CXnHJ","data-mapping":"pathname","data-theme":getGiscusTheme(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0},{"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous","data-mapping":"og:title","data-input-position":"top","data-category":"Announcements"}),a=document.createElement("script");for(e in t)a.setAttribute(e,t[e]);document.getElementById("giscus-wrap").insertAdjacentElement("afterbegin",a)}function changeGiscusTheme(e){var t;e={setConfig:{theme:getGiscusTheme(e)}},(t=document.querySelector("iframe.giscus-frame"))&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}function loadOtherComment(){loadGiscus()}btf.addModeChange("giscus",changeGiscusTheme),btf.loadComment(document.getElementById("giscus-wrap"),loadGiscus)</script></div><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script type="text/javascript" src="/js/memos/waterfall.min.js"></script><script type="text/javascript" src="/js/memos/project.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax src="https://fastly.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var t=document.getElementById("recent-posts");t&&"/"==location.pathname&&(console.log("已挂载github calendar"),t.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://my-hexo-github-calender.vercel.app/api/?ZWN2001",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"ZWN2001")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style></style><script data-pjax>var parent,child;document.getElementById("recent-posts")&&"/"===location.pathname&&(parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/编程知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 洛雪の编程知识 (17)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/实用知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 洛雪の实用知识 (12)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/学习-课外拓展/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 洛雪の学习-课外拓展 (20)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/学习-课内知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 洛雪の学习-课内知识 (57)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://zwn2001.space/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>',console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child))</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#b30070}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style><style>[bg-lazy]{background-image:none!important;background-color:#eee!important}</style><script>window.imageLazyLoadSetting={isSPA:!1,preloadRatio:1,processImages:null}</script><script>window.addEventListener("load",function(){var t=/\.(gif|jpg|jpeg|tiff|png)$/i,r=/^data:image\/[a-z]+;base64,/;Array.prototype.slice.call(document.querySelectorAll("img[data-original]")).forEach(function(a){var e=a.parentNode;"A"===e.tagName&&(e.href.match(t)||e.href.match(r))&&(e.href=a.dataset.original)})})</script><script>!function(r){r.imageLazyLoadSetting.processImages=t;var e=r.imageLazyLoadSetting.isSPA,n=r.imageLazyLoadSetting.preloadRatio||1,c=a();function a(){var t=Array.prototype.slice.call(document.querySelectorAll("img[data-original]")),e=Array.prototype.slice.call(document.querySelectorAll("[bg-lazy]"));return t.concat(e)}function t(){e&&(c=a());for(var t,o=0;o<c.length;o++)0<=(t=(t=c[o]).getBoundingClientRect()).bottom&&0<=t.left&&t.top<=(r.innerHeight*n||document.documentElement.clientHeight*n)&&function(){var t,e,n,a=c[o],i=function(){c=c.filter(function(t){return a!==t}),r.imageLazyLoadSetting.onImageLoaded&&r.imageLazyLoadSetting.onImageLoaded(a)};(t=a).hasAttribute("bg-lazy")?(t.removeAttribute("bg-lazy"),i()):(e=new Image,n=t.getAttribute("data-original"),e.onload=function(){t.src=n,t.removeAttribute("data-original"),i()},t.src!==n&&(e.src=n))}()}function i(){clearTimeout(t.tId),t.tId=setTimeout(t,500)}t(),document.addEventListener("scroll",i),r.addEventListener("resize",i),r.addEventListener("orientationchange",i)}(this)</script></body></html>