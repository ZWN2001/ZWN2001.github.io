<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>操作系统os-chapter1-6 | ZWN's blog</title><meta name="author" content="洛雪"><meta name="copyright" content="洛雪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="操作系统"><meta property="og:type" content="article"><meta property="og:title" content="操作系统os-chapter1-6"><meta property="og:url" content="https://zwn2001.space/posts/os-note1-6/index.html"><meta property="og:site_name" content="ZWN&#39;s blog"><meta property="og:description" content="操作系统"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zwn2001.space/img/cover3/13-min.jpg"><meta property="article:published_time" content="2022-06-28T10:40:26.000Z"><meta property="article:modified_time" content="2023-08-27T12:12:18.878Z"><meta property="article:author" content="洛雪"><meta property="article:tag" content="操作系统"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://zwn2001.space/img/cover3/13-min.jpg"><link rel="shortcut icon" href="/img/favicon.webp"><link rel="canonical" href="https://zwn2001.space/posts/os-note1-6/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:-1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:{limitDay:200,position:"top",messagePrev:"距离上次更新已经过去",messageNext:"天啦！注意内容可能过时。"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://unpkg.com/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://unpkg.com/flickr-justified-gallery/dist/fjGallery.css"}},isPhotoFigcaption:!0,islazyload:!0,isAnchor:!0,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"操作系统os-chapter1-6",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-08-27 20:12:18"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/rightmenu.css"><link rel="stylesheet" href="/css/loadimg.css"><link rel="stylesheet" href="/css/project.css"><link type="text/html" rel="stylesheet" href="/css/wide_screen.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"><style>#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags:before{content:"\A";white-space:pre}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags>.article-meta__separator{display:none}</style><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" src="/img/favicon.webp"><div class="loading-image-dot"></div><div id="loading-percentage"></div></div></div><script>const loadingPercentage=document.getElementById("loading-percentage");loadingPercentage.style.color="black";let loadingPercentageTimer=setInterval(function(){var e=document.querySelector(".pace-progress");e&&(e=e.getAttribute("data-progress-text"))!==loadingPercentage.textContent&&"60%"===(loadingPercentage.textContent=e)&&clearInterval(loadingPercentageTimer)},100);const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",()=>{preloader.endLoading()})</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">139</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/cover3/13-min.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="ZWN's blog"><span class="site-name">ZWN's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">操作系统os-chapter1-6</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-06-28T10:40:26.000Z" title="发表于 2022-06-28 18:40:26">2022-06-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-08-27T12:12:18.878Z" title="更新于 2023-08-27 20:12:18">2023-08-27</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0-%E8%AF%BE%E5%86%85%E7%9F%A5%E8%AF%86/">学习-课内知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">43.8k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>134分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote><p>期末90，考得还行吧。hmb出卷真的要命，有一道大题让你自己设计二级页表系统，我计组忘净了直接寄。</p></blockquote><h1>第一章</h1><h2 id="什么是操作系统">什么是操作系统</h2><p>操作系统是一组<strong>控制和管理计算机硬件和软件资源</strong>、合理地对各类作业(程序）进行<strong>调度</strong>，以及<strong>方便用户</strong>的<strong>程序</strong>集合。操作系统是用户和计算机的接口，同时也是计算机硬件和其他软件的接口。</p><p>书上定义为操作系统是一直运行在计算机上的程序（通常称为内核）</p><p><strong>操作系统最基本的两个特征：并发和共享</strong></p><h3 id="计算机系统组成">计算机系统组成</h3><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="1.png" style="zoom:60%"><h2 id="计算机系统的组织">计算机系统的组织</h2><h3 id="计算机系统操作">计算机系统操作</h3><h4 id="计算机启动过程">计算机启动过程</h4><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/60929600">https://zhuanlan.zhihu.com/p/60929600</a></p><blockquote><p>其实电脑启动的过程是一个十分完善的硬件自检的过程，在加电自检的那几秒钟里面计算机可以完成上百道工序，下面就由我来与大家介绍一下这个过程。</p><p>第一步：在主板接通电源之后，系统就由POST(Power On Self Test,<strong>上电自检</strong>)开始自检，在我们刚刚接通电源的时候，整个系统由BIOS控制，电压还不太稳定（这个过程非常短暂，一般只有几毫秒，这个时候电压的稳定完全依靠主板和电源内部的滤波电容进行），主板芯片组会向CPU发出reset的命令让CPU开始初始化，同时主板芯片组等待电源发出POWE GOOD命令，一旦电源发出POWER GOOD命令，主板芯片组会马上停止reset命令的发出（如果是手动reset那么松开reset按钮时就会停止发出命令），这时候CPU会马上从地址FFFFF0H或FFFF0H开始执行寻址指令（<strong>这个地址是在BIOS内而不再内存里面</strong>），在这个地址中无论是AMI BIOS还是Award BIOS，<strong>在这个地址中都会存储一条跳转命令，直接跳转到系统BIOS中真正的启动代码处，这个时候BIOS就会进行到第二个步骤POST</strong>。</p><p>第二步：<strong>系统BIOS的启动代码首先要做的事情就是POST</strong>，<strong>POST的主要任务就是在检测系统中的一些关键设备是否存在和正常工作</strong>。由于POST在初始化显示卡之前，因此如果POST过程中出现任何的被BIOS认为的致命错误，比如没有找到内存或者说内存错误之类的，POST会通过主板上再带的扬声器来发送长短和数量不等的警报声以传递错误信息，如果在正常情况下，POST会进行的非常快，我们是难以感觉到这个过程的。</p><p>第三步：在这一步，<strong>系统BIOS会找到显卡</strong>，存放显卡BIOS的ROM通常地址在C0000H处，<strong>系统BIOS找到显卡BIOS之后调用它的代码</strong>，由于显卡生产商的不同，所以显卡的初始化是由显卡BIOS来完成的，所以不同显卡厂商的界面也是不太一样的。</p><p>第四步：<strong>硬盘引导启动</strong>：这一步是根据BIOS设置的启动顺序进行，按照顺序将控制权依次转移给列表中的存储设备，无论是哪个设备，计算机都会依次读取这个设备的第一个扇区，即第一个512字节，如果这512个字节的最后两个字节是0x55和0xAA，表明这个设备可以用于启动；如果不是，表明设备不能用于启动，控制权于是被转交给&quot;启动顺序&quot;中的下一个设备，这最前面的512个字节就被叫做主引导记录（Master boot record，缩写为MBR）。</p><p>其中主引导记录的主要作用就是引导硬盘到指定的位置来加载操作系统，一般分为三个部分：第1-446字节：调用操作系统的机器码；第447-510字节：分区表（Partition table）；第511-512字节：主引导记录签名（0x55和0xAA）。</p><p>其中分区表的作用是将硬盘分为若干个分区，硬盘分区的好处就是在于可以在不同的分区中安装不同的操作系统，但是主引导记录必须知道每个操作系统具体是在哪个分区。</p><p>主引导记录的大小总共只有64个字节，其中分为四项，每项16个字节，也就是说，每块硬盘只有4个主分区，只能安装4套操作系统。每个主分区总共16个字节，分为6个部分：</p><ul><li><p>第一个字节：如果为0x80，就表示该主分区是激活分区，控制权要转交给这个分区。四个主分区里面只能有一个是激活的。</p></li><li><p>第二至四个字节：表示主分区第一个扇区的物理位置（柱面、磁头、扇区号等等）。</p></li><li><p>第五个字节：表示主分区类型（具体内容比较多在这里就不再过多阐述）。</p></li><li><p>第六只八个字节：表示主分区的最后一个扇区的物理位置。</p></li><li><p>第九至十二个字节：表示主分区第一个扇区的逻辑地址。</p></li><li><p>第十三至十六个字节：表示主分区的扇区总数。</p></li></ul><p>最后一条规定了 主分区的长度，也就是说，主分区的长度最大不能大于2^32，所以，每个分区512个字节的话，整块硬盘的大小不会超过2TB，所以提高硬盘大小只有两个办法：一是提高硬盘扇区总数；二是提高每个扇区的字节数。</p><p>第五步：<strong>硬盘启动</strong>。<strong>这个时候系统会优先从四个主分区里面的那个被激活的分区来启动，叫做引导卷启动</strong>（Volume boot record，缩写为VBR），卷引导记录的主要作用是，告诉计算机，操作系统在这个分区里的位置。<strong>然后，计算机就会加载操作系统了</strong>。但是如果系统被安装在了拓展分区和逻辑分区中，就要通过启动管理器来启动，在这种情况下，计算机读取&quot;主引导记录&quot;前面446字节的机器码之后，不再把控制权转交给某一个分区，而是运行事先安装的&quot;启动管理器&quot;（boot loader），由用户选择启动哪一个操作系统。</p><p>第六步：<strong>内核加载启动</strong>。这个时候计算机的操作系统位置已经确定，就要进行内核加载。在内核加载阶段，Ntldr 将首先加载Windows内核 Ntoskrnl.exe 和 硬件抽象层 (HAL). HAL 有点类似于嵌入式操作系统下的BSP（Borad support package)，这个抽象层对硬件底层的特性进行隔离，对操作系统提供统一的调用接口，操作系统移植到不同硬件时只要改变相应的 HAL 就可以，其它的内核组件不需要修改，这个是操作系统通常的设计模式。</p><p>接下来Ntldr 从HKEY_LOCAL_ MACHINE\SYSTEM\CurrentControlSet 下读取这台机器安装的驱动程序，然后依次加载驱动程序。驱动程序加载完成后，Windows做如下设置：</p><ol><li><p>创建系统环境变量</p></li><li><p>启动 win32.sys ，这个是Windows子系统的内核模式部分。</p></li><li><p>启动 csrss.exe，这个是Windows子系统的用户模式部分。</p></li><li><p>启动 winlogon.exe</p></li><li><p>创建虚拟内存页面文件</p></li><li><p>对一些必要的文件进行改名</p></li></ol></blockquote><h4 id="中断与陷阱">中断与陷阱</h4><p><strong>操作系统是中断驱动的（interrupt driven）。因为事件的发生通常通过软件或硬件中断来表示。</strong></p><p>硬件<strong>通过系统总线向CPU发信号</strong>来触发，软件通过执行特别操作如<strong>系统调用</strong>（system call）触发中断，这种中断通常被称为<strong>陷阱</strong>（trap）。<strong>硬件中断具有随机性与突发性，而陷阱是程序安排好的</strong>。</p><p>CPU如何处理中断：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="2.png" style="zoom:100%"><h3 id="存储结构">存储结构</h3><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="3.png" style="zoom:120%"><p><strong>主存（内存：main memory）是CPU唯一能直接访问的大容量存储</strong>。CPU要访问硬盘则需通过硬盘控制器。</p><p>缓存<code>cache</code>：从低速存储设备<strong>临时复制</strong>到高速存储设备。</p><h3 id="IO结构">IO结构</h3><h4 id="DMA">DMA</h4><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="4.png" style="zoom:100%"><h2 id="操作系统结构">操作系统结构</h2><h3 id="Multiprogramming-多道程序">Multiprogramming(多道程序)</h3><p>操作系统将多个任务存储在内存中，CPU在作业之间进行调度切换。</p><p><strong>优点</strong></p><ul><li>CPU利用率高</li><li>系统吞吐量大</li><li>IO设备利用率高</li></ul><p><strong>缺点</strong></p><ul><li>响应慢</li></ul><p><strong>基本特征：</strong></p><ul><li>制约性</li><li>间断性</li><li>共享性</li></ul><h3 id="multitasking（多任务）">multitasking（多任务）</h3><p>即分时复用</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="5.png" style="zoom:100%"><h2 id="操作系统操作">操作系统操作</h2><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="6.png" style="zoom:100%"><h3 id="双重模式（dual-mode">双重模式（dual-mode)</h3><p><strong>User mode(处理用户代码或进程) 与 Kernel mode（处理系统代码或进程）</strong></p><h4 id="划分的原因">划分的原因</h4><p>很多指令不能让用户直接操作，划分模式以达到限制用户操作的目的</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="7.png" style="zoom:100%"><h2 id="进程管理">进程管理</h2><p><strong>处于执行中的程序被称为进程</strong>。是系统内部的一个工作单元。<strong>程序是被动的实体，进程是动态的实体</strong>。每个进程建立进程控制块进行管理。</p><p><strong>进程需要一定的资源</strong>（包括CPU时间、内存、文件、IO设备）以完成其任务。这些<strong>资源可以在进程创建时分配给进程，也可以在执行进程时分配给进程</strong>。除了在创建时得到各种物理和逻辑资源外，进程还可以接受传输过来的各种初始化数据（输入）。进程完成后释放资源。</p><p><strong>系统由多个进程组成</strong>，所有这些进程可以潜在地<strong>并发</strong>执行。</p><p>操作系统负责下述与进程管理相关的活动：</p><ul><li>创建和删除用户进程和系统进程。</li><li>挂起和重启进程。</li><li>提供进程同步机制。</li><li>提供<strong>进程通信</strong>机制。</li><li>提供死锁处理机制。</li></ul><h2 id="存储管理">存储管理</h2><p>操作系统提供了统一而逻辑的信息存储。操作系统对存储设备的物理属性进行了抽象，定义了逻辑存储单元，即文件。操作系统将文件映射到物理介质上，并通过这些存储介质访问这些文件。</p><h3 id="文件系统管理">文件系统管理</h3><p>操作系统负责下列有关文件管理的活动：</p><ul><li>创建和删除文件和目录。</li><li>提供操作文件和目录的原语（基元）。</li><li>将文件映射到二级存储</li><li>在稳定介质上备份文件</li></ul><h3 id="大容量存储">大容量存储</h3><p>操作系统负责下列有关硬盘管理的活动：</p><ul><li><p>空闲空间管理。</p></li><li><p>存储空间分配。</p></li><li><p>硬盘调度。</p></li></ul><p>由千二级存储器使用频繁，因此必须高效。计算机操作的最终速度可能与硬盘子系统的速度和管理该子系统的算法有关。</p><h3 id="IO子系统">IO子系统</h3><h4 id="缓冲区-Buffer-与缓存-Cache-的区别">缓冲区(Buffer)与缓存(Cache)的区别</h4><p>缓冲区是协调两个速度不匹配的<strong>过程</strong>（或者任务）。</p><p>缓存协调两个速度不匹配的<strong>设备</strong>，在高速存储器内放置快速存储区存放低层（慢速）数据。</p><h4 id="概念：Spooling-（即外部设备联机并行操作）">概念：Spooling （即<a target="_blank" rel="noopener external nofollow noreferrer" href="http://baike.baidu.com/view/206732.htm">外部设备</a>联机并行操作）</h4><p>即Simultaneous Peripheral Operation On-Line的缩写，它是关于慢速<a target="_blank" rel="noopener external nofollow noreferrer" href="http://baike.baidu.com/view/1913432.htm">字符设备</a>如何与计算机主机交换信息的一种技术，通常称为“<a target="_blank" rel="noopener external nofollow noreferrer" href="http://baike.baidu.com/view/3098049.htm">假脱机</a>技术”。Spooling allows programs to “hand off” work to be done by the peripheral and then proceed to other tasks, or to not begin until input has been transcribed.</p><p>例子</p><p>以前由于未使用多进程，如果对操作系统执行打印命令，整个操作系统就不能与用户进行交互了，因此人们通常采用SPOOLING技术，将需要打印的内容<strong>由进程</strong>拷贝到一个功能较弱且廉价的计算机的硬盘上（功能弱体现在功能单一，即以支持SPOOLING操作为主要目的的机器），该计算机有操作系统，与打印机直接相连。这样就可以使高性能计算机免除为服务低速外设而浪费运算资源的情况。</p><h2 id="补充">补充</h2><h3 id="并行与并发">并行与并发</h3><p>顾名思义，「并发」强调的是可以一起「出『发』」，「并行」强调的是可以一起「执『行』」。</p><p><strong>与可以一起出发的并发（concurrent）相对的是不可以一起出发的顺序（sequential）：</strong></p><ul><li>顺序：<strong>上一个开始执行的任务完成后，当前任务才能开始执行</strong></li><li>并发：<strong>无论上一个开始执行的任务是否完成，当前任务都可以开始执行</strong></li></ul><p>（也就是说，A B 顺序执行的话，A 一定会比 B 先完成，而并发执行则不一定。）</p><p><strong>与可以一起执行的并行（parallel）相对的是不可以一起执行的串行（serial）：</strong></p><ul><li>串行：<strong>有一个任务执行单元，从物理上就只能一个任务、一个任务地执行</strong></li><li>并行：<strong>有多个任务执行单元，从物理上就可以多个任务一起执行</strong></li></ul><p>（也就是说，<strong>在任意时间点上，串行执行时必然只有一个任务在执行，而并行则不一定</strong>。）</p><p>综上，并发与并行并不是互斥的概念，只是前者关注的是任务的抽象调度、后者关注的是任务的实际执行。而它们又是相关的，比如并行一定会允许并发。</p><p>所以：</p><ul><li><strong>单核 CPU 多任务：并发（不必等上一个任务完成才开始下一个任务）、串行（只有一个实际执行任务的 CPU 核）</strong></li><li>多线程：并发、串行（所有线程都在同一个核上执行）；并发、并行（不同线程在不同的核上执行）</li></ul><hr><p>如下图，并发是两个队列<strong>交替</strong>使用一台咖啡机，并行是两个队列<strong>同时</strong>使用两台咖啡机</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="8.jpg" style="zoom:100%"><h1>第一章重点拾遗</h1><h2 id="操作系统特征">操作系统特征</h2><p>1．并发</p><p>在计算机系统中同时存在多个程序，从<strong>宏观上看这些程序是同时向前推进的；从微观上讲，任何时刻只有一个程序在执行</strong>，即单CPU条件下，这些程序在CPU上轮流执行。</p><p>双重含义：</p><ul><li>用户与用户程序并发</li><li>用户与操作系统程序并发</li></ul><p>2．共享：操作系统与多个用户程序共同使用计算机系统中的资源。</p><p>3．随机性：操作系统必须随时对以不可预测的次序发生的事件进行响应。</p><h2 id="操作系统的两个设计目标">操作系统的两个设计目标</h2><ul><li><p>提供一个良好的供其它程序执行的运行环境，具体追求：</p></li><li><p>方便使计算机系统用</p><ul><li>操作系统提供方便使用的接口</li></ul></li><li><p>使计算机系统能高效率工作</p><ul><li>操作系统扩充硬件的功能：操作系统应使硬件的功能发挥的更好</li><li>操作系统使用户合理共享资源，防止各用户间相互干扰</li><li>操作系统以文件形式管理软件资源，保证信息的安全和快速存取</li></ul></li></ul><p>两个目标是一对矛盾，需要折中权衡</p><h2 id="操作系统形成与发展">操作系统形成与发展</h2><p>操作系统从无到有，其发展是随着计算机硬件技术的发展而发展的。</p><ul><li>手工操作阶段（程序员即使操作员，汇编，读卡机，设备驱动程序）</li><li>管理程序（20世纪50年代末至60年代初，编译程序）</li><li>多道程序系统：批处理系统、分时系统：<br>（1）<strong>多道程序设计技术：通道技术，中断技术的出现使多道程序设计技术成为可能</strong><br>（2）<strong>SPOOLing技术（Simultaneous Peripheral Operation-On Line），预输入和缓输出功能</strong><br>（3） <strong>分时系统：把CPU时间划成时间片，轮流为用户服务</strong></li><li>通用操作系统</li></ul><h2 id="操作系统分类">操作系统分类</h2><h3 id="单道批处理系统">单道批处理系统</h3><p><strong>单道批处理系统</strong>：为了实现对作业的连续处理，需要先把一批作业以脱机方式输入到磁盘上，并在系统中配上监督程序（<code>Monitor</code>），在它的控制下，使得这批作业能一个接着一个的连续工作。</p><p>具体的工作过程是首先由监督程序将磁带上的第一个作业装入内存，并把运行控制权交给作业；该作业处理完时，又把控制权交给监督程序，再有监督程序把磁带的第二个作业调入内存等等。<strong>可以看成是串行的</strong>。</p><p><strong>优点</strong>：解决人机矛盾和CPU与IO设备速度不匹配问题，提高系统资源的利用率和系统吞吐量。</p><p>（吞吐率（量）：单位时间内处理作业的个数）</p><p><strong>缺点</strong>：不能充分的利用系统资源，现很少使用（如下图，如果频繁IO会导致CPU利用率很低）。</p><h4 id="特点：">特点：</h4><ul><li>自动：作业自动运行，无需干预</li><li>批量：磁带上的各个作业按顺序地进入内存，先调入先完成</li><li>单道：内存中仅有一道程序运行，可以看成是串行的</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="11.png" alt=""></p><h3 id="多道批处理操作系统">多道批处理操作系统</h3><h4 id="工作方式">工作方式</h4><p>作业（<code>job</code>）：用户要求计算机系统进行处理的一个计算问题。用户程序及其所需的数据和控制命令一起形成作业。作业 = 程序 + 数据 + 作业说明书</p><p>用户（准备好自己的作业）将作业交给系统操作员，系统操作员将许多用户的作业组成一批作业，通过输入设备输入到计算机系统中（磁盘上），然后，启动操作系统，执行每个作业，最后由操作员将作业运行结果分发给用户。</p><p><strong>多道指某个作业占用CPU，若由于某种原因暂时不用CPU，第二个作业占用CPU</strong>。</p><h4 id="特点">特点</h4><ul><li><strong>宏观上并行，微观上串行</strong></li><li>多道，主存中同时存在多个正在运行的程序，它们<strong>并发工作，减少CPU的空闲时间，提高了CPU的利用率</strong>。</li><li>成批处理，作业流程自动化，减少了人工操作和作业交接的时间，<strong>提高了系统吞吐率</strong>。<ul><li>带来的不足之处：<strong>无交互手段，调试程序困难；作业处理时间长，周转效率低</strong>；</li><li><strong>用户不能直接干预自己作业的运行</strong>，一旦发现作业错误，不能及时修改，延长了开发软件时间，所以<strong>一般适用于成熟的程序</strong>。</li></ul></li><li>采用作业调度策略，按一定的合理搭配选择作业进入主存，<strong>可以充分利用计算机系统的各种资源</strong>。<ul><li>CPU密集型、I/O密集型、均衡型</li></ul></li><li>采用<strong>SPOOL技术</strong>使作业在执行过程中，可以直接从高速磁盘上存取信息，<strong>缩短了作业执行时间，提高了运行效率</strong>。</li></ul><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="12.png" alt=""></p><h4 id="SPOOLing系统特点">SPOOLing系统特点</h4><p>（Simultaneous Peripheral Operation On-Line，同时的外围设备联机操作–假脱机技术）</p><p><strong>在一个计算问题开始之前，把计算所需要的程序和数据从输入设备上预先输入到磁盘上，这样，当进行计算时可以从磁盘上读取程序和数据（速度快），无须再访问输入设备（慢速）。同样，计算过程中，将结果先放到磁盘上保存，全部计算完成后再把全部计算结果输出到打印机上</strong>。</p><p>利用磁盘作缓冲，将输入、计算、输出分别组织成独立的任务流，使I/O和计算真正并行</p><p>作业进入到磁盘上的输入，系统按某种调度策略选择几个搭配得当的作业，调入主存。作业运行的结果输出到磁盘上的输出，之后再从磁盘上的输出将结果送到打印机。</p><p><strong>追求目标</strong>：系统资源利用率和系统效率</p><h3 id="分时操作系统">分时操作系统</h3><h4 id="工作方式-2">工作方式</h4><p>一台主机连接了若干个终端，每个终端有一个用户在使用，交互式地向系统发出命令请求；系统接受每个用户的命令，并采用<strong>时间片轮转</strong>的方式处理用户的服务请求，并在终端上向用户显示处理结果；用户根据上一步运行结果发出下一道命令。</p><p><strong>追求的目标是比较快速响应用户</strong></p><ul><li>分时系统为用户提供交互命令</li><li>分时系统中采用分时方法对多个终端用户服务</li><li>分时方法：将CPU时间划为时间片</li><li>分时系统以时间片为单位，轮流为各个用户服务</li></ul><h4 id="特点-2">特点</h4><ul><li>同时性（多路性）<ul><li>同时有多个用户使用一台计算机。<br>（宏观上看是多个用户同时使用一个CPU，微观上则是多个用户在不同时刻轮流使用CPU。）</li></ul></li><li>独占性（独立性）<ul><li>各个用户彼此独立，互不干扰地使用计算机，感觉不到计算机同时还在为其他用户服务，有一种独占计算机的错觉。</li></ul></li><li>及时性<ul><li>系统对用户提出的请求能在较短时间内作出响应，让用户满意。</li></ul></li><li>交互性<ul><li>采用人机对话方式，用户在终端上输入、调试、运行自己的程序，能及时修改程序中的错误且直接获得结果。用户根据系统响应结果进一步提出新的请求。（用户能直接干预作业运行的每一步）</li></ul></li></ul><h4 id="分时系统目标与多道程序目标的对比">分时系统目标与多道程序目标的对比</h4><ul><li>分时系统目标：对用户请求快速反应</li><li>多道批处理目标：提高计算机系统效率</li></ul><h3 id="实时操作系统">实时操作系统</h3><h4 id="主要追求目标">主要追求目标</h4><ul><li>及时性（实时性）<ul><li>对外部请求在严格时间范围内作出反应和处理（强制性的）</li></ul></li><li>高可靠性和安全性<ul><li>系统保证不出错（因此，不追求系统资源利用率）</li></ul></li></ul><h3 id="分布式操作系统">分布式操作系统</h3><p>分布式操作系统是网络操作系统的更高级的形式，它保持了网络操作系统的全部功能。</p><h4 id="分布式系统">分布式系统</h4><p>基于两种环境：</p><ul><li><p>一种是多处理机（多CPU）系统：紧密耦合</p><ul><li>建立在多个CPU上──物理上相邻──总线或开关网连接处理器，共享主存进行通信</li></ul></li><li><p>另一种是基于计算机网络的多计算机系统：松散耦合</p><ul><li>建立在网络上──地理上分开，通过网络用报文（Message）连接</li></ul></li><li><p>分布式计算机系统结构：环形，星形，树形</p></li></ul><h4 id="特征">特征</h4><p>1）是一个统一的操作系统。<br>2）资源进一步共享（最大限度的共享）。<br>3）透明性：资源共享，分布。用户并不知道，对用户来讲是透明的。<br>4）自治性：处于分布式系统中的多个主机处于平等地位。<br>5）处理能力增强，速度更快，可靠性增强。</p><h2 id="中断">中断</h2><h3 id="中断系统的作用">中断系统的作用</h3><ul><li><p><strong>中断是实现多道程序操作系统的前提</strong>，没有中断，操作系统无法改变CPU 的状态（即目态－管态之间的互换）（用户态与内核态）</p></li><li><p>中断是现代计算机系统中的基本设施之一，它起着通讯联络作用，协调系统对各种外部事件的响应和处理。中断是实现多道程序的必要条件。</p></li><li><p>操作系统是由中断驱动的。</p></li></ul><h3 id="中断系统的处理原理">中断系统的处理原理</h3><p>​ 中断装置由一些特写的寄存器和控制线路组成，中央处理器和外围设备等识别到的事件保存在特写寄存器中，中央处理器每执行完一条指令后，均由中断装置判别是否有事件发生。若无事件发生，中央处理器继续执行指令；若有事件发生，中断装置中断原占用中央处理器的程序执行，而让操作系统的处理事件的服务程序占用中央处理器对出现的事件进行处理，待操作系统对事件处理完成后，再让原来的程序继续占用中央处理器执行。</p><h3 id="多道程序设计技术与中断系统">多道程序设计技术与中断系统</h3><p>​ 一个计算机系统，尤其是采用多道程序设计技术的计算机系统，不仅有操作系统和其他的系统软件，而且还有若干应用程序。这些程序只有占用中央处理器执行时才能履行自己的职责。但是，一个中央处理器在任何时刻最多只能被一个程序占用。那么，应该由谁来决定哪个程序在什么时候可以占用中央处理器？我们已经知道中断装置在判别到有某个事件发生时，就会触发一个中断而让操作系统去占用处理器，操作系统对事件处理结束后，又主动让出处理器，让出的处理器应被哪个程序占用？这与所发生的事件的性质、对事件的处理情况、系统中各个程序的状态有关。因而，操作系统在让出处理器时应根据对事件处理情况从那些具备占用处理器条件的程序中选择一个程序，被选中的程序就可占用处理器，直到中再一次发生事件而被中断。被中断的程序什么时候能继续占用处理器？这仍取决于事件的性质和对事件的处理情况，若它具备占用处理器的条件，则与其他程序一起等待操作系统的选择。操作系统总是按预定的策略去选择可占用处理器的程序，因此，刚被中断的程序不一定立即被选中。所以，系统中的若干程序可能交替他占用处理器。于是又出现一个新问题：怎样保证各个被中断的程序能在再一次占用处理器时继承以前执行的情况，继续执行？</p><p>​ 中断装置在发现中断事件后，首先把被中断程序的断点（当前的指令地址）等保存起来，然后让操作系统的处理程序占用处理器。操作系统在处理事件之前，把被中断程序在处理器的各寄存器中设置的状态保存起来，在事件处理结束后，选中某个程序占用处理器时再把被保存的该程序的状态恢复到各寄存器中，同时把该程序的返回地址（原断点或亲折启动点）装入指令地址计数器中。于是，被选中的程序就可占用处理器，根据被中断前的情况继续执行。</p><h2 id="通道">通道</h2><p>为了使CPU从I/O事务中解脱出来，同时为了提高CPU与设备、设备与设备之间的并行度，设置了通道。</p><p>通道定义：<strong>是独立于CPU的专门负责数据输入/输出传输工作的处理机，对外部设备实现统一管理，代替CPU对输入/输出操作进行控制，从而使输入/输出操作可以与CPU并行操作</strong>。</p><p>引入目的：<strong>实现外设与CPU的并行操作，实现设备与设备的并行，从而提高整个系统的效率</strong>。</p><p>（DMA？）</p><h2 id="原语">原语</h2><p>原语是一些<strong>关闭中断</strong>（屏蔽中断）的公用小程序</p><p><strong>一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断</strong>。在<a target="_blank" rel="noopener external nofollow noreferrer" href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/192">操作系统</a>中，某些被进程调用的操作，如队列操作、对信号量的操作、检查启动外设操作等，一旦开始执行，就不能被中断，否则就会出现操作错误，造成系统混乱。所以，这些操作都要用原语来实现。<strong>原语是操作系统核心（不是由进程，而是由一组程序模块组成）的一个组成部分，并且常驻内存，通常在管态下执行</strong>。</p><p>特点</p><ul><li>处于操作系统最底层，最接近硬件</li><li>运行具有原子性，操作不允许中断</li><li>运行时间短，调用频繁</li></ul><h1>第二章：操作系统结构</h1><p>考试主要内容在系统调用与操作系统结构。</p><h2 id="操作系统服务">操作系统服务</h2><p>看看就行</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="8.png" style="zoom:80%"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="9.png" style="zoom:80%"><h2 id="系统调用">系统调用</h2><p>系统调用是内核的一部分，本质上也是一种软中断（trap）</p><h3 id="系统调用使用和执行过程">系统调用使用和执行过程</h3><p>（管态-内核态，目态-用户态）</p><ul><li>操作系统提供若干功能子程序（系统调用），这些<strong>系统调用（更严格地说，系统调用对应的服务程序）在管态下执行</strong>（所以内核态时无法执行系统调用，而是直接执行系统调用对应的服务程序）。</li><li>现代计算机系统硬件提供一条“访管指令”，该指令可以在目态下执行。</li><li>用户编制程序需要请求操作系统服务时，使用系统调用。编译程序将其转换成目标程序中的 “访管指令” 及一些参数。</li><li>目标程序执行时，当CPU执行到 “访管指令”，产生自愿性中断，操作系统接过控制权（管态）。</li><li>操作系统分析相关参数，让对应的 “系统调用” 子程序为用户服务。</li><li>完成系统调用后，操作系统将CPU状态改变为目态，返回到用户程序继续执行。</li></ul><h4 id="执行系统调用的主要操作">执行系统调用的主要操作</h4><ul><li>1、传递系统调用参数</li><li>2、执行陷入指令</li><li>3、执行相应的服务程序</li><li>4、返回用户态</li></ul><h3 id="系统调用分类">系统调用分类</h3><ul><li>文件操作类<ul><li>如：打开文件、建立文件、读文件、写文件、关闭文件及删除文件等。</li></ul></li><li>资源申请类<ul><li>如：请求分配主存空间、归还主存空间、分配外围设备及归还外围设备等。</li></ul></li><li>控制类<ul><li>执行中的程序可以请求操作系统中止其执行或返回到程序的某一点再继续执行。操作系统要根据程序中止的原因和用户的要求作出处理，因而这类系统调用有：正常结束、异常结束及返回断点/指定点等。</li></ul></li><li>信息维护类<ul><li>如：设置日期时间、获取日期时间、设置文件属性及获取文件属性等。</li></ul></li></ul><h3 id="系统调用与API">系统调用与API</h3><p>一般应用程序开发人员根据应用程序接口(API)设计程序。API是一系列适用千应用程序员的函数，包括传递给每介函数的参数及其返回的程序员想得到的值。</p><p>有三种应用程序员常用的API：</p><ul><li><p>适用于Windows系统的Win32 API</p></li><li><p>适用于POSIX系统的POSIXAPI（包括几乎所有UNIX、Linux和MacOSX版本），</p></li><li><p>用于设计运行于Java虚拟机程序的JavaAPI。</p></li></ul><h4 id="不用系统调用而是使用API的原因">不用系统调用而是使用API的原因</h4><ul><li>使用API编程的程序可移植性强</li><li>实际的系统调用比API更注重细节且困难</li></ul><h3 id="系统调用接口">系统调用接口</h3><p>系统调用接口截取API的函数调用，并调用操作系统中相应的系统调用。通常，每个系统调用有一个与其相关的数字，系统调用接口根据这些数字维护一个列表索引。然后，系统调用接口根据索引来调用所需的操作系统内核中的系统调用，并返回系统调用状态及其他返回值。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="10.png" style="zoom:20%"><h3 id="系统调用的参数传递">系统调用的参数传递</h3><p>​ 向操作系统传递参数有三种方法。最简单的是通过<strong>寄存器</strong>来传递参数。不过有时，参数数量会比寄存器多。这时，这些参数通常存在<strong>内存的块和表</strong>中，并将块的地址通过寄存器来传递。Linux和Solaris就采用这种方法。参数也可通过程序放在或压入<strong>堆栈</strong>中，并通过操作系统弹出。有的系统采用块或堆栈方法，因为这些方法并不限制所传递参数的数量或长度。</p><h2 id="操作系统设计与实现">操作系统设计与实现</h2><p>用户目标：方便和容易使用、容易学习、可靠、安全和快速</p><p>系统目标：操作系统应该容易设计、实现和维护，也应该灵活、可靠、高效且容错。</p><p>结构设计目标</p><ul><li>正确性<ul><li>影响操作系统正确性的因素：<br>随机性：任务类型和到达系统的时间是随机的；系统中发生的各种事件是随机的，资源使用情况是随机的。<br>操作系统必须充分估计和把握各种不确定因素。<br>结构良好 → 保证正确性，易于验证其正确性</li></ul></li><li>高效性<ul><li>减少操作系统自身的开销（时间开销、空间开销）<br>特别是：核心程序的设计（关键，原则：少而精，有效灵活）</li></ul></li><li>易维护性<ul><li>增、删、改、调整</li></ul></li><li>移植性<ul><li>移植性：能否方便地把操作系统移植到一个新的硬件环境中。</li><li>原则：减少与硬件直接相关的程序量，将其独立封装。采用标准语言书写操作系统</li></ul></li></ul><h3 id="机制与策略">机制与策略</h3><p><strong>一个重要原理是策略(<code>policy</code>)和机制(<code>mechanism</code> )的区分。机制决定如何做， 策略决定做什么</strong>。</p><h2 id="操作系统结构-2">操作系统结构</h2><h3 id="模块结构">模块结构</h3><p>系统中每一个模块都是根据他们要完成的功能来划分的，这些功能模块按照一定的结构方式组合起来协同完成整个系统的功能。适用于系统小、模块少、使用环境稳定的系统。</p><h4 id="优点">优点</h4><ul><li>结构紧密、接口简单直接、系统效率相对较高</li></ul><h4 id="缺点">缺点</h4><ul><li><p>各模块相互牵连，不容易把握好模块的独立性，导致系统结构不清晰。</p></li><li><p><strong>可扩展性较差</strong></p></li><li><p>更换或修改模块困难（各模块相互牵连导致耦合度高）</p></li><li><p>系统的可适应性差，复杂度增长迅速</p></li></ul><h3 id="层次结构">层次结构</h3><p>按照层次结构设计的操作系统，就是将操作系统的所有功能模块按照功能的调用次序排列成若干层，使得功能模块之间只存在单向调用和单向依赖。</p><h4 id="优点-2">优点</h4><ul><li><p>模块间的组织和依赖关系清晰明了，系统的可读性、可适应性及可靠性强</p></li><li><p>修改模块对系统影响小，便于修改和扩充。</p></li></ul><h4 id="缺点-2">缺点</h4><ul><li>如何进行有效的分层</li></ul><h3 id="微内核结构">微内核结构</h3><p>主要思想是在操作系统的内核中只留下一些最基本的功能，其他服务用若干个运行在用户态的进程来实现。非常适用于分布式系统。</p><h4 id="优点-3">优点</h4><ul><li><p>每个服务进程独立，某个服务崩溃不会引起其他服务崩溃，可靠性好。</p></li><li><p>系统灵活性好。</p></li><li><p>便于维护，修改某一服务不会影响其他部分。</p></li><li><p>操作系统可移植性强</p></li></ul><h4 id="缺点-3">缺点</h4><ul><li><strong>微内核相互通信，导致系统效率不高</strong>。</li></ul><h1>一二章习题拾遗</h1><ul><li>无进程处于运行状态则就绪和等待队列均为空（错）。<ul><li>死锁时无进程运行，等待队列不为空。</li></ul></li><li>实时操作系统必须在<strong>被控对象规定时间</strong>内处理完来自外部的事件</li><li>描述操作系统的典型观点<ul><li>操作系统是众多软件的结合（对</li><li>操作系统是用户和计算机间的接口（对</li><li>操作系统是资源管理者（对</li><li>操作系统是虚拟机（错）</li></ul></li><li>中断发生后，进入中断处理的程序属于<strong>操作系统程序</strong></li><li>OS通常为用户提供四种使用接口：<ul><li>终端命令</li><li>图标菜单</li><li>系统调用</li><li>类似DOS的批命令文件或UNIX的shell文件</li></ul></li><li>单处理器中可以并行的是<ul><li>处理器与设备</li><li>处理器与通道</li><li>设备与设备</li><li>进程与进程，这个不能并行，只能并发串行</li></ul></li><li>进程切换不可能发生在用户态，而系统调用、外部中断、缺页可以</li><li>中断处理和子程序调用都需要压栈以保护现场。中断处理一定会保存而子程序调用不需要保存的是<strong>程序状态字寄存器</strong><ul><li>因为子程序调用是系统能够预知的，且一般在进程内部执行，不会更改程序状态，只要更新寄存器就行。</li></ul></li><li>计算机开机后，操作系统最终被加载到<strong>RAM</strong></li><li>处理外部中断时，操作系统保存<strong>通用寄存器</strong>内容，中断隐指令自动保存程序计数器，</li><li>访存会使CPU从用户态变到内核态</li></ul><h1>第三章：进程</h1><p>进程：一个程序在一个数据集合上的一次执行过程。（进程是具有独立功能的程序关于某个数据集合上的一次运行活动，是系统进行资源分配和调度的独立单位。）</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="13.png" style="zoom:80%"><h2 id="程序与进程之间的区别">程序与进程之间的区别</h2><ul><li>进程是由程序和数据组成的，进程离开程序是没有意义的。</li><li><strong>程序是静态的，进程是动态的。</strong></li><li>进程有生命周期，有诞生有消亡。进程是短暂的，而程序是相对长久的。</li><li>一个程序可以对应多个进程。<ul><li>可再入程序（两个及两个以上进程共用一个程序）：可被多个进程同时调用的程序。<ul><li>具有下列特征：它是纯代码的，即在执行过程中自身不会改变，调用它的进程应该提供数据区（工作区）。</li></ul></li></ul></li><li>进程有创建其它进程的功能，而程序没有。<ul><li>进程比程序更能真实地描述并发执行。</li></ul></li></ul><h2 id="进程控制块">进程控制块</h2><p>系统为了管理进程设置了一个专门的<strong>数据结构</strong>，<strong>用于记录进程的外部特征，描述进程的运动变化过程</strong>。<br>系统利用PCB来控制和管理进程，所以，<strong>PCB是系统感知进程存在的唯一标志，进程与PCB是一一对应的</strong>。</p><h3 id="PCB的内容">PCB的内容</h3><p>记录了管理进程所必需的信息</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="15.png" style="zoom:60%"><ul><li>标识信息：进程标识（进程名字，进程的内部标识）；用户名</li><li>说明信息：进程状态；等待原因；进程程序和数据的存储信息（起始地址，长度）。</li><li>现场信息：记录保存了<strong>重要寄存器（通用寄存器、控制寄存器、程序状态字寄存器）内容（也就是寄存器的值）以及程序计数器（下条要执行的指令的地址）</strong>，用于恢复断点，让进程继续执行。</li><li>管理调度信息：进程优先数；进程队列指针；消息队列指针；进程使用的资源清单；进程家族关系；进程当前打开的文件。</li></ul><h3 id="系统并发度（PCB表）">系统并发度（PCB表）</h3><p>​ 为便于管理，系统把所有PCB组织在一起，并把它们放在内存的固定区域，就构成了PCB表。PCB表的大小决定了系统中最多可同时存在的进程个数，个数也叫系统的并发度。<br>​ 注：多道程序中的多道与系统并发度中的PCB个数不同。如有十个用户（多道）在上机，而每个用户有&gt;=1个进程。系统并发度&gt;多道。</p><h3 id="进程的组成：程序-数据-PCB（构成进程三要素）">进程的组成：程序 + 数据 + PCB（构成进程三要素）</h3><h2 id="进程的状态及其转换">进程的状态及其转换</h2><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="14.png" style="zoom:80%"><p>五个状态，<code>new</code>（新建），<code>ready</code>（就绪），<code>running</code>（运行），<code>waiting</code>（等待/阻塞），<code>terminated</code>（终止）。</p><ul><li><p><code>ready</code>：一个进程已经具备运行条件，但由于无CPU暂时不能运行的状态。（进程已得到除CPU以外的所有资源，一旦获得CPU时，立即可以运行。）</p></li><li><p><code>waiting</code>：进程因等待某种事件的发生而暂时不能运行的状态。如等待I/O结束，即使CPU空闲，该进程也不能运行。</p></li></ul><h3 id="进程的创建">进程的创建</h3><p>系统为一个程序分配一个工作区（存放程序处理的数据），并为该程序建立一个进程控制块后，进程创建完成。<br>完成以下工作：</p><ul><li>建立一个PCB（找一个空PCB）。</li><li>为进程分配内存等必要资源（进程的工作区，存放程序处理的数据集）。</li><li>填写PCB中各项目,例如，初始状态为 “就绪态”。</li><li>把PCB插入进程<strong>就绪队列</strong>。</li></ul><p>（至于什么是就绪队列，后文会讲）</p><h3 id="就绪-运行">就绪 -&gt; 运行</h3><p>被调度程序选中。</p><h3 id="运行-就绪">运行 -&gt; 就绪</h3><p>分配给进程的进间片执行完成（轮转调度算法）、高优先级的进程到达（抢占式调度）。</p><h3 id="运行-等待-阻塞">运行 -&gt; 等待/阻塞</h3><p>当进程请求资源的使用权(如外设)或等待事件发生(如I/O完成)。</p><p>一个进程从运行到阻塞，就会调度一个进程从就绪到运行。</p><p>操作系统会将该进程的PCB放入阻塞队列中，队列根据不同的事件进行划分。所以<strong>会有多个阻塞队列</strong>，原因如下：</p><p>如果所有阻塞进程放在同一个阻塞队列中，当一个事件完成后操作系统不得不扫描整个队列找到那些等待该事件的进程然后将其放进就绪队列中，这样的效率十分低下，因此通常是为每一个事件创建一个阻塞队列。</p><h3 id="等待-阻塞-就绪">等待/阻塞 -&gt; 就绪</h3><p>当进程已经获取所需资源的使用权或者等待事件已完成。</p><p>当按照优先级进行调度时，操作系统会将优先级相同的进程PCB从阻塞队列放进一个就绪队列，避免扫描等低效的做法，这是典型的用空间换时间的做法。</p><p>所以<strong>只会有一个就绪队列</strong>。</p><h3 id="阻塞-唤醒进程">阻塞/唤醒进程</h3><p>正在执行的进程，由于需要的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或等待新任务的到达等，则由系统自动执行阻塞原语，使自己由运行状态变为阻塞状态。<strong>进程的阻塞是进程自身的一种主动行为</strong>，只有处于运行状态的进程，才可能将其转为阻塞状态。</p><h4 id="阻塞原语（Block）的执行过程如下：">阻塞原语（Block）的执行过程如下：</h4><ul><li><strong>找到将要被阻塞进程的标识号对应的 PCB</strong>；</li><li>若该进程为运行状态，则<strong>保护其现场，将其状态转为阻塞状态</strong>，停止运行；</li><li><strong>将该 PCB 插入到相应事件的等待队列中去</strong>。</li><li>当被阻塞进程所需要的事件发生时，如 I/O 操作已完成或其所需要的数据已到达，则由相关进程（例如，提供数据的进程）执行唤醒原语，将等待该事件的进程唤醒。<strong>进程的唤醒是一种被动行为，需要其他进程触发</strong>。</li></ul><h4 id="唤醒原语（Wakeup）的执行过程如下：">唤醒原语（Wakeup）的执行过程如下：</h4><ul><li><strong>在该事件的等待队列中找到相应进程的 PCB</strong>；</li><li><strong>将其从等待队列中移出，并置为就绪状态</strong>；</li><li><strong>把该 PCB 插入就绪队列中，等待调度程序调度</strong>。</li></ul><p>阻塞/唤醒是一对作用刚好相反的原语，必须成对使用。<strong>阻塞原语是由被阻塞进程自我调用实现的，而唤醒原语则是由一个与被唤醒进程相合作或被其他相关的进程调用实现的</strong>。</p><h3 id="挂起与激活">挂起与激活</h3><p>出于用户观察需要，进程可以执行挂起和激活两种操作。挂起是将活跃状态转为挂起状态，使进程不再被系统调用；激活是将挂起状态转为活跃状态。</p><p>进程挂起的几种情况：</p><ul><li>终端用户的需要：当终端用户在运行程序期间发现有可疑问题，希望暂停程序的运行以便研究其执行情况或做一定的修改；</li><li>父进程请求；</li><li>符合调节的需要；</li><li>操作系统的需要：有时希望挂起某些进程以便检查运行中的资源使用情况或进行记账。</li></ul><h4 id="挂起原语（Suspend）的执行过程如下：">挂起原语（Suspend）的执行过程如下：</h4><ul><li>检查被挂起的进程的状态；</li><li>若是活动就绪状态，便将其改成挂起就绪；若是活动阻塞状态，便将其改成挂起阻塞；</li><li>为方便用户或父进程考察该进程的运行情况，把该进程的 PCB 复制到某指定的内存区域；</li><li>若被挂起的进程正在执行，则转向调度程序重新调度。</li></ul><h4 id="激活原语（Active）的执行过程如下：">激活原语（Active）的执行过程如下：</h4><ul><li>将进程从外存调入内存，检查该进程的现行状态；</li><li>若是挂起就绪，便将其改为活动就绪；若是挂起阻塞，便将其改为活跃阻塞；</li><li>假如采用的是抢占调度策略，则每当有挂起就绪进程被激活而加入就绪队列时，便检查是否需要重新调度，即</li><li>由调度程序将被激活的进程和当前进程两者优先级进行比较；<ul><li>若被激活进程优先级低，则不必重新调度；若当前进程优先级低，则把处理机分配给被激活的进程。</li></ul></li></ul><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="16.png" style="zoom:80%"><h2 id="进程切换">进程切换</h2><p>进程切换在什么时候发生呢？理论上在任何时刻只要操作系统拿到控制权就可以进行进程切换，那么什么时候操作系统会重新拿到控制权呢？<br>  这里首先考虑中断的情况，而中断又可分为两种：<strong>中断</strong>和<strong>陷阱</strong>。中断一般是与当前正运行进程无关的某种外部事件相关，例如完成了一次I/O操作，中断处理器完成一些基本的辅助操作后将控制权转给与已发生的终端相关的操作系统历程，简单来说中断的发生属于正常的事件，不过是操作系统暂时停止执行当前进程转为处理另外一件更加紧急的事情。例如以下三种中断：<br>  1、时钟中断。当前进程时间片到期，转为从就绪队列中调度新的进程开始运行。<br>  2、I/O中断。某一I/O完成，操作系统判断是否有正在等待该I/O的进程，如果有将其放回就绪态，随后操作系统根据调度算法调度合适的进程继续运行。<br>  3、缺页中断。处理器遇到一个引用不存在内存中的虚存地址时，此时会发生缺页中断，然后操作系统要根据算法将访问的页调入内存，这块的处理与操作系统对内存管理有很大关系。<br>  除了中断，陷阱也有可能会导致进程状态的切换。所谓陷阱就是异常或者错误。即发生在程序内部的不可预期的非法错误。如果错误致命则将当前进程改为退出态，不致命时操作系统的行为决定于操作系统的设计，有可能是简单的通知用户，也有可能是尝试恢复。<br>  还有一种可能会导致进程切换的事件，就是<strong>系统调用</strong>。当用户进程发起一个特权指令（系统调用）时，操作系统会将当前用户进程设置为阻塞态，然后会调用系统例程执行系统调用指令，当执行完毕会在此调度用户进程开始执行。<br>  综上所述，可能造成进程状态切换的事件有三种<strong>中断，陷阱(异常)，系统调用</strong>。</p><h3 id="切换过程">切换过程</h3><p>进程切换的过程如下：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器；</li><li>更新PCB信息（记住PCB状态）；</li><li>把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列；</li><li>选择另一个进程执行，并更新其 PCB；</li><li>更新内存管理的数据结构；</li><li>恢复处理机上下文。</li></ol><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="17.png" style="zoom:70%"><h4 id="进程的终止">进程的终止</h4><p>由以下14种事件触发：<br>1、正常完成。正常结束运行。<br>2、超过时限。进程运行超过规定的时限。<br>3、无内存可用。系统无法满足进程需要的内存。<br>4、超出范围。进程试图访问非法的内存单元。<br>5、保护错误。进程试图使用不允许使用的资源或文件。<br>6、算术错误。进程试图进行被禁止的运算。<br>7、时间超出。进程等待某一事件发生的时间超过了规定的时间。<br>8、I/O失败。在输入输出期间发生错误。<br>9、无效指令。进程试图执行一个不存在的指令。<br>10、特权指令。进程试图使用为操作系统保留的指令。<br>11、数据误用。错误类型或未初始化的一块数据。<br>12、操作员或操作系统干涉。操作员或操作系统终止进程。<br>13、父进程终止。在某些操作系统中，父进程终止时操作系统会自动终止该进程的所有子进程。<br>14、父进程请求。父进程要求终止其子进程。</p><h2 id="进程调度队列">进程调度队列</h2><p>就绪状态的所有进程存在就绪队列。阻塞状态的进程根据事件不同存在不同的阻塞队列。</p><p>任务队列：存放系统中的所有进程</p><h2 id="处理器的三级调度">处理器的三级调度</h2><p>进程调度（程序）的职责（任务）是控制协调进程对CPU的竞争，即按选定的调度算法从就绪队列中选择一个进程，让它占用CPU（即把CPU的使用权交给被选中的进程，把CPU分配给被选中进程）执行。</p><h3 id="作业调度（长期调度、高级调度）">作业调度（长期调度、高级调度）</h3><p>其主要任务是按照一定的原则从<strong>外存</strong>上处于后备状态的作业中选择一个或多个，给他们分配内存、输入输出设备等必要资源，并建立相应的进程以使其具有获取竞争处理器的权利。</p><p><strong>频率低</strong>，通常几分钟一次。</p><p>批处理系统或通用操作系统的批处理部分由于新提交的作业先放在磁盘上，所以需要作业调度将其分批装入内存。其他类型操作系统一般不需要作业调度。</p><p>执行调度时需要解决两个问题。</p><p>第一，调度程序必须决定操作系统可以接纳多少个作业进入内存。这取决于多道程序的并发程度，即允许有多少个作业同时在内存中运行。</p><p>第二，调度程序必须决定接纳哪些作业。这主要取决于所采取的调度算法。</p><blockquote><p>这里解释一下作业和进程的区别与联系</p><p>作业可分为：编译、链接、装入、和运行这4个作业步。</p><p>当一个作业被作业调度（高级调度）选中进入内存并投入运行时，操作系统为此用户作业生成用户进程完成其计算任务。</p><p>进程是已提交完毕并选中运行的作业（程序）的执行实体，也是为完成作业任务向系统申请和分配资源的基本单位，它处于运行，就绪，等待等多个状态变化之中。</p><p>综上所述：</p><p>作业是任务实体，进程是完成任务的执行实体</p><p>没有作业任务，进程无事可做；没有进程，作业任务无法完成</p><p>作业的概念更多的用于批处理操作系统；进程多用于各种多道程序设计系统</p></blockquote><h3 id="内存调度（中级调度、交换调度）">内存调度（中级调度、交换调度）</h3><p><strong>引入的主要目的是提高内存利用率和系统吞吐率</strong>，主要任务是按照给定的原则和策略，将处于外存对换区中的具备运行条件的进程调入内存，并将其状态改为就绪状态，挂在就绪队列；或将处于内存中暂时不能运行的进程交换到外存对换区，此时进程状态为挂起状态。</p><blockquote><p>当内存资源紧缺时，会把暂时不能运行的进程换出内存，此时这个进程处于“挂起”状态，不参与低级调度；当进程具备运行条件且内存资源富裕时，再将进程重新回调内存工作。</p><p>起到短期均衡系统负载的作用，充分提高内存利用率和系统吞吐率。</p></blockquote><h3 id="进程调度（低级调度、CPU调度）">进程调度（低级调度、CPU调度）</h3><p>主要任务是按照给定的原则和策略从就绪队列中选取一个进程，将处理器分配给它。</p><p><strong>运行频率很高</strong>，几十毫秒一次。</p><h2 id="再议进程创建与终止">再议进程创建与终止</h2><h3 id="创建">创建</h3><p>大多数操作系统根据-个唯一的进程标识符 (process identifier, pid) 来识别进程，pid 通常是一个整数值。<br><strong>理解进程创建的几个重要概念，这一项也是本章的重点!</strong></p><p>Fork()的两个要点:</p><ul><li>内核为子进程做一个父进程的上下文拷贝。<ul><li>拷贝包括: (1) 复制父进程的PCB作为子进程的PCB (2) 在新的地址空间中复制父进程的一个拷贝</li></ul></li><li>父进程与子进程在不同的地址空间上运行。</li></ul><p>关于①的理解:子进程与父进程共享子进程创建前的所有资源。<br>关于②的理解:子进程在创建后和父进程是竞争关系，两个进程依据进程调度的规则分别执行。</p><p>总结 ： <strong>先继承，后分离</strong>。</p><p>Fork( )的返回值: Pid=fork();</p><ul><li>正确执行:<ul><li>父进程返回子进程号;</li><li>子进程返回0。</li></ul></li><li>出现错误:返回-1。</li></ul><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="18.png" style="zoom:70%"><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="type">pid_t</span>  pid;</span><br><span class="line">	<span class="comment">/* fork another process */</span></span><br><span class="line">	pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123; <span class="comment">/* error occurred */</span></span><br><span class="line">		<span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork Failed&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123; <span class="comment">/* child process */</span></span><br><span class="line">		execlp(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123; <span class="comment">/* parent process */</span></span><br><span class="line">		<span class="comment">/* parent will wait for the child to complete */</span></span><br><span class="line">        <span class="comment">//子进程结束后唤醒父进程</span></span><br><span class="line">		wait (<span class="literal">NULL</span>);</span><br><span class="line">		<span class="built_in">printf</span> (<span class="string">&quot;Child Complete&quot;</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);<span class="comment">//这也是一个系统调用</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="一些细节问题">一些细节问题</h4><p>子进程复制父进程的内存空间，上面的代码也会复制并继续运行，则会根据不同的<code>pid</code>进入不同的代码块。</p><p><strong><code>execlp()</code>函数会从PATH 环境变量所指的目录中查找符合参数<code>file</code>的文件名，找到后便执行该文件</strong>，然后将第二个以后的参数当做该文件的<code>argv[0]</code>、<code>argv[1]</code>……，最后一个参数必须用空指针(NULL)作结束。</p><blockquote><p>fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“<strong>写时复制</strong>“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。<strong>在fork之后exec之前，两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个</strong>。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，<strong>由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间</strong>。</p><p>fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，以免父进程执行导致写时复制，而后子进程执行exec系统调用，因无意义的复制而造成效率的下降。</p><p><strong>fork时子进程获得父进程数据空间、堆和栈的复制</strong>，所以变量的地址（当然是虚拟地址）也是一样的。</p></blockquote><p>写出下面程序的运行结果：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">       <span class="type">pid_t</span> cld_pid;</span><br><span class="line">       <span class="type">int</span> status;</span><br><span class="line">       <span class="type">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ )&#123;</span><br><span class="line">              <span class="keyword">if</span> ((cld_pid = fork()) == <span class="number">0</span>)&#123;</span><br><span class="line">                     a+=<span class="number">1</span>;</span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">&quot;a=%d\n&quot;</span>,a);</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="keyword">else</span>&#123;</span><br><span class="line">                     b+=<span class="number">1</span>;</span><br><span class="line">                     <span class="built_in">printf</span>(<span class="string">&quot;b=%d\n&quot;</span>,b);</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       wait(&amp;status);</span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其实就是考察了如果一个进程在for循环进行fork，会产生什么样的结果，哪些变量的值已经改变，哪些变量的值没有改变。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="59.png" style="zoom:60%"><p>实际上它的运行一共产生了三个子进程：</p><p>首先父进程fork出了子进程1，同时自己执行了b自加和打印，得到<strong>b=3</strong>。此时在第一轮循环中，子进程1的变量分别为i=0，a=1，b=2。第二轮循环中，创建了子进程2，同时执行b的自加和打印，得到<strong>b=4</strong>，耗尽循环条件。而子进程2的变量为i=1，a=1，b=3。</p><p>对于子进程1，会执行a的自加和打印，得到<strong>a=2</strong>，完成第一轮循环。在第二轮循环中创建了子子进程1，并对b自加和打印，得到<strong>b=3</strong>。子子进程1的变量分别为i=1，a=2，b=2。</p><p>对于子进程2，会执行a的自加和打印，得到<strong>a=2</strong>，然后由于i=1，结束。</p><p>对于子子进程1，会执行a的自加和打印，得到<strong>a=3</strong>，而由于i已经为1，再也没有新的循环了。</p><h3 id="终止">终止</h3><p>有了父进程与子进程的概念后，我们来讨论-一下进程结束的问题。正常情况下，子进程结束后会有父进程回收子进程的资源。但是有些时候在子进程结束前，父进程已经结束或是没有<code>wait()</code>语句等待子进程结束，这时子进程就不可能被父进程处理了，需要操作系统出面解决问题。不同的系统有不同的处理方式，有的系统不允许子进程在没有父进程的情况下继续执行，而Linux和UNIX会交由1号进程(<code>init</code>) 作为父进程回收这类子进程。</p><p>UNIX:可以通过系统调用<code>exit()</code>来终止进程，父进程可以通过<strong>系统调用</strong><code>wait()</code>以等待子进程的终止。系统调用<code>wait()</code><strong>返回了终止子进程的进程标识符，以使父进程能够知道哪个子进程终止了</strong>。如果父进程终止，那么其所有子进程会以<code>init</code>进程作为父进程。因此，子进程仍然有一个父进程来收集状态和执行统计。</p><h2 id="进程间通信">进程间通信</h2><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.agedcat.com/foundation/os/162.html">参考</a></p><p><strong>进程通信 IPC</strong>就是进程间的数据交换，通常可以分为低级通信方式和高级通信方式。</p><ul><li><p><strong>低级通信方式</strong>：进程互斥与同步交换的信息量较少且效率较低，因此称这两种进程通信方式为<strong>低级进程通信方式</strong>，相应地也将<strong>P、V原语</strong>称为两条<strong>低级进程通信原语</strong>。</p></li><li><p><strong>高级通信方式</strong>：高级通信方式是指以<strong>较高</strong>效率传递<strong>大量</strong>数据的通信方式。高级通信方式主要可分为<strong>共享通信</strong>（共享存储器系统通信），<strong>消息传递</strong>（消息传递系统通信）和<strong>管道通信</strong>（管道通信系统或共享文件系统通信）三大类，这三大类又可以分为管道，命名管道，信号，消息队列，共享内存，信号量，以及套接字七小类。</p></li></ul><h3 id="高级通信方式">高级通信方式</h3><h4 id="共享存储器系统">共享存储器系统</h4><p>相互通信的进程<strong>共享某些数据结构或共享存储区</strong>。</p><blockquote><p><strong>基于共享数据结构的通信方式</strong>：诸进程通过公用某些数据结构交换信息。如生产者-消费者问题。</p><p><strong>基于共享存储区的通信方式</strong>：在存储器中划出一块共享存储区，诸进程可通过对共享存储区进行读或写来实现通信。包括建立共享存储区、附接及断接。</p></blockquote><h4 id="消息传递系统">消息传递系统</h4><p>在消息传递系统中，进程间的数据交换以消息为单位，用户直接利用系统提供的一组<strong>通信命令</strong>（原语）来实现通信。</p><p>消息传递系统因其实现方式不同可分为：</p><blockquote><p><strong>直接通信方式</strong>：发送进程将消息发送到接收进程，并将其挂在接收进程的消息队列上；接收进程从消息队列上取消息。</p><p><strong>间接通信方式</strong>：发送进程将消息发送到信箱，接收进程从信箱中取消息。</p></blockquote><p><strong>消息传递系统是实现进程通信的常用方式，这种通信方式既可以实现进程间的信息交换，也可以实现进程间的同步</strong>。</p><h5 id="消息缓冲通信">消息缓冲通信</h5><p>消息缓冲通信是<strong>直接通信</strong>方式的一种实现。</p><p>消息缓冲通信的实现思想:</p><ul><li><p>发送进程应先在自己的工作区中设置一个发送区，把欲发送的消息填入其中，然后再用<strong>发送原语</strong>将其发送出去。</p></li><li><p>接收进程调用<strong>接收原语</strong>从自己的消息缓冲队列中摘下第一个消息，并将其内容复制到自己的消息接收区内。</p></li></ul><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="19.png" style="zoom:60%"><h5 id="信箱通信">信箱通信</h5><p>信箱通信方式中，进程之间通信需要通过共享数据结构实体——信箱来进行。</p><p>信箱是一种数据结构，其中存放信件。信箱逻辑上分成信箱头和信箱体两部分。信箱头中存放有关信箱的描述。信箱体由若干格子组成，每格存放一个信件，格子的数目和大小在创建信箱时确定。</p><p>信箱通信通过<strong>信箱通信原语</strong>实现，信箱通信原语包括：</p><blockquote><p>信箱的创建和撤消：<br>消息的发送和接收：</p><blockquote><p>Send(mailbox,message);<br>Receive(mailbox,message);</p></blockquote><p>PS：进程间的消息通信存在同步关系</p></blockquote><h4 id="管道（共享文件）通信">管道（共享文件）通信</h4><p>管道（pipe）通过<strong>连接读进程和写进程的共享文件</strong>来实现读写进程之间通信。</p><p>使用管道通信时，<strong>基本上采用文件系统的原有机制实现</strong>。包括创建、打开、关闭、读写等。</p><p>管道机制应提供以下三方面的协调能力：</p><blockquote><p><strong>互斥</strong>：诸进程互斥读写管道<br><strong>同步</strong>：管道空、满情况处理<br><strong>存在</strong>：确定对方是否存在</p></blockquote><p>管道是一种半双工的通信方式，数据只能<strong>单向流动</strong>，上游进程往管道中写入数据，下游进程从管道中接收数据。如果想实现双方通信，那么需要建立两个管道。</p><p><strong>管道就是一个文件</strong>，是一种只存在于内存中的特殊的文件系统。</p><p>管道是由内核管理的一个缓冲区，缓冲区被设计成为环形的数据结构，以便管道可以被循环利用（循环队列）。</p><h3 id="Linux系统中的进程间通信的机制（了解）">Linux系统中的进程间通信的机制（了解）</h3><h4 id="管道">管道</h4><p>首先应该就是我们最熟悉的管道了。如果你学过 Linux 命令，那你肯定使用过<code>|</code>这个竖线。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ps auxf | grep mysql</span><br></pre></td></tr></table></figure><p>上面命令行里的<code>|</code>竖线就是一个<strong>管道</strong>，它的功能是将前一个命令<code>ps auxf</code>的输出，作为后一个命令<code>grep mysql</code>的输入，从这功能描述，可以看出管道<strong>传输数据是单向的</strong>，如果想相互通信，我们需要创建两个管道才行。</p><p>管道的类型有可以分为<strong>无名管道</strong>和<strong>有名管道</strong>两种。有名管道和无名管道的读写方式是相同的。</p><p>管道的一个缺点：<strong>管道这种通信方式效率低，不适合进程间频繁地交换数据</strong></p><p>其实，<strong>所谓的管道，就是内核里面的一串缓存</strong>。从管道的一段写入的数据，实际上是缓存在内核中的，另一端读取，也就是从内核中读取这段数据。另外，<strong>管道传输的数据是无格式的流且大小受限</strong>。</p><p>管道分为有名管道和无名管道</p><ul><li><p><strong>无名管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用</strong>。进程的亲缘关系一般指的是父子关系。无名管道一般用于两个不同进程之间的通信。当一个进程创建了一个管道,并调用fork创建自己的一个子进程后，父进程关闭读管道端，子进程关闭写管道端，这样提供了两个进程之间数据流动的一种方式。</p></li><li><p><strong>有名管道也是一种半双工的通信方式，但是它允许无亲缘关系进程间的通信</strong>。</p></li><li><p>无名管道：优点：简单方便；缺点：1）局限于单向通信2）只能创建在它的进程以及其有亲缘关系的进程之间;3）缓冲区有限；</p></li><li><p>有名管道：优点：可以实现任意关系的进程间的通信；缺点：1）长期存于系统中，使用不当容易出错；2）缓冲区有限</p></li></ul><h4 id="消息队列">消息队列</h4><p>前面提到管道的通信方式效率较低，因此<strong>管道不适合进程间频繁地交换数据</strong>。</p><p>对于这个问题，<strong>消息队列</strong>的通信模式就可以解决。比如，A 进程要给 B 进程发送消息，A 进程把数据放在对应的消息队列后就可以正常返回了，B 进程需要的时候再去读取数据就可以了。同理，B 进程要给 A 进程发送消息也是如此。</p><p>下面我们来了解一下消息机制：</p><p>UNIX的消息机制中使用了两种数据结构:</p><blockquote><p><strong>消息首部</strong>：消息首部中记录消息的类型、大小、指向消息数据区的指针、消息队列的链接指针等。<br><strong>消息队列头标</strong>：每个消息队列的消息头标中，包含了指向消息队列中第一个消息的指针和指向最后一个消息的指针，队列中消息的数目，队列中消息数据的总字节数，队列所允许的消息数据的最大字节总数，还可以含有最近一次执行发送操作的进程标识号和时间等。</p></blockquote><p><strong>消息队列是保存在内核中的消息链表</strong>，在发送数据时，会分成一个一个独立的数据单元，也就是消息体（数据块），<strong>消息体是用户自定义的数据类型，消息的发送方和接收方要约定好消息体的数据类型，所以每个消息体都是固定大小的存储块</strong>，不像管道是无格式的字节流数据。如果进程从消息队列中读取了消息体，内核就会把这个消息体删除。</p><p><strong>消息队列生命周期随内核，如果没有释放消息队列或者没有关闭操作系统，消息队列会一直存在，而前面提到的匿名管道的生命周期，是随进程的创建而建立，随进程的结束而销毁</strong>。</p><p>消息这种模型，两个进程之间的通信就像平时发邮件一样，你来一封，我回一封，可以频繁沟通了。</p><p><strong>但邮件的通信方式存在不足的地方有两点，一是通信不及时，二是附件也有大小限制，这同样也是消息队列通信不足的点</strong>。</p><p>消息队列不适合比较大数据的传输，因为在内核中每个消息体都有一个最大长度的限制，同时所有队列所包含的全部消息体的总长度也是有上限。在 Linux 内核中，会有两个宏定义 MSGMAX 和 MSGMNB，它们以字节为单位，分别定义了一条消息的最大长度和一个队列的最大长度。</p><p>消息队列通信过程中，存在用户态与内核态之间的数据拷贝开销，因为进程写入数据到内核中的消息队列时，会发生从用户态拷贝数据到内核态的过程，同理另一进程读取内核中的消息数据时，会发生从内核态拷贝数据到用户态的过程。</p><h4 id="共享内存">共享内存</h4><p>消息队列的读取和写入的过程，都会有发生用户态与内核态之间的消息拷贝过程。那<strong>共享内存</strong>的方式，就很好的解决了系统开销大的问题。</p><p><strong>共享内存可使若干进程共享主存中的某一个区域，且使该区域出现在多个进程的虚地址空间中</strong>。<strong>当进程间欲利用共享内存进行通信时，必须首先在主存中建立一个共享存储区，然后将它附接到自己的虚地址空间上</strong>。此后，进程对该区的访问操作，与对其虚地址空间中其他部分的操作完全相同。进程之间以后便可以通过对共享存储区中数据的读/写来进行直接通信。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="20.png" style="zoom:60%"><p>现代操作系统，对于内存管理，采用的是虚拟内存技术，也就是<strong>每个进程都有自己独立的虚拟内存空间，不同进程的虚拟内存映射到不同的物理内存中</strong>。所以，即使进程 A 和 进程 B 的虚拟地址是一样的，其实访问的是不同的物理内存地址，对于数据的增删查改互不影响。</p><p>共享内存的机制，就是拿出一块虚拟地址空间来，映射到相同的物理内存中。这样这个进程写入的东西，另外一个进程马上就能看到了，都不需要拷贝来拷贝去，传来传去，大大提高了进程间通信的速度。</p><h4 id="信号">信号</h4><p>软中断信号（简称信号）是一种实现进程间简单通信的设施，用于通知对方发生了异常事件。</p><p>软中断是对硬件中断的一种模拟，接收进程在收到软中断信号后，将按照事先的规定去执行一个软中断处理程序。</p><p>软中断处理程序必须等到接收进程执行时才能生效。</p><p>运行在 shell 终端的进程，我们可以通过键盘输入某些组合键的时候，给进程发送信号。例如</p><ul><li><code>Ctrl+C</code> 产生 <code>SIGINT</code> 信号，表示终止该进程；</li><li><code>Ctrl+Z</code> 产生 <code>SIGTSTP</code> 信号，表示停止该进程，但还未结束；</li></ul><p>信号是进程间通信机制中唯一的<strong>异步通信机制</strong>，因为可以在任何时候发送信号给某一进程，一旦有信号产生，我们就有下面这几种，用户进程对信号的处理方式。</p><ol><li><strong>执行默认操作</strong>。Linux 对每种信号都规定了默认操作，例如，上面列表中的 <code>SIGTERM</code> 信号，就是终止进程的意思。Core 的意思是 Core Dump，也即终止进程后，通过 Core Dump 将当前进程的运行状态保存在文件里面，方便程序员事后进行分析问题在哪里。</li><li><strong>捕捉信号</strong>。我们可以为信号定义一个信号处理函数。当信号发生时，我们就执行相应的信号处理函数。</li><li><strong>忽略信号</strong>。当我们不希望处理某些信号的时候，就可以忽略该信号，不做任何处理。有两个信号是应用进程无法捕捉和忽略的，即 <code>SIGKILL</code> 和 <code>SEGSTOP</code>，它们用于在任何时候中断或结束某一进程。</li></ol><h4 id="Socket">Socket</h4><p>前面提到的管道、消息队列、共享内存、信号量和信号都是在同一台主机上进行进程间通信，那要想跨网络与不同主机上的进程之间通信，就需要 <code>Socket</code> 通信了。</p><p>实际上，<code>Socket</code> 通信不仅可以跨网络与不同主机的进程间通信，还可以在同主机上进程间通信。</p><p>根据创建 socket 类型的不同，通信的方式也就不同：</p><blockquote><p>实现 TCP 字节流通信： socket 类型是 AF_INET 和 SOCK_STREAM；<br>实现 UDP 数据报通信：socket 类型是 AF_INET 和 SOCK_DGRAM；<br>实现本地进程间通信： 「本地字节流 socket 」类型是 AF_LOCAL 和 SOCK_STREAM，「本地数据报 socket 」类型是 AF_LOCAL 和 SOCK_DGRAM。另外，AF_UNIX 和 AF_LOCAL 是等价的，所以 AF_UNIX 也属于本地 socket；</p></blockquote><p>接下来，简单说一下这三种通信的编程模式。</p><ul><li><h5 id="针对-TCP-协议通信的-socket-编程模型">针对 TCP 协议通信的 socket 编程模型</h5></li></ul><blockquote><ul><li>服务端和客户端初始化 socket，得到文件描述符；</li><li>服务端调用 bind，将绑定在 IP 地址和端口;</li><li>服务端调用 listen，进行监听；</li><li>服务端调用 accept，等待客户端连接；</li><li>客户端调用 connect，向服务器端的地址和端口发起连接请求；</li><li>服务端 accept 返回用于传输的 socket 的文件描述符；</li><li>客户端调用 write 写入数据；服务端调用 read 读取数据；</li><li>客户端断开连接时，会调用 close，那么服务端 read 读取数据的时候，就会读取到了 EOF，待处理完数据后，服务端调用 close，表示连接关闭。<br>这里需要注意的是，服务端调用 accept 时，连接成功了会返回一个已完成连接的 socket，后续用来传输数据。</li></ul></blockquote><p>所以，监听的 socket 和真正用来传送数据的 socket，是「两个」 socket，一个叫作监听 socket，一个叫作已完成连接 socket。</p><p>成功连接建立之后，双方开始通过 read 和 write 函数来读写数据，就像往一个文件流里面写东西一样。</p><ul><li><h5 id="针对-UDP-协议通信的-socket-编程模型">针对 UDP 协议通信的 socket 编程模型</h5></li></ul><p>UDP 是没有连接的，所以不需要三次握手，也就不需要像 TCP 调用 listen 和 connect，但是 UDP 的交互仍然需要 IP 地址和端口号，因此也需要 bind。</p><p>对于 UDP 来说，不需要要维护连接，那么也就没有所谓的发送方和接收方，甚至都不存在客户端和服务端的概念，只要有一个 socket 多台机器就可以任意通信，因此每一个 UDP 的 socket 都需要 bind。</p><p>另外，每次通信时，调用 sendto 和 recvfrom，都要传入目标主机的 IP 地址和端口。</p><ul><li><h5 id="针对本地进程间通信的-socket-编程模型">针对本地进程间通信的 socket 编程模型</h5></li></ul><p>本地 socket 被用于在同一台主机上进程间通信的场景：</p><p>本地 socket 的编程接口和 IPv4 、IPv6 套接字编程接口是一致的，可以支持「字节流」和「数据报」两种协议；</p><p>本地 socket 的实现效率大大高于 IPv4 和 IPv6 的字节流、数据报 socket 实现；</p><p>对于本地字节流 socket，其 socket 类型是 AF_LOCAL 和 SOCK_STREAM。</p><p>对于本地数据报 socket，其 socket 类型是 AF_LOCAL 和 SOCK_DGRAM。</p><p>本地字节流 socket 和 本地数据报 socket 在 bind 的时候，不像 TCP 和 UDP 要绑定 IP 地址和端口，而是绑定一个本地文件，这也就是它们之间的最大区别。</p><h1>第三章习题拾遗</h1><h2 id="阻塞与唤醒">阻塞与唤醒</h2><p>可能将进程唤醒的是</p><ul><li>IO结束（可能）</li><li>某进程退出临界区（可能）</li><li>当前进程时间片用完（不会）</li></ul><p>时间片用完会发生时钟中断，从就绪队列调度一个进程进入运行态，而不会唤醒阻塞队列的进程</p><p>记住：<strong>阻塞与唤醒是互斥操作</strong>即可</p><h3 id="临界区">临界区</h3><blockquote><p>什么是临界区？<br>每个进程中访问临界资源的那段程序称为临界区（临界资源是一次仅允许一个进程使用的共享资源）。每次只准许一个进程进入临界区，进入后不允许其他进程进入。</p><p>进程进入临界区的调度原则<br>①如果有若干进程要求进入空闲的临界区，一次仅允许一个进程进入。</p><p>②任何时候，处于临界区内的进程不可多于一个。如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待。</p><p>③进入临界区的进程要在有限时间内退出，以便其它进程能及时进入自己的临界区。</p><p>④如果进程不能进入自己的临界区，则应让出CPU，避免进程出现“忙等”现象。</p><p>互斥对象是一种最简单的内核对象，用它可以方便的实现对某一资源的互斥访问。因为它是内核对象，因此可以产生信号，实际上，程序中就是利用这一点实现互斥的。<br>临界区并不是内核对象，而是系统提供的一种数据结构，程序中可以声明一个该类型变量，之后用它来实现对资源的互斥访问。当欲访问某一临界资源时，先将该临界区加锁（如果临界区不空闲，等待），用完该资源后，将临界区释放。</p><p>一般，将他们用于线程间的同步，而且通常可以互换使用。</p><p>如果要实现复杂互斥，应使用其它方法，如信号量内核对象等。临界区对象不能跨越进程，是线程间共享数据区的同步对象；互斥对象可以作为进程间共享数据区的同步对象。</p></blockquote><p>所以一个进程退出临界区可能会唤醒另一个等待访问临界区的进程。</p><h2 id="父子进程不能共享虚拟地址空间">父子进程不能共享虚拟地址空间</h2><blockquote><p>fork（）会产生一个和父进程完全相同的子进程，但子进程在此后多会exec系统调用，出于效率考虑，linux中引入了“写时复制“技术，也就是只有进程空间的各段的内容要发生变化时，才会将父进程的内容复制一份给子进程。<strong>在fork之后exec之前，两个进程用的是相同的物理空间（内存区），子进程的代码段、数据段、堆栈都是指向父进程的物理空间，也就是说，两者的虚拟空间不同，但其对应的物理空间是同一个</strong>。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间，如果不是因为exec，内核会给子进程的数据段、堆栈段分配相应的物理空间（至此两者有各自的进程空间，互不影响），而代码段继续共享父进程的物理空间（两者的代码完全相同）。而如果是因为exec，<strong>由于两者执行的代码不同，子进程的代码段也会分配单独的物理空间</strong>。</p><p>fork之后内核会通过将子进程放在队列的前面，以让子进程先执行，以免父进程执行导致写时复制，而后子进程执行exec系统调用，因无意义的复制而造成效率的下降。</p><p><strong>fork时子进程获得父进程数据空间、堆和栈的复制</strong>，所以变量的地址（当然是虚拟地址）也是一样的。</p></blockquote><h2 id="虚拟地址空间">虚拟地址空间</h2><p><strong>单片机的 CPU 是直接操作内存的「物理地址」</strong>。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="21.png" style="zoom:80%"><p><strong>在这种情况下，要想在内存中同时运行两个程序是不可能的</strong>。如果第一个程序在 2000 的位置写入一个新的值，将会擦掉第二个程序存放在相同位置上的所有内容，所以同时运行两个程序是根本行不通的，这两个程序会立刻崩溃。</p><blockquote><p>操作系统是如何解决这个问题呢？</p></blockquote><p>这里关键的问题是这两个程序都引用了绝对物理地址，而这正是我们最需要避免的。</p><p>我们可以把进程所使用的地址「隔离」开来，即让操作系统为每个进程分配独立的一套「<strong><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1964845950%7D">虚拟地址</a></strong>」，互不干涉。但是有个前提每个进程都不能访问物理地址，至于虚拟地址最终怎么落到物理内存里，对进程来说是透明的，操作系统已经把这些都安排的明明白白了。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="22.png" style="zoom:80%"><p><strong>操作系统会提供一种机制，将不同进程的虚拟地址和不同内存的物理地址映射起来。</strong></p><p>如果程序要访问虚拟地址的时候，由操作系统转换成不同的物理地址，这样不同的进程运行的时候，写入的是不同的物理地址，这样就不会冲突了。</p><p>于是，这里就引出了两种地址的概念：</p><ul><li>我们程序所使用的内存地址叫做<strong>虚拟内存地址</strong>（<em>Virtual Memory Address</em>）</li><li>实际存在硬件里面的空间地址叫<strong>物理内存地址</strong>（<em>Physical Memory Address</em>）。</li></ul><p>操作系统引入了虚拟内存，<strong>进程持有的虚拟地址会通过 CPU 芯片中的内存管理单元（MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存</strong>，如下图所示：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="23.png" style="zoom:60%"><blockquote><p>操作系统是如何管理虚拟地址与物理地址之间的关系？</p></blockquote><p>主要有两种方式，分别是<strong>内存分段和内存分页</strong>，分段是比较早提出的，我们先来看看内存分段。</p><hr><h3 id="内存分段"><strong>内存分段</strong></h3><p>程序是由若干个逻辑分段组成的，如可由代码分段、数据分段、栈段、堆段组成。<strong>不同的段是有不同的属性的，所以就用分段（Segmentation）的形式把这些段分离出来。</strong></p><blockquote><p>分段机制下，虚拟地址和物理地址是如何映射的？</p></blockquote><p>分段机制下的虚拟地址由两部分组成，<strong>段选择子</strong>和<strong>段内偏移量</strong>。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="24.jpg" style="zoom:80%"><ul><li><strong>段选择子</strong>就保存在段寄存器里面。段选择子里面最重要的是<strong>段号</strong>，用作段表的索引。<strong>段表</strong>里面保存的是这个<strong>段的基地址、段的界限和特权等级</strong>等。</li><li>虚拟地址中的<strong>段内偏移量</strong>应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。</li></ul><p>在上面，知道了虚拟地址是通过<strong>段表</strong>与物理地址进行映射的，分段机制会把程序的虚拟地址分成 4 个段，每个段在段表中有一个项，在这一项找到段的基地址，再加上<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E5%81%8F%E7%A7%BB%E9%87%8F&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1964845950%7D">偏移量</a>，于是就能找到物理内存中的地址，如下图：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="25.jpg" style="zoom:70%"><p>如果要访问段 3 中偏移量 500 的虚拟地址，我们可以计算出物理地址为，段 3 基地址 7000 + 偏移量 500 = 7500。</p><p>分段的办法很好，解决了程序本身不需要关心具体的物理内存地址的问题，但它也有一些不足之处：</p><ul><li>第一个就是<strong>内存碎片</strong>的问题。</li><li>第二个就是<strong>内存交换的效率低</strong>的问题。</li></ul><p>接下来，说说为什么会有这两个问题。</p><blockquote><p>我们先来看看，分段为什么会产生内存碎片的问题？</p></blockquote><p>我们来看看这样一个例子。假设有 1G 的物理内存，用户执行了多个程序，其中：</p><ul><li>游戏占用了 512MB 内存</li><li>浏览器占用了 128MB 内存</li><li>音乐占用了 256 MB 内存。</li></ul><p>这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 = 256MB。</p><p>如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="26.jpg" style="zoom:80%"><p>这里的内存碎片的问题：</p><ul><li><strong>外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载；</strong></li></ul><p>解决外部内存碎片的问题就是<strong>内存交换</strong>。</p><p>可以把音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p><p>这个内存交换空间，在 Linux 系统里，也就是我们常看到的 Swap 空间，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p><blockquote><p>再来看看，分段为什么会导致内存交换效率低的问题？</p></blockquote><p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 <code>Swap</code> 内存区域，这个过程会产生性能瓶颈。</p><p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。</p><p>所以，<strong>如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</strong></p><p>为了解决内存分段的内存碎片和内存交换效率低的问题，就出现了内存分页。</p><hr><h3 id="内存分页"><strong>内存分页</strong></h3><p><strong>分段的好处就是能产生连续的内存空间，但是会出现内存碎片和内存交换的空间太大的问题</strong>。</p><p>要解决这些问题，那么就要想出能少出现一些内存碎片的办法。另外，当需要进行内存交换的时候，让需要交换写入或者从磁盘装载的数据更少一点，这样就可以解决问题了。这个办法，也就是<strong>内存分页</strong>（<em>Paging</em>）。</p><p><strong>分页是把整个虚拟和物理内存空间切成一段段固定尺寸的大小</strong>。这样一个连续并且尺寸固定的内存空间，我们叫<strong>页</strong>（<em>Page</em>）。在 Linux 下，每一页的大小为 <code>4KB</code>。</p><p>虚拟地址与物理地址之间通过<strong>页表</strong>来映射，如下图：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="27.jpg" style="zoom:60%"><p>页是存储在内存力，由 CPU 的<strong>内存管理单元</strong> （<em>MMU</em>） 负责映射转换的工作，这样CPU 就可以直接通过 MMU，找出要实际要访问的物理内存地址。</p><p><strong>而当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常，进入系统内核空间分配物理内存、更新进程页表，最后再返回用户空间，恢复进程的运行</strong>。</p><blockquote><p>分页是怎么解决分段的内存碎片、内存交换效率低的问题？</p></blockquote><p>由于内存空间都是预先划分好的，也就不会像分段会产生间隙非常小的内存，这正是分段会产生内存碎片的原因。而<strong>采用了分页，那么释放的内存都是以页为单位释放的，也就不会产生无法给进程使用的小内存。</strong></p><p>如果内存空间不够，操作系统会把其他正在运行的进程中的「最近没被使用」的内存页面给释放掉，也就是暂时写在硬盘上，称为<strong>换出</strong>（<em>Swap Out</em>）。一旦需要的时候，再加载进来，称为<strong>换入</strong>（<em>Swap In</em>）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，<strong>内存交换的效率就相对比较高。</strong></p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="28.jpg" style="zoom:80%"><p>更进一步地，<strong>分页的方式使得我们在加载程序的时候，不再需要一次性都把程序加载到物理内存中</strong>。我们完全可以在进行虚拟内存和物理内存的页之间的映射之后，并不真的把页加载到物理内存里，而是<strong>只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。</strong></p><blockquote><p>分页机制下，虚拟地址和物理地址是如何映射的？</p></blockquote><p>在分页机制下，虚拟地址分为两部分，<strong>页号</strong>和<strong>页内偏移</strong>。页号作为页表的索引，<strong>页表</strong>包含物理页每页所在<strong>物理内存的基地址</strong>，这个基地址与页内偏移的组合就形成了物理内存地址，见下图。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="29.jpg" style="zoom:80%"><p>总结一下，对于一个内存地址转换，其实就是这样三个步骤：</p><ul><li>把虚拟内存地址，切分成页号和偏移量；</li><li>根据页号，从页表里面，查询对应的物理页号；</li><li>直接拿物理页号，加上前面的偏移量，就得到了物理内存地址。</li></ul><p>下面举个例子，虚拟内存中的页通过页表映射为了物理内存中的页，如下图：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="30.jpg" style="zoom:60%"><p>这看起来似乎没什么毛病，但是放到实际中操作系统，这种简单的分页是肯定是会有问题的。</p><blockquote><p>简单的分页有什么缺陷吗？</p></blockquote><p>有空间上的缺陷。</p><p>因为操作系统是可以同时运行非常多的进程的，那这不就意味着页表会非常的庞大。</p><p>在 32 位的环境下，虚拟地址空间共有 4GB，假设一个页的大小是 4KB（2^12），那么就需要大约 100 万 （2^20） 个页，每个「页表项」需要 4 个字节大小来存储，那么整个 4GB 空间的映射就需要有 <code>4MB</code> 的内存来存储页表。</p><p>这 4MB 大小的页表，看起来也不是很大。但是要知道每个进程都是有自己的虚拟地址空间的，也就说都有自己的页表。</p><p>那么，<code>100</code> 个进程的话，就需要 <code>400MB</code> 的内存来存储页表，这是非常大的内存了，更别说 64 位的环境了。</p><h3 id="多级页表"><strong>多级页表</strong></h3><p>要解决上面的问题，就需要采用的是一种叫作<strong>多级页表</strong>（<em>Multi-Level Page Table</em>）的解决方案。</p><p>在前面我们知道了，对于单页表的实现方式，在 32 位和页大小 <code>4KB</code> 的环境下，一个进程的页表需要装下 100 多万个「页表项」，并且每个页表项是占用 4 字节大小的，于是相当于每个页表需占用 4MB 大小的空间。</p><p>我们把这个 100 多万个「页表项」的单级页表再分页，将页表（一级页表）分为 <code>1024</code> 个页表（二级页表），每个表（二级页表）中包含 <code>1024</code> 个「页表项」，形成<strong>二级分页</strong>。如下图所示：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="31.jpg" style="zoom:80%"><blockquote><p>你可能会问，分了二级表，映射 4GB 地址空间就需要 4KB（一级页表）+ 4MB（二级页表）的内存，这样占用空间不是更大了吗？</p></blockquote><p>当然如果 4GB 的虚拟地址全部都映射到了物理内存上的话，二级分页占用空间确实是更大了，但是，我们往往不会为一个进程分配那么多内存。</p><p>其实我们应该换个角度来看问题，还记得计算机组成原理里面无处不在的<strong>局部性原理</strong>么？</p><p>每个进程都有 4GB 的虚拟地址空间，而显然对于大多数程序来说，其使用到的空间远未达到 4GB，因为会存在部分对应的页表项都是空的，根本没有分配，对于已分配的页表项，如果存在最近一定时间未访问的页表，在物理内存紧张的情况下，操作系统会将页面换出到硬盘，也就是说不会占用物理内存。</p><p>如果使用了二级分页，一级页表就可以覆盖整个 4GB 虚拟地址空间，但<strong>如果某个一级页表的页表项没有被用到，也就不需要创建这个<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E9%A1%B5%E8%A1%A8&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1964845950%7D">页表</a>项对应的二级页表了，即可以在需要时才创建二级页表</strong>。做个简单的计算，假设只有 20% 的一级页表项被用到了，那么页表占用的内存空间就只有 4KB（一级页表） + 20% * 4MB（二级页表）= <code>0.804MB</code>，这对比单级页表的 <code>4MB</code> 是不是一个巨大的节约？</p><p>那么为什么不分级的页表就做不到这样节约内存呢？我们从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址。假如虚拟地址在页表中找不到对应的页表项，计算机系统就不能工作了。所以<strong>页表一定要覆盖全部虚拟地址空间，不分级的页表就需要有 100 多万个页表项来映射，而二级分页则只需要 1024 个页表项</strong>（此时一级页表覆盖到了全部虚拟地址空间，二级页表在需要时创建）。</p><p>我们把二级分页再推广到多级页表，就会发现页表占用的内存空间更少了，这一切都要归功于对<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E5%B1%80%E9%83%A8%E6%80%A7%E5%8E%9F%E7%90%86&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1964845950%7D">局部性原理</a>的充分应用。</p><p>对于 64 位的系统，两级分页肯定不够了，就变成了四级目录，分别是：</p><ul><li>全局页目录项 PGD（<em>Page Global Directory</em>）；</li><li>上层页目录项 PUD（<em>Page Upper Directory</em>）；</li><li>中间页目录项 PMD（<em>Page Middle Directory</em>）；</li><li>页表项 PTE（<em>Page Table Entry</em>）；</li></ul><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="32.jpg" style="zoom:80%"><h3 id="TLB"><strong>TLB</strong></h3><p>多级页表虽然解决了空间上的问题，但是虚拟地址到物理地址的转换就多了几道转换的工序，这显然就降低了这俩地址转换的速度，也就是带来了时间上的开销。</p><p>程序是有局部性的，即在一段时间内，整个程序的执行仅限于程序中的某一部分。相应地，执行所访问的存储空间也局限于某个内存区域。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="33.jpg" style="zoom:60%"><p>我们就可以利用这一特性，<strong>把最常访问的几个页表项存储到访问速度更快的硬件</strong>，于是计算机科学家们，就在 CPU 芯片中，<strong>加入了一个专门存放程序最常访问的页表项的 Cache</strong>，这个 Cache 就是 TLB（<em>Translation Lookaside Buffer</em>） ，<strong>通常称为页表缓存、转址旁路缓存、快表</strong>等。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="34.jpg" style="zoom:60%"><p>在 CPU 芯片里面，封装了内存管理单元（<em>Memory Management Unit</em>）芯片，它用来完成地址转换和 TLB 的访问与交互。</p><p>有了 TLB 后，那么 CPU 在寻址时，会先查 TLB，如果没找到，才会继续查常规的页表。</p><p>TLB 的命中率其实是很高的，因为程序最常访问的页就那么几个。</p><hr><h3 id="段页式内存管理"><strong>段页式内存管理</strong></h3><p>内存分段和内存分页并不是对立的，它们是可以组合起来在同一个系统中使用的，那么组合起来后，通常称为<strong>段页式内存管理</strong>。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="35.png" style="zoom:70%"><p>段页式内存管理实现的方式：</p><ul><li>先将程序划分为多个有逻辑意义的段，也就是前面提到的分段机制；</li><li>接着再把每个段划分为多个页，也就是对分段划分出来的连续空间，再划分固定大小的页；</li></ul><p>这样，地址结构就由<strong>段号、段内页号和页内位移</strong>三部分组成。</p><p>用于段页式地址变换的数据结构是每一个程序一张段表，每个段又建立一张页表，段表中的地址是页表的起始地址，而页表中的地址则为某页的物理页号，如图所示：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="36.jpg" style="zoom:80%"><p>段页式地址变换中要得到物理地址须经过三次内存访问：</p><ul><li>第一次访问段表，得到页表起始地址；</li><li>第二次访问页表，得到物理页号；</li><li>第三次将物理页号与页内位移组合，得到物理地址。</li></ul><p>可用软、硬件相结合的方法实现段页式地址变换，这样虽然增加了硬件成本和系统开销，但提高了内存的利用率。</p><hr><h3 id="Linux-内存管理"><strong>Linux 内存管理</strong></h3><p>那么，Linux 操作系统采用了哪种方式来管理内存呢？</p><blockquote><p>在回答这个问题前，我们得先看看 Intel 处理器的发展历史。</p></blockquote><p>早期 Intel 的处理器从 80286 开始使用的是段式内存管理。但是很快发现，光有段式内存管理而没有页式内存管理是不够的，这会使它的 X86 系列会失去市场的竞争力。因此，在不久以后的 80386 中就实现了对页式内存管理。也就是说，80386 除了完成并完善从 80286 开始的段式内存管理的同时还实现了页式内存管理。</p><p>但是这个 80386 的页式内存管理设计时，没有绕开段式内存管理，而是建立在段式内存管理的基础上，这就意味着，<strong>页式内存管理的作用是在由段式内存管理所映射而成的地址上再加上一层地址映射。</strong></p><p>由于此时由段式内存管理映射而成的地址不再是“物理地址”了，Intel 就称之为“线性地址”（也称虚拟地址）。于是，段式内存管理先将逻辑地址映射成线性地址，然后再由页式内存管理将线性地址映射成物理地址。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="37.png" style="zoom:60%"><p>这里说明下逻辑地址和线性地址：</p><ul><li>程序所使用的地址，通常是没被段式内存管理映射的地址，称为逻辑地址；</li><li>通过段式内存管理映射的地址，称为线性地址，也叫虚拟地址；</li></ul><p>逻辑地址是「段式内存管理」转换前的地址，线性地址则是「页式内存管理」转换前的地址。</p><blockquote><p>了解完 Intel 处理器的发展历史后，我们再来说说 Linux 采用了什么方式管理内存？</p></blockquote><p><strong>Linux 内存主要采用的是页式内存管理，但同时也不可避免地涉及了段机制</strong>。</p><p>这主要是上面 Intel 处理器发展历史导致的，因为 Intel X86 CPU 一律对程序中使用的地址先进行段式映射，然后才能进行页式映射。既然 CPU 的硬件结构是这样，Linux 内核也只好服从 Intel 的选择。</p><p>但是事实上，Linux 内核所采取的办法是使段式映射的过程实际上不起什么作用。也就是说，“上有政策，下有对策”，若惹不起就躲着走。</p><p><strong>Linux 系统中的每个段都是从 0 地址开始的整个 4GB 虚拟空间（32 位环境下），也就是所有的段的起始地址都是一样的。这意味着，Linux 系统中的代码，包括操作系统本身的代码和应用程序代码，所面对的地址空间都是线性地址空间（虚拟地址），这种做法相当于屏蔽了处理器中的逻辑地址概念，段只被用于访问控制和内存保护。</strong></p><blockquote><p>我们再来瞧一瞧，Linux 的虚拟地址空间是如何分布的？</p></blockquote><p>在 Linux 操作系统中，虚拟地址空间的内部又被分为<strong>内核空间和用户空间</strong>两部分，不同位数的系统，地址空间的范围也不同。比如最常见的 32 位和 64 位系统，如下所示：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="38.jpg" style="zoom:80%"><p>通过这里可以看出：</p><ul><li><code>32</code> 位系统的内核空间占用 <code>1G</code>，位于最高处，剩下的 <code>3G</code> 是用户空间；</li><li><code>64</code> 位系统的内核空间和用户空间都是 <code>128T</code>，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。</li></ul><p>再来说说，内核空间与用户空间的区别：</p><ul><li>进程在用户态时，只能访问用户空间内存；</li><li>只有进入内核态后，才可以访问内核空间的内存；</li></ul><p>虽然每个进程都各自有独立的虚拟内存，但是<strong>每个虚拟内存中的内核地址，其实关联的都是相同的物理内存</strong>。这样，进程切换到内核态后，就可以很方便地访问内核空间内存。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="39.jpg" style="zoom:60%"><p>接下来，进一步了解虚拟空间的划分情况，用户空间和内核空间划分的方式是不同的，内核空间的分布情况就不多说了。</p><p>我们看看用户空间分布的情况，以 32 位系统为例，我画了一张图来表示它们的关系：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="40.jpg" style="zoom:60%"><p>通过这张图你可以看到，用户空间内存，从<strong>低到高</strong>分别是 7 种不同的内存段：</p><ul><li>程序文件段，包括<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E4%BA%8C%E8%BF%9B%E5%88%B6&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1964845950%7D">二进制</a>可执行代码；</li><li>已初始化数据段，包括静态常量；</li><li>未初始化数据段，包括未初始化的静态变量；</li><li>堆段，包括动态分配的内存，从低地址开始向上增长；</li><li>文件映射段，包括动态库、共享内存等，从低地址开始向上增长（<strong><a href="https://link.zhihu.com/?target=http%3A//lishiwen4.github.io/linux/linux-process-memory-location" rel="external nofollow noreferrer">跟硬件和内核版本有关</a></strong>）；</li><li>栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 <code>8 MB</code>。当然系统也提供了参数，以便我们自定义大小；</li></ul><p>在这 7 个内存段中，堆和文件映射段的内存是动态分配的。比如说，使用 C 标准库的 <code>malloc()</code>或者 <code>mmap()</code> ，就可以分别在堆和文件映射段动态分配内存。</p><h1>第四章：线程</h1><h2 id="单线程与多线程">单线程与多线程</h2><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="41.png" style="zoom:60%"><p><strong>引入线程后CPU调度进程以进程的线程为单位</strong>。</p><p>在多线程的模型中，每个线程也有自己的控制块，也会把寄存器内容进行保存，有自己的栈（并不意味着有自己的地址空间/内存空间）。</p><p>为什么对于大多数合作性任务，多线程比多个独立的进程更优越呢？这是因为，<strong>线程共享相同的内存空间</strong>。不同的线程可以存取内存中的同一个变量。所以，程序中的所有线程都可以读或写声明过的全局变量。</p><p>如果曾用 <code>fork()</code> 编写过重要代码，就会认识到这个工具的重要性。为什么呢？虽然 <code>fork()</code>允许创建多个进程，但它还会带来以下通信问题: 如何让多个进程相互通信，这里每个进程都有各自独立的内存空间。对这个问题没有一个简单的答案。虽然有许多不同种类的本地 IPC (进程间通信），但它们都遇到两个重要障碍：</p><ul><li><p>强加了某种形式的额外内核开销，从而<strong>降低性能</strong>。</p></li><li><p>对于大多数情形，IPC 不是对于代码的 “自然” 扩展。通常极大地<strong>增加了程序的复杂性</strong>。</p></li></ul><p>双重坏事: 开销和复杂性都非好事。如果曾经为了支持 IPC 而对程序大动干戈过，那么您就会真正欣赏线程提供的简单共享内存机制。由于所有的线程都驻留在同一内存空间，POSIX 线程无需进行开销大而复杂的长距离调用。只要利用简单的同步机制，程序中所有的线程都可以读取和修改已有的数据结构。而无需将数据经由文件描述符转储或挤入紧窄的共享内存空间。仅此一个原因，就足以让您考虑应该采用单进程/多线程模式而非多进程/单线程模式。</p><p>不仅如此，线程同样还是非常快捷的。与标准 <code>fork()</code> 相比，线程带来的开销很小。内核无需单独复制进程的内存空间或文件描述符等等。这就节省了大量的 CPU 时间，使得线程创建比新进程创建快上十到一百倍。因为这一点，可以大量使用线程而无需太过于担心带来的 CPU 或内存不足。使用 <code>fork()</code> 时导致的大量 CPU 占用也不复存在。这表示只要在程序中有意义，通常就可以创建线程。</p><p>当然，和进程一样，线程将利用多 CPU。如果软件是针对多处理器系统设计的，这就真的是一大特性（如果软件是开放源码，则最终可能在不少平台上运行）。特定类型线程程序（尤其是 CPU 密集型程序）的性能将随系统中处理器的数目几乎线性地提高。如果正在编写 CPU 非常密集型的程序，则绝对想设法在代码中使用多线程。一旦掌握了线程编码，无需使用繁琐的 IPC 和其它复杂的通信机制，就能够以全新和创造性的方法解决编码难题。所有这些特性配合在一起使得多线程编程更有趣、快速和灵活。</p><h2 id="线程概念与实现方式">线程概念与实现方式</h2><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="45.png" style="zoom:80%"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="46.png" style="zoom:80%"> <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="47.png" style="zoom:80%"><h2 id="多线程模型">多线程模型</h2><h3 id="多对一">多对一</h3><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="42.png" style="zoom:80%"><h3 id="一对一">一对一</h3><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="43.png" style="zoom:80%"><h3 id="多对多">多对多</h3><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="44.png" style="zoom:80%"><h1>第四章习题拾遗</h1><p>线程包含CPU现场，可以独立执行程序。</p><p>进程是资源分配的基本单位。</p><p>用户级线程切换不需要内核支持（由线程库完成）</p><h1>第五章：CPU调度</h1><h2 id="基本概念">基本概念</h2><h3 id="CPU-IO-burst-cycle-理解与图像">CPU/IO burst cycle 理解与图像</h3><p>进程执行由CPU执行和IO等待周期组成，进程在这两个状态之间切换。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="48.png" style="zoom:70%"><h3 id="CPU调度程序">CPU调度程序</h3><h4 id="何时可能发生调度决策">何时可能发生调度决策</h4><p>注意，只是可能发生调度</p><ul><li><p>Switches from running to waiting state</p></li><li><p>Switches from running to ready state</p></li><li><p>Switches from waiting to ready</p></li><li><p>Terminates</p></li></ul><p>1,4是非抢占式的，也就是说，是由进程自己主动让出CPU使用权。</p><p>2,3是抢占式的，由操作系统结束进程对CPU的使用</p><h4 id="抢占与非抢占的区别与相应问题">抢占与非抢占的区别与相应问题</h4><p>抢占调度对访问共享数据是有代价的。考虑两个进程共享数据的情况。 第一个进程正在更新数据时， 它被抢占以使第二个进程能够运行。第二个进程可能试图读数据，该数据现在处于不一致的状态。这种情况下需要一种新机制来协调对共享数据的访问。</p><p>抢占对于操作系统内核的设计也有影响。在处理系统调用时，内核可能忙于进程活动。这些活动可能涉及要改变重要内核数据（如IO队列）。如果个进程在进行这些修改时被抢占，内核（或设备驱动）需要读取或修改同样的结构，肯定会导致混乱。有的操作系统，包括绝大多数 UNIX 系统，通过在上下文切换之前等待系统调用完成或等待发生IO阻塞来处理这一问题。不幸的是，这种内核执行模式对实时计算和多进程的支待较差。 这些问题及其解决方案将在 5.4 和 19.5 节中讨论。</p><p>因为根据定义中断能随时发生， 而且不能总是被内核所忽视，所以受中断影响的代码段必须加以保护以避免同时访问。 操作系统需要在任何时候都能接受中断， 否则输入会丢失或输出会被改写。为了这些代码段不被多个进程同时访问，在进入时要禁止中断，而在退出时要重新允许中断。注意到禁止中断代码段发生并不频繁，而且常常只包括很少的指令。</p><h5 id="一个问题">一个问题</h5><p>进程是否可能在执行系统调用的过程中被抢占？</p><p>进程在执行系统调用的过程中不会被抢占。让我们设想进程<code>a</code>正在执行的过程中发生中断，而中断处理程序判断出系统需要被重新调度，它会设置进程<code>a</code>的<code>need_resched</code>标志（<code>need_resched</code>标志的作用参见后面说明），在中断处理程序结束之后（<code>ret_from_intr</code>），系统会检查被中断处理程序中断执行的进程的优先级，如果此时进程<code>a</code>处在用户态，系统会直接激活调度程序完成进程切 换；而如果此时进程a处在内核态，系统会不作调度而恢复进程<code>a</code>的执行，只有进程<code>a</code>完成系统调用之后（<code>ret_from_sys_call</code>），它的 <code>need_resched</code>标志才会被检查，从而完成进程切换。</p><p>进程在内核态不会被抢占的特点减少了单CPU系统中内核设计的复杂性，因为不需要考虑不同进程对内核代码和数据结构的竞争。</p><p><code>need_resched</code> 标志位。该位在从中断和系统调用中返回的时候被检查，<code>need_resched</code>为1的时候表示要求启动调度程序，这通常发生在进程的时间片已经用完，或者因为IO事件发生而强行抢占当前进程的时候。</p><h4 id="分派程序">分派程序</h4><p>分派程序是一个模块，用来将 CPU 的控制交给由短期调度程序选择的进程。 其功能包括：</p><ul><li>切换上下文。</li><li>切换到用户模式。</li><li>跳转到用户程序的合适位置， 以重新启动程序</li></ul><p>分派程序应尽可能快， 因为在每次进程切换时都要使用。 分派程序停止一个程序而启动另一个进程所花费的时间称为<strong>分派延迟</strong>。</p><h2 id="调度准则与算法">调度准则与算法</h2><h3 id="调度准则">调度准则</h3><p>准侧有很多，但<strong>等待时间为最主要衡量标准</strong>。</p><p>其余包括CPU使用率，吞吐量，响应时间。</p><h3 id="先到先服务（FCFS，First-Come-First-Served-）">先到先服务（FCFS，First-Come, First-Served ）</h3><p>先来先服务(FCFS)调度算法是一种最简单的调度算法，该算法既可用于作业调度，也可用于进程调度。</p><p>当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或多个最先进入该队列的作业，将它们调入内存，为它们分配资源、创建进程，然后放入就绪队列。</p><p>在进程调度中采用FCFS算法时，则<strong>每次调度是从就绪队列中选择一个最先进入该队列的进程</strong>，为之分配处理机，使之投入运行。</p><p><strong>该进程一直运行到完成或发生某事件而阻塞后才放弃处理机</strong>。（非抢占式）</p><p>出现的问题是如果短时进程排在长时进程后面会导致短时进程等待时间长。甘特图（经常考的图）如下：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="49.png" style="zoom:70%"><h3 id="最短作业优先调度（SJF）">最短作业优先调度（SJF）</h3><p>短作业(进程)优先调度算法，是指对短作业或短进程优先调度的算法。它们可以分别用于作业调度和进程调度。短作业优先(SJF)的调度算法是从后备队列中选择一个或若干个<strong>估计运行时间最短</strong>的作业，将它们调入内存运行。而短进程优先(SPF)调度算法则是从就绪队列中选出一个<strong>估计运行时间最短</strong>的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而被阻塞放弃处理机时再重新调度。</p><p>分为抢占式和非抢占式。</p><h4 id="非抢占式SJF">非抢占式SJF</h4><p>等到进程运行完，再到就绪队列中选取（估计）运行时间最短的进程去运行。</p><h4 id="抢占式SJF">抢占式SJF</h4><p>某个进程运行时，如果某个进程加到就绪队列，比较新进程运行时间与现在执行进程剩余的运行时间，如果新进程运行时间更短，则优先运行新进程。</p><p>甘特图如下：</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="50.png" style="zoom:70%"><h4 id="一个问题-2">一个问题</h4><p>一个进程的运行时长如何确定？显然是无法准确确定的，但我们可以估计。虽然不知道下一个CPU区间的长度，但是可以颈测它。认为下一个CPU区间的长度与以前的相似。因此，通过计算下一个CPU区间长度的近似值，能选择具有最短预测CPU区间的进程来运行。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="51.png" style="zoom:80%"><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>τ</mi><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msub><mo>=</mo><mi>α</mi><msub><mi>t</mi><mi>n</mi></msub><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo><mi>α</mi><msub><mi>t</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><msup><mo stretchy="false">)</mo><mi>j</mi></msup><mi>α</mi><msub><mi>t</mi><mrow><mi>n</mi><mo>−</mo><mi>j</mi></mrow></msub><mo>+</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo>+</mo><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><msup><mo stretchy="false">)</mo><mrow><mi>n</mi><mo>+</mo><mn>1</mn></mrow></msup><msub><mi>τ</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">\tau_{n+1}=\alpha t_n+(1-\alpha)\alpha t_{n-1}+...+(1-\alpha)^{j}\alpha t_{n-j}+...+(1-\alpha)^{n+1}\tau_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.638891em;vertical-align:-.208331em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.1132em">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:-.1132em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.208331em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2777777777777778em"></span><span class="mrel">=</span><span class="mspace" style="margin-right:.2777777777777778em"></span></span><span class="base"><span class="strut" style="height:.76508em;vertical-align:-.15em"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.151392em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">n</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.208331em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">...</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.1107719999999999em;vertical-align:-.286108em"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.824664em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span></span></span></span></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.311664em"><span style="top:-2.5500000000000003em;margin-left:0;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight" style="margin-right:.05724em">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.286108em"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.66666em;vertical-align:-.08333em"></span><span class="mord">...</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">+</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:.8141079999999999em"><span style="top:-3.063em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:.1132em">τ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.1132em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span></span></span></span></p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.43056em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>1</mn><mo>−</mo><mi>α</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(1-\alpha)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">(</span><span class="mord">1</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord mathnormal" style="margin-right:.0037em">α</span><span class="mclose">)</span></span></span></span>都小于等于1，那么后面项的权重比前面的项要小。</p><h4 id="优缺点">优缺点</h4><p>优点是 可以有效降低作业的平均等待时间，提高系统吞吐量。被认为是最佳的算法。</p><p>缺点：</p><ul><li><p>对长作业不利，周转时间与带权周转时间提升。</p></li><li><p>未考虑作业的紧迫程度。</p></li><li><p>时间长短是估计的，所以不一定会达到真正的短作业调度</p></li></ul><p>SJF调度经常用于<strong>长期调度</strong>。</p><h3 id="优先级调度">优先级调度</h3><p>为了照顾紧迫型作业，使之在进入系统后便获得优先处理，引入了最高优先权优先(FPF)调度算法。此算法常被用于批处理系统中，作为作业调度算法，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于作业调度时，系统将从后备队列中选择若干个优先权最高的作业装入内存。当用于进程调度时，该算法是<strong>把处理机分配给就绪队列中优先权最高的进程</strong>。</p><p>进程的优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>：</p><ul><li>静态优先级：创建进程的时候，就已经确定优先级了，然后整个运行时间优先级都不会变化。</li><li>动态优先级：根据进程的动态变化调整优先级，如果进程运行时间增加，降低优先级，如果进程等待时间增加，则升高优先级。</li></ul><p>进程随等待时间增加升高优先级的过程被称作老化（Aging），其实就是为了避免优先级过低的进程一直得不到执行而被饿死（Starvation）。</p><h4 id="非抢占式优先权算法">非抢占式优先权算法</h4><p>在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成；或因发生某事件使该进程放弃处理机时，系统方可再将处理机重新分配给另一优先权最高的进程。这种调度算法主要用于批处理系统中；也可用于某些对实时性要求不严的实时系统中。</p><h4 id="抢占式优先权调度算法">抢占式优先权调度算法</h4><p>在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程。</p><p>因此，在采用这种调度算法时，是每当系统中出现一个新的就绪进程<code>i</code>时，就将其优先权<code>Pi</code>与正在执行的进程<code>j</code>的优先权<code>Pj</code>进行比较。如果<code>Pi≤Pj</code>，原进程<code>Pj</code>便继续执行；但如果是<code>Pi&gt;Pj</code>，则立即停止<code>Pj</code>的执行，做进程切换，使<code>i</code>进程投入执行。显然，这种抢占式的优先权调度算法能更好地满足紧迫作业的要求，故而常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</p><h3 id="轮转法调度-RR，Round-Robin">轮转法调度(RR，Round Robin )</h3><p>在早期的时间片轮转法中，系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。</p><p>当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；如果该进程在时间片结束之前阻塞或结束，CPU也会立即切换。然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。换言之，<strong>系统能在给定的时间内响应所有用户的请求</strong>。</p><p>在该算法中，时间片的长度是一个比较关键的点：</p><ul><li>如果设置的太短会导致过多的进程上下文切换，降低CPU的效率</li><li>如果设置的太长有可能会导致短作业的响应时间变长（就变成了FCFS）</li></ul><p>一般来说，时间片的设置应为略大于一次交互的响应时间，20ms~50ms是一个折中的值。</p><h3 id="多级队列">多级队列</h3><p>将就绪队列划分成多个队列，不同队列采用不同的调度方式。同时队列之间也存在优先级，或者给队列划分时间片，高优先级的队列有更多时间片。</p><h3 id="多级反馈队列">多级反馈队列</h3><p>前面介绍的各种用作进程调度的算法都有一定的局限性。如短进程优先的调度算法，仅照顾了短进程而忽略了长进程，而且如果并未指明进程的长度，则短进程优先和基于进程长度的抢占式调度算法都将无法使用。而多级反馈队列调度算法则不必事先知道各种进程所需的执行时间，而且还可以满足各种类型进程的需要，因而它是目前被公认的一种较好的进程调度算法。</p><p>在采用多级反馈队列调度算法的系统中，调度算法的实施过程如下所述：</p><p>1）应设置多个就绪队列，并为各个队列赋予不同的优先级。第一个队列的优先级最高，第二个队列次之，其余各队列的优先权逐个降低。该算法赋予各个队列中进程执行时间片的大小也各不相同，在优先权愈高的队列中，为每个进程所规定的执行时间片就愈小。例如，第二个队列的时间片要比第一个队列的时间片长一倍，第<code>i+1</code>个队列的时间片要比第<code>i</code>个队列的时间片长一倍。</p><p>2）当一个新进程进入内存后，首先将它放入第一队列的末尾，按FCFS原则排队等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可准备撤离系统；如果它在一个时间片结束时尚未完成，调度程序便将该进程转入第二队列的末尾，再同样地按FCFS原则等待调度执行；如果它在第二队列中运行一个时间片后仍未完成，再依次将它放入第三队列，……，如此下去，当一个长作业(进程)从第一队列依次降到第n队列后，在第n队列便采取按时间片轮转的方式运行。</p><p>3）仅当第一队列空闲时，调度程序才调度第二队列中的进程运行；仅当第<code>1～(i-1)</code>队列均空时，才会调度第<code>i</code>队列中的进程运行。如果处理机正在第<code>i</code>队列中为某进程服务时，又有新进程进入优先权较高的队列(第<code>1～(i-1)</code>中的任何一个队列)，则此时新进程将抢占正在运行进程的处理机，即第<code>i</code>队列中某个正在运行的进程的时间片用完后，由调度程序选择优先权较高的队列中的那一个进程，把处理机分配给它。</p><p><strong>这种算法对于短作业来说很可能就在第一级队列就被处理完成，对于长作业来说，虽然有可能因为在第一级队列无法执行完成而被被移入到第二级队列运行（等待时间变长），但是获得时间片也会变长（运行时间变长），所以该算法很好的兼顾了长短作业，同时有较好的响应时间</strong>。</p><h2 id="Unix、Linux与Windows进程调度策略">Unix、Linux与Windows进程调度策略</h2><p>Linux 从整体上区分实时进程和普通进程，因为实时进程和普通进程度调度是不同的，它们两者之间，实时进程应该先于普通进程而运行，然后，对于同一类型的不同进程，采用不同的标准来选择进程。对普通进程的调度策略是动态优先调度，对于实时进程采用了两种调度策略，FIFO(先来先服务调度)和RR（时间片轮转调度）。</p><p>UNIX系统是单纯的分时系统，所以没有设置作业调度。UNIX系统的进程调度采用的算法是，多级反馈队列调度法。其核心思想是先从最高休先级就绪队列中取出排在队列最前面的进程，当进程执行完一个时间片仍未完成则剥夺它的执行，将它放入到相应的队列中，取出下一个就绪进程投入运行，对于同一个队列中的各个进程，按照时间片轮转法调度。多级反馈队列调度算法即能使高优先级的作业得到响应又能使短作业（进程）迅速完成。但是它还是存在某些方面的不足，当不断有新进程到来时，则长进程可能饥饿。</p><p>Windows 系统其调度方式比较复杂，它的处理器调度的调度单位是线程而不是进程，是基于优先级的抢占式多处理器调度，依据优先级和分配时间片来调度。而且Windows 2000/XP在单处理器系统和多处理器系统中的线程调度是不同的线程调度机制，Windows操作系统的调度系统总是运行优先级最高的就绪线程。在同一优先级的各线程按时间片轮转算法进行调度。如果一个高优先级的线程进入就绪状态，当前运行的线程可能在用完它的时间片之前就被抢占处理机。</p><p>多任务、有线程优先级、多种中断级别这是现代操作系统的共同特点。实时操作系统（Real-time operating system, RTOS）最大的特点是对响应时间有严格的要求，linux尚且不能称为完全的实时操作系统，USA的宇宙飞船常用的操作系统是VxWorks，这才是闻名于世的RTOS。</p><h1>第五章习题拾遗</h1><ul><li><p>哪个调度算法是绝对可抢占的？</p><ul><li>时间片流转算法</li><li>在时间片用完或进程执行完后被其他进程抢占</li><li>更详细地说并不算一种抢占而是一种调度（其实对于RR二者并无差别）</li><li>那么相对应的，<strong>RR一定不会出现饿死</strong>。</li></ul></li><li><p>计算(2)问，答案为D：</p></li></ul><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="52.png" style="zoom:80%"><ul><li>计算，答案为C</li></ul><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="53.png" style="zoom:80%"><p>首先<code>P1</code>和<code>P2</code>依次进入<code>Q1</code>，执行<code>P1</code>10ms后中断<code>P1</code>将其调入<code>Q2</code>，此时<code>Q1</code>非空，继续调度<code>Q1</code>中的进程，即执行<code>P2</code>进程10ms，同样没有执行完，调入<code>Q2</code>，此时<code>Q1</code>为空，开始调度执行<code>Q2</code>的进程，由于<code>P2</code>剩余时间少于<code>P1</code>，先调度执行进程<code>P2</code>，执行完后将<code>P1</code>执行完。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="54.png" style="zoom:80%"><h2 id="上下文切换">上下文切换</h2><p>我们都知道，Linux 是一个多任务操作系统，它支持远大于 CPU 数量的任务同时运行。当然，这些任务实际上并不是真的在同时运行，而是因为系统在很短的时间内，将 CPU 轮流分配给它们，造成多任务同时运行的错觉。</p><p>而在每个任务运行前，CPU 都需要知道任务从哪里加载、又从哪里开始运行，也就是说，需要系统事先帮它设置好<strong>CPU 寄存器和程序计数器</strong></p><h3 id="基本概念-2">基本概念</h3><h4 id="什么是-CPU-上下文">什么是 CPU 上下文</h4><p><strong>CPU 寄存器和程序计数器就是 CPU 上下文，因为它们都是 CPU 在运行任何任务前，必须的依赖环境</strong>。</p><ul><li>CPU 寄存器是 CPU 内置的容量小、但速度极快的内存。</li><li>程序计数器则是用来存储 CPU 正在执行的指令位置、或者即将执行的下一条指令位置。</li></ul><h4 id="什么是-CPU-上下文切换">什么是 CPU 上下文切换</h4><p>就是先把前一个任务的 CPU 上下文（也就是 CPU 寄存器和程序计数器）保存起来，然后加载新任务的上下文到这些寄存器和程序计数器，最后再跳转到程序计数器所指的新位置，运行新任务。</p><p>而这些保存下来的上下文，会存储在系统内核中，并在任务重新调度执行时再次加载进来。这样就能保证任务原来的状态不受影响，让任务看起来还是连续运行。</p><p>根据任务的不同，可以分为以下几种类型</p><ul><li>系统调用上下文切换</li><li>进程上下文切换</li><li>线程上下文切换</li><li>中断上下文切换</li></ul><h3 id="系统调用的上下文切换">系统调用的上下文切换</h3><p>Linux 按照特权等级，把进程的运行空间分为内核空间和用户空间，分别对应着下图中， CPU 特权等级的 Ring 0 和 Ring 3。</p><ul><li>内核空间（Ring 0）具有最高权限，可以直接访问所有资源；</li><li>用户空间（Ring 3）只能访问受限资源，不能直接访问内存等硬件设备，必须通过系统调用陷入到内核中，才能访问这些特权资源。</li></ul><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="55.png" style="zoom:80%"><p>进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。</p><p>从用户态到内核态的转变，需要通过<strong>系统调用</strong>来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。</p><p>在这个过程中就发生了 CPU 上下文切换，整个过程是这样的：</p><ul><li>保存 CPU 寄存器里原来用户态的指令位</li><li>为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。</li><li>跳转到内核态运行内核任务。</li><li>当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。</li></ul><p>所以，<strong>一次系统调用的过程，其实是发生了两次 CPU 上下文切换</strong>。（用户态-内核态-用户态）</p><p>不过，需要注意的是，<strong>系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程</strong>。这跟我们通常所说的进程上下文切换是不一样的：<strong>进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行。</strong></p><p>所以，<strong>系统调用过程通常称为特权模式切换，而不是上下文切换。系统调用属于同进程内的 CPU 上下文切换</strong>。但实际上，系统调用过程中，CPU 的上下文切换还是无法避免的。</p><h3 id="进程上下文切换">进程上下文切换</h3><p>首先，<strong>进程是由内核来管理和调度的，进程的切换只能发生在内核态</strong>。所以，进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。</p><p>因此，<strong>进程的上下文切换就比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU 寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈</strong>。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="56.png" style="zoom:60%"><p>另外，我们知道，现代操作系统通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。如果发生运行时动态链接（进入系统态）、内存紧缩等情况，即虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢，不过这是进程上下文切换带来的副作用了。</p><p><strong>发生进程上下文切换的场景</strong></p><ul><li><p>基于时间片的操作系统，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，<strong>当某个进程的时间片耗尽了</strong>，就会被系统挂起，切换到其它正在等待 CPU 的进程运行。</p></li><li><p>进程在<strong>系统资源不足</strong>（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。</p></li><li><p>当<strong>进程通过睡眠函数 <code>sleep</code> 这样的方法将自己主动挂起</strong>时，自然也会重新调度。</p></li><li><p>当<strong>有优先级更高的进程运行</strong>时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行</p></li><li><p>发生<strong>硬件中断</strong>时，CPU 上的进程会被中断挂起，转而执行内核中的中断服务程序。</p></li></ul><h4 id="进程上下文切换潜在的性能问题">进程上下文切换潜在的性能问题</h4><p>根据 Tsuna 的测试报告，每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，很容易导致 CPU 将大量时间耗费在寄存器、内核栈以及虚拟内存等资源的保存和恢复上，进而大大缩短了真正运行进程的时间。这也正是导致平均负载升高的一个重要因素。</p><p>另外，我们知道， Linux 通过 TLB（Translation Lookaside Buffer）来管理虚拟内存到物理内存的映射关系。当虚拟内存更新后，TLB 也需要刷新，内存的访问也会随之变慢。特别是在多处理器系统上，缓存是被多个处理器共享的，刷新缓存不仅会影响当前处理器的进程，还会影响共享缓存的其他处理器的进程。</p><h3 id="线程上下文切换">线程上下文切换</h3><p>线程与进程最大的区别在于：<strong>线程是调度的基本单位，而进程则是资源拥有的基本单位</strong>。说白了，所谓内核中的任务调度，实际上的调度对象是线程；而进程只是给线程提供了虚拟内存、全局变量等资源。</p><p>所以，对于线程和进程，我们可以这么理解： - 当进程只有一个线程时，可以认为进程就等于线程。 - 当进程拥有多个线程时，这些线程会共享相同的虚拟内存和全局变量等资源。这些资源在上下文切换时是不需要修改的。 - 另外，线程也有自己的私有数据，比如栈和寄存器等，这些在上下文切换时也是需要保存的。</p><h4 id="发生线程上下文切换的场景">发生线程上下文切换的场景</h4><ul><li><p>前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。此时切换线程，CPU 的各种寄存器都要重新刷一遍，从这个角度而言，你可以把进程和线程当作一种东西，只是共享度不同，其他没区别的。</p></li><li><p>前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据</p></li></ul><p>虽然同为上下文切换，但同进程内的线程切换，要比多进程间的切换消耗更少的资源，这也正是多线程代替多进程的一个优势。</p><h3 id="中断上下文切换">中断上下文切换</h3><p>为了快速响应硬件的事件，<strong>中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件</strong>。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p><p>中断处理程序运行于内核态。中断发生时CPU可能处于内核态（如执行系统调用的过程中）也可能处于用户态（执行应用空间代码）。所以前者不涉及特权级转换，后者涉及。</p><p>不涉及特权级转换的情况：</p><ul><li>压入寄存器现场、错误代码等</li><li>执行中断处理程序</li><li>恢复寄存器现场</li></ul><p>可以看到这里并没有发生堆栈的切换——因为本来就运行在内核栈上嘛！中断处理程序借用了应用程序的内核栈。说『借用』是因为进程的内核栈是给进程执行内核空间代码使用的（通常就是系统调用），由于中断并不一定和正在运行的进程有什么关联。</p><p>但是对于后者，也就是用户态中被中断，有一个用户 <code>-&gt;</code> 内核 <code>-&gt;</code> 用户的切换过程，伴随着相关栈的切换。具体过程：</p><ul><li>找到内核栈</li><li>压入寄存器现场、错误代码</li><li>转入中断处理程序</li><li>恢复第二步保存的现场</li><li>切换换回用户栈</li></ul><p>为了快速响应硬件的事件，中断处理会打断进程的正常调度和执行，转而调用中断处理程序，响应设备事件，如断电和设备损坏等。而在打断其他进程时，就需要将进程当前的状态保存下来，这样在中断结束后，进程仍然可以从原来的状态恢复运行。</p><p><strong>跟进程上下文不同，中断上下文切换并不涉及到进程的用户态</strong>。所以，即便中断过程打断了一个正处在用户态的进程，也不需要保存和恢复这个进程的虚拟内存、全局变量等用户态资源。<strong>中断上下文，其实只包括内核态中断服务程序执行所必需的状态，包括 CPU 寄存器、内核堆栈、硬件中断参数等</strong>。</p><p><strong>对同一个 CPU 来说，中断处理比进程拥有更高的优先级</strong>，所以中断上下文切换并不会与进程上下文切换同时发生。同样道理，由于中断会打断正常进程的调度和执行，所以大部分中断处理程序都短小精悍，以便尽可能快的执行结束。</p><p>另外，跟进程上下文切换一样，中断上下文切换也需要消耗 CPU，切换次数过多也会耗费大量的 CPU，甚至严重降低系统的整体性能。所以，当你发现中断次数过多时，就需要注意去排查它是否会给你的系统带来严重的性能问题。</p><h3 id="一些讨论">一些讨论</h3><ul><li>CPU 上下文切换，是保证现代系统正常工作的核心功能之一，一般情况下不需要我们特别关注。根据 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.tsunanet.net/2010/11/how-long-does-it-take-to-make-context.html">Tsuna</a> 的测试报告，每次上下文切换都需要几十纳秒到数微秒的 CPU 时间。这个时间还是相当可观的，特别是在进程上下文切换次数较多的情况下，会把 CPU 时间消耗在寄存器、内核栈以及虚拟内存等数据的保存和恢复上，从而缩短进程真正运行的时间，导致系统的整体性能大幅下降。</li><li>CPU 执行的最小逻辑单元是线程，并不是一个 CPU 核心。所以切换进程，只是切换一个进程里的一个线程到另一个进程里的一个线程，说白了还是线程切换。如果对比的是单个进程和进程内线程的切换，线程共享资源，cache命中率会高很多；进程切换，不共享资源，cache命中率低。</li><li>上下文切换说的是 CPU 寄存器的切换，跟 cache 和内存没啥关系，后者只是上下文切换带来的副作用。也许你会有疑问，当切换到新的进程，进程所需的资源不在内存里，这不就开始调度了，调度的开销呢？但实际是，新建进程不会分配 CPU，进程就绪后等等待分配处理器，此时资源已经进内存了。</li><li>切换进程可能要刷 TLB，进程内线程切换不需要。进程切换要切页表，所以可能同时要刷 TLB，这个根据实现定。</li></ul><h1>第六章：进程同步</h1><h2 id="问题引入">问题引入</h2><p>生产 - 消费模型，用<code>count</code>记录当前产品数量，生产一件则<code>count</code>加一，消费一件则减一，生产与消费同时进行，那么在改变<code>count</code>时就会出现如下问题。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="57.png" style="zoom:45%"><p>这就出现了由于CPU调度导致的数据问题。那么我们将讨论如何解决这个问题。也就是说，保证操作的原子性。换言之，保证生产与消费的进程同步（同步指两个或两个以上随时间变化的量在变化过程中保持一定的相对关系），即两个进程不会同时访问共享变量（也就是互斥）</p><h2 id="问题解决：临界区问题">问题解决：临界区问题</h2><p>临界区 (<code>Critical Sections</code>) 是访问共享数据的代码，生产者消费者代码中的<code>count++\count--</code>就是临界区。</p><p>考虑一个由n个进程<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">{</mo><msub><mi>P</mi><mn>0</mn></msub><mo separator="true">,</mo><msub><mi>P</mi><mn>1</mn></msub><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><msub><mi>P</mi><mrow><mi>n</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">}</mo></mrow><annotation encoding="application/x-tex">\{P _0 , P_1 ,..., P_{n−1} \}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mopen">{</span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.30110799999999993em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord">...</span><span class="mpunct">,</span><span class="mspace" style="margin-right:.16666666666666666em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.13889em">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.301108em"><span style="top:-2.5500000000000003em;margin-left:-.13889em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.208331em"><span></span></span></span></span></span></span><span class="mclose">}</span></span></span></span> 组成的系统。每个进程都有一段称为<strong>临界区（critical section）<strong>的代码，进程会在其中更改公共变量、更新表、编写文件等等。该系统的重要特性是，当一个进程在其临界区执行时，不允许其他进程在其临界区执行。也就是说，没有两个进程可以同时在它们的临界区执行。<strong>临界区问题（critical-section problem）<strong>是设计一个进程可以用来进行协作的协议。每个进程必须请求允许进入其临界区。实现此请求的代码段是</strong>入口区（entry section）</strong>。<strong>临界区（critical section）<strong>之后则是</strong>出口区（exit section）</strong>。其余的代码是</strong>剩余区（remainder section）</strong>。入口区和出口区被封闭在方框中，以突出这些重要的代码段。如图。</p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="58.png" style="zoom:50%"><p><strong>临界区问题的解决方案必须满足以下三个要求:</strong></p><ol><li><p><strong>互斥锁（Mutual exclusion）</strong>：如果进程P在它的临界区执行，那么没有其他进程可以在它们的临界区没中执行。</p></li><li><p><strong>空闲让进/前进（Progress）</strong>：如果一个进程正在它的临界区中执行，并且有很多其他的进程也希望进入他们的临界区。然后，只有那些没有在其<strong>剩余区</strong>中执行的进程才能参与决定哪一个将进入它的临界区，而这个选择不能被无限期延迟。</p><p>即，没有进程处于临界区时，可允许一个请求进入临界区的进程立即进入。</p></li><li><p><strong>有限等待（Bounded waiting）</strong>：在一个进程发出请求进入其临界区并在该请求被确认之前，其他进程被允许进入其临界区的<strong>次数</strong>有一个范围或限制。</p></li></ol><p>我们假设每个进程都以非零的速度执行。然而，我们不能对n个进程的相对速度做任何假设。</p><p>在一个给定的时间点上，可能会有许多内核模式的进程在操作系统中处于活动状态。因此，实现操作系统(内核代码)的代码会受到多个可能的<strong>竞态条件</strong>（race condition）的影响。以一个内核数据结构为例，它维护系统中所有打开的文件的列表。当打开或关闭新文件时，必须修改此列表(将文件添加到列表中或将其从列表中删除)。如果两个进程同时打开文件，则该列表的单独更新可能导致竞态条件。其他可能出现竞态条件的内核数据结构包括维护内存分配、维护进程列表和中断处理的结构。这取决于内核开发人员，以确保操作系统不受这种竞争条件的影响。</p><p>有两种通用方法用于处理操作系统中的临界区：<strong>抢占式内核（preemptive kernels）<strong>和</strong>非抢占式内核（nonpreemptive kernels）</strong>。<strong>抢占式内核</strong>允许进程在内核模式运行时被抢占。非抢占内核不允许在内核模式中运行的进程被抢占;内核模式下，进程将一直运行，直到它退出内核模式、阻塞或自愿让出CPU控制。</p><p>显然，<strong>一个非抢占式的内核基本上不受内核数据结构的竞争条件的影响，因为只有一个进程在内核中处于活动状态</strong>。但是对于抢占内核，则是不同的，所以必须仔细设计，以确保共享的内核数据不受竞态条件的影响。对于<strong>SMP</strong>（“对称多处理”（Symmetrical Multi-Processing））架构来说，抢占式内核尤其困难，因为在这些环境中，两个内核模式进程可以同时在不同的处理器上运行。</p><p>那么，为什么有人会赞成抢占式内核而不是非抢占式内核呢？抢占式内核会更有响应性，因为在将处理器交付给其他<code>waiting</code>状态的进程之前，内核模式下的进程运行任意周期长的的风险更小[注：这是原文翻译，意思就是在处理器叫控制权交给下一个进程之前，当前内核模式运行的进程一般不会占用很久]。(当然，通过设计不以这种方式运行的内核代码，这种风险也可以最小化。)此外，抢占式内核更适合于实时编程，因为它将允许实时进程抢占当前内核中正在运行的进程。</p><h2 id="Peterson算法"><code>Peterson</code>算法</h2><p>Peterson 算法完美地用软件实现了双线程互斥问题。</p><p>算法使用两个控制变量<code>flag</code>与<code>turn</code>。 <strong>其中<code>flag[n]</code>的值为真，表示ID号为<code>n</code>的进程希望进入该临界区.。变量<code>turn</code>保存有权访问共享资源的进程的ID号</strong>.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//flag[] is boolean array; and turn is an integer </span></span><br><span class="line">flag[i] = <span class="literal">false</span>; </span><br><span class="line">flag[j] = <span class="literal">false</span>; </span><br><span class="line"><span class="type">int</span> turn;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pi: flag[i] = <span class="literal">true</span>;</span><br><span class="line">    turn = j;</span><br><span class="line">    <span class="keyword">while</span> (flag[j] == <span class="literal">true</span> &amp;&amp; turn == j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// busy wait</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// critical section</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// end of critical section</span></span><br><span class="line">    flag[i] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pj: flag[j] = <span class="literal">true</span>;</span><br><span class="line">    turn = i;</span><br><span class="line">    <span class="keyword">while</span> (flag[i] == <span class="literal">true</span> &amp;&amp; turn == i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// busy wait</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// critical section</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// end of critical section</span></span><br><span class="line">    flag[j] = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>我们现在证明这个算法是正确的。我们需要证明:</p><ul><li><p>互斥锁（Mutual exclusion）</p></li><li><p>空闲让进/前进（Progress）</p></li><li><p>有限等待（Bounded waiting）</p></li></ul><hr><p><strong>证明1：</strong></p><p><code>Pi</code>进程只有在<code>flag[j] == false</code>或者<code>turn == i</code>时候才会进入临界区。</p><p>如果两个进程同时在其临界区内执行，那么<code>flag[0] = flag[1] = true</code> 。</p><p>但是<code>turn</code>的值只能是<code>i</code>或者<code>j</code>,所以<code>Pi</code>和<code>Pj</code>同一时间不能成功地执行它们的<code>while</code>语句。因此只能有一个进程（如<code>Pj</code>）能成功的执行完<code>while</code>语句，而另一个进程（<code>Pi</code>）则至少必须执行一个附加的语句(<code>turn = j</code>)。</p><p>而且，由于只要<code>Pj</code>在其临界区内，<code>flag[j] = true</code>和<code>turn = j</code>就会同时成立。</p><p>互斥成立</p><hr><p><strong>证明2：</strong></p><p>只要<code>flag[j] = true &amp;&amp; turn = j</code>成立，进程<code>Pi</code>陷入<code>while</code>循环语句。</p><p>如果<code>Pj</code>不准备进入临界区，那么<code>flag[j] = false</code>，<code>Pi</code>就可以进入临界区。</p><p>如果<code>Pj</code>已经设置<code>flag[j] = true</code>，且也在其<code>while</code>语句中执行，那么<code>turn = j</code> 或者<code>turn = i</code>。如果<code>turn = i</code>，那么Pi进入临界区；如果<code>turn = j</code>，那么<code>Pj</code>进入临界区。然而当<code>Pj</code>退出临界区，它会设置<code>flag[j] = false</code>，以允许<code>Pi</code>进入其临界区</p><p>如果<code>Pj</code>重新设置<code>flag[j] = true</code>，那么它也必须设置<code>turn</code>为<code>i</code>。</p><p>因此由于进程<code>Pi</code>执行<code>while</code>语句时并不改变<code>turn</code>的值，所以<code>Pi</code>会进入临界区（证明2成立），并且<code>Pi</code>最多在<code>Pj</code>进入临界区一次后就能进入（证明3成立）。</p><h2 id="硬件同步">硬件同步</h2><p>硬件支持进程同步的方法：</p><ul><li>单处理器：关中断</li><li>多处理器：利用原子指令（不会被打断）</li></ul><h3 id="利用原子指令进行进程同步">利用原子指令进行进程同步</h3><h4 id="TestAndSet"><code>TestAndSet</code></h4><p>返回<code>target</code>的值并将其设置为<code>true</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">boolean <span class="title function_">TestAndSet</span> <span class="params">(boolean *target)</span></span><br><span class="line">&#123;</span><br><span class="line">   boolean rv = *target;</span><br><span class="line">   *target = TRUE;</span><br><span class="line">   <span class="keyword">return</span> rv:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用一个初始化为<code>false</code>的布尔值<code>lock</code>，代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">   <span class="keyword">while</span> (<span class="built_in">TestAndSet</span> (&amp;lock))&#123;</span><br><span class="line">   &#125;  <span class="comment">// do nothing</span></span><br><span class="line">    </span><br><span class="line">      <span class="comment">//critical section</span></span><br><span class="line">      lock = FALSE;</span><br><span class="line">      <span class="comment">//remainder section </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一个进程由于<code>lock</code>为<code>false</code>，将<code>lock</code>置为<code>true</code>后直接进入临界区。第二个进程尝试进入临界区时会在<code>while</code>循环内等待，第一个进程执行完临界区后<code>lock</code>为<code>false</code>，第二个进程进入临界区，由此实现互斥锁。</p><h4 id="Swap"><code>Swap</code></h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span> <span class="params">(boolean *a, boolean *b)</span></span><br><span class="line">&#123;</span><br><span class="line">    boolean temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)  &#123;</span><br><span class="line">     key = TRUE;</span><br><span class="line">     <span class="keyword">while</span> ( key == TRUE)</span><br><span class="line">       Swap (&amp;lock, &amp;key);</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//critical section</span></span><br><span class="line">     lock = FALSE;</span><br><span class="line">     <span class="comment">//remainder section </span></span><br><span class="line">&#125;               </span><br></pre></td></tr></table></figure><p>同样地，<code>lock</code>初始化为<code>false</code>，第一个进程会将<code>lock</code>置为<code>true</code>，<code>key</code>置为<code>false</code>，然后跳出循环执行临界区代码。这里要注意，<strong><code>lock</code>是共享变量，<code>key</code>则是每个进程的变量</strong>，也就是说，只有一个<code>lock</code>，但每个进程都有一个<code>key</code>。第二个进程进入<code>while</code>循环后，两个变量都是<code>true</code>，会一直执行循环。第一个进程执行完临界区后，<code>lock</code>变为<code>false</code>，此时第二个进程完成变量互换后执行临界区。</p><h4 id="存在的问题">存在的问题</h4><p>我们需要在代码中嵌入硬件指令。解决方案：信号量（<code>semaphore</code>）</p><h2 id="信号量（-semaphore）">信号量（<code>semaphore</code>）</h2><p>信号量核心：一个用于控制的整型变量。</p><p>两个基础操作（PV操作）（原子操作）：<code>P</code>：<code>wait()</code>，<code>V</code>：<code>signal()</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">wait (S) &#123; </span><br><span class="line">        <span class="keyword">while</span> (S &lt;= <span class="number">0</span>)&#123; </span><br><span class="line">        &#125; <span class="comment">// no-op</span></span><br><span class="line">         S--;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">signal (S) &#123; S++; &#125;</span><br></pre></td></tr></table></figure><p>运作方式：</p><ul><li><p>初始化，给与它一个非负数的整数值。</p></li><li><p>执行P（<code>wait(S)</code>），信号标S的值将被减少。企图进入临界区段的进程，需要先执行P（<code>wait(S)</code>）。当信号标S减为负值时，进程会被挡住，不能继续；当信号标S不为负值时，进程可以获准进入临界区段。</p></li><li><p>执行V（<code>signal(S)</code>），信号标S的值会被增加。结束离开临界区段的进程，将会执行V（<code>signal(S)</code>）。当信号标S不为负值时，先前被挡住的其他进程，将可获准进入临界区段。</p></li><li><p>每执行一次P操作，意味着请求的进程分配到一个资源；每执行一次V操作，意味着进程释放了一个资源。</p></li></ul><p>特别的，如<strong>二元信号量</strong>（互斥锁）：信号量只能是0或1。</p><p>一般的，使用<strong>计数信号量</strong>：</p><ul><li><p>初始值一般是资源的数量。</p></li><li><p>当S&gt;0时，<strong>S值的大小表示某类可用资源的数量</strong>，即表示有该类资源可以分配。</p></li><li><p>当S&lt;0时，表示没有可分配的资源数量，其<strong>S的绝对值表示排在S信号量的等待队列中进程的数目</strong>（等待的进程数）。</p></li></ul><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="62.png" style="zoom:55%"><h3 id="使用PV操作注意事项：">使用PV操作注意事项：</h3><ul><li><p>每个程序中用户实现互斥的<strong>P、V操作必须成对出现</strong>，先做P操作，进临界区，后做V操作，出临界区。若有多个分支，要认真检查其成对性。</p></li><li><p>P、V操作应分别紧靠临界区的头尾部，临界区的代码应尽可能短，不能有死循环。</p></li></ul><h3 id="问题">问题</h3><h4 id="忙等">忙等</h4><p>如果一个进程占用资源时间较长而不释放锁，导致其他进程一直等待获取该资源并在执行时只能执行空循环（被分配到CPU时）造成处理器资源浪费。</p><p>解决方式：阻塞与唤醒。每个信号量对应一个阻塞队列，当发现某进程无法进入临界区，就将其放入阻塞队列而不分配CPU，等待允许进入临界区时由调度程序进行唤醒。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Implementation of wait:</span></span><br><span class="line">                      <span class="built_in">wait</span> (S)&#123; </span><br><span class="line">	                        value- -;</span><br><span class="line">	                        <span class="keyword">if</span> (value &lt; <span class="number">0</span>) &#123; </span><br><span class="line">			          <span class="function">add <span class="keyword">this</span> process to waiting queue</span></span><br><span class="line"><span class="function">			          <span class="title">block</span><span class="params">()</span></span>;  </span><br><span class="line">                                    &#125;</span><br><span class="line">                       &#125;</span><br><span class="line"><span class="comment">//Implementation of signal:</span></span><br><span class="line">                      <span class="built_in">signal</span> (S)&#123; </span><br><span class="line">	                           value++;</span><br><span class="line">	                            <span class="keyword">if</span> (value &lt;= <span class="number">0</span>) &#123; </span><br><span class="line">			              <span class="function">remove a process P from the waiting queue</span></span><br><span class="line"><span class="function">			              <span class="title">wakeup</span><span class="params">(P)</span></span>;  </span><br><span class="line">                                &#125;</span><br><span class="line">                      &#125;</span><br></pre></td></tr></table></figure><h4 id="共享变量问题">共享变量问题</h4><p>不同进程共享信号量S这个变量，则对S的操作又形成了临界区。</p><p>单处理器就可以通过关中断或者硬件指令。多处理机环境中情况有所不同，例如test_and­_set指令包括“取”、“送”两个机器周期，两个CPU执行<code>test_and_set(lock)</code>可能发生指令周期上的交叉，假如<code>lock</code>初始为0, CPU1和CPU2可能分别执行完前一个机器周期并通过检测(均为0)，然后分别执行后一个机器周期将<code>lock</code>设置为1，结果都取回0作为判断临界区空闲的依据，从而不能实现互斥。</p><p>为在多CPU环境中利用<code>test_and_set</code>指令实现进程互斥，硬件需要提供进一步的支持，以保证<code>test_and_set</code>指令执行的原子性. 这种支持目前多以“锁总线”(<code>bus locking</code>)的形式提供的，由于<code>test_and_set</code>指令对内存的两次操作都需要经过总线，在执行<code>test_and_set</code>指令之前锁住总线，在执行<code>test_and_set</code>指令后开放总线，即可保证<code>test­_and_set</code>指令执行的原子性，用法如下：</p><p>算法4-6：多处理机互斥算法（自旋锁算法）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">  b=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(b)&#123; </span><br><span class="line">      lock(bus);</span><br><span class="line">      b = test_and_set(&amp;lock);</span><br><span class="line">      unlock(bus);</span><br><span class="line">  &#125; </span><br><span class="line"><span class="comment">//临界区 </span></span><br><span class="line">  lock = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//其余部分</span></span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h4 id="死锁（Deadlock）与饿死（Starvation）">死锁（<code>Deadlock</code>）与饿死（<code>Starvation</code>）</h4><p>信号量很容易出现死锁</p><h2 id="经典问题">经典问题</h2><h3 id="生产者消费者问题">生产者消费者问题</h3><blockquote><p>假定生产者和消费者之间的公用缓冲池有n个缓冲区，生产者可以向缓冲区生产一个产品，消费者可以从缓冲区消耗一个产品，注意：生产者不能同时生产，消费者也不能同时消费，也不能同时生产和消费，当缓冲区空时无法消费，当缓冲区满时无法生产。</p></blockquote><p>互斥锁 <code>mutex</code>，计数信号量<code>full</code>、<code>empty</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">//实现生产与消费、生产与生产、消费与消费,</span></span><br><span class="line">semaphore full = <span class="number">0</span>, empty = n;  <span class="comment">//full表示已用缓冲区数，empty表示空缓冲区数</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">producer</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		wait(empty);  <span class="comment">//每次生产会减少一个空缓冲区，如果没有空缓存区了就阻塞</span></span><br><span class="line">	    wait(mutex);  <span class="comment">//保证互斥</span></span><br><span class="line">	    <span class="comment">//生产一个产品;</span></span><br><span class="line">	    signal(mutex);  <span class="comment">//保证互斥</span></span><br><span class="line">	    signal(full);  <span class="comment">//每次生产增加一个已用缓冲区</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">consumer</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		wait(full);  <span class="comment">//每次消费会减少一个已用缓冲区，如果没有已用缓存区了就阻塞</span></span><br><span class="line">	    wait(mutex);</span><br><span class="line">	    <span class="comment">//消耗一个产品;</span></span><br><span class="line">	    signal(mutex);</span><br><span class="line">	    signal(empty);  <span class="comment">//每次生产增加一个空缓冲区</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读者写者问题">读者写者问题</h3><blockquote><p>假设一个文件可被多个进程共享，我们允许多个进程同时读这个共享对象，但是不允许一个进程写这个共享对象的同时，别的进程进行读或写。换句话说：读和读不互斥，读和写互斥，写和写互斥。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore rmutex, wmutex = <span class="number">1</span>; <span class="comment">//wmutex用以实现写进程与其它进程的互斥</span></span><br><span class="line"><span class="type">int</span> readcount = <span class="number">0</span>;  <span class="comment">//记录读进程的数量</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">reader</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		wait(rmutex);  <span class="comment">//见下文解释</span></span><br><span class="line">		<span class="keyword">if</span>(readcount == <span class="number">0</span>) wait(wmutex);  <span class="comment">//第一个读进程去把写进程上锁</span></span><br><span class="line">		readcount++;  </span><br><span class="line">		signal(rmutex);  <span class="comment">//见下文解释</span></span><br><span class="line">		<span class="comment">//读者读;</span></span><br><span class="line">		wait(rmutex);  <span class="comment">//见下文解释</span></span><br><span class="line">		readcount--;</span><br><span class="line">		<span class="keyword">if</span>(readcount == <span class="number">0</span>) signal(wmutex);  <span class="comment">//解锁</span></span><br><span class="line">		signal(rmutex);  <span class="comment">//见下文解释</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">writer</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		wait(wmutex);  <span class="comment">//实现写进程与其他进程都互斥</span></span><br><span class="line">		<span class="comment">//写者写;</span></span><br><span class="line">		signal(wmutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题的程序中有个关键点，就是明明读进程是不互斥的，为什么还需要<code>rmutex</code>来实现<code>if</code>判断的互斥呢。原因如下：当我们在进程互斥中使用条件语句和数值变化的时候，如果不把那一段也实现互斥的话，很有可能出问题，比如在这段代码中，要是不加第5行和第8行的话：如果一个读进程执行完了第6行，还没有执行第7行的<code>readcount++</code>操作之前，这个读进程被剥夺了处理机，换另一个读进程上处理机运行了，那么另一个读进程就会阻塞在第6行的<code>wait</code>操作上，就无法实现多个读者一起读了(因为此时<code>wmutex</code>这个互斥锁已经加锁了，不能再进行<code>wait</code>）；10行和13行同理，如果一个读进程执行完了第11行就被剥夺处理机，换上另一个读进程也执行了11行，这样<code>readcount</code>被连减两次，那么这两个进程都能通过12行的<code>if</code>判断，会执行两次<code>signal</code>操作，产生错误。</p><h3 id="哲学家进餐问题">哲学家进餐问题</h3><blockquote><p>五个哲学家共用一张圆桌，分别坐在周围的五张椅子上，在桌子上有五只碗和五只筷子，他们的生活方式是交替地进行思考和进餐。平时，一个哲学家进行思考，饥饿时便试图取用其左右最靠近他的筷子，只有在他拿到两只筷子时才能进餐。进餐毕，放下筷子继续思考。</p></blockquote><p>这是一个讲解死锁的时候的经典例子，解决这道题的直接思路如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="comment">/*当哲学家饥饿时，总是先拿左边的筷子，再拿右边的筷子*/</span></span><br><span class="line">	wait(chopstick[i]);</span><br><span class="line">	wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">	<span class="comment">//吃饭;</span></span><br><span class="line">	signal(chopstick[i]);</span><br><span class="line">	signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这样可能会出现死锁问题：如果所有哲学家都拿起了左手边筷子，五个进程就会死锁。对于避免哲学家进餐问题发生死锁的方法有很多，这里讲一种：只有当同时一个哲学家能同时拿起左右两只筷子时，才允许拿筷子，解法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>&#125;;</span><br><span class="line">semaphore mutex = <span class="number">1</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">philosopher</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		wait(mutex);</span><br><span class="line">        wait(chopstick[i]);</span><br><span class="line">		wait(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">		signal(mutex);</span><br><span class="line">		<span class="comment">//吃饭;</span></span><br><span class="line">		signal(chopstick[i]);</span><br><span class="line">		signal(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但仅仅这样做还是有问题，如果一个哲学家获得了两只筷子，开始进餐，此时他左边或者右边的哲学家进入了临界区后，被阻塞在第6行或者第7行，那么其他的哲学家就无法进入临界区了，<strong>也就是说这个时间只能有一个哲学家进餐</strong>，但显然同一时间是可以有不相邻的两个哲学家同时进餐的。</p><p>另一种解法：对编号偶数哲学家来说先取左边的筷子，而对于编号奇数哲学家来说先取右边的筷子，这样也会避免死锁。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;	<span class="comment">// 筷子的互斥信号量</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 哲学家i进程</span></span><br><span class="line">P_Philosopher_i()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;        </span><br><span class="line">        <span class="keyword">if</span>(i%<span class="number">2</span> == <span class="number">0</span>)&#123;    <span class="comment">// 编号为偶数哲学家</span></span><br><span class="line">	    P(chopstick[i]);          <span class="comment">// 取左边筷子的互斥性</span></span><br><span class="line">	    P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);    <span class="comment">// 取右边筷子的互斥性</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;        <span class="comment">// 编号为奇数哲学家</span></span><br><span class="line">            P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);    <span class="comment">// 取右边边筷子的互斥性</span></span><br><span class="line">	    P(chopstick[i]);          <span class="comment">// 取左边筷子的互斥性</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//吃饭;</span></span><br><span class="line"> </span><br><span class="line">	V(chopstick[i]);</span><br><span class="line">	V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//思考;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外：对哲学家同时进餐的进程加以限制，可以让最大4个哲学家进程同时拿去筷子。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">semaphore chopstick[<span class="number">5</span>] = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;;	<span class="comment">// 筷子的互斥信号量</span></span><br><span class="line">semaphore mutex = <span class="number">4</span>;    <span class="comment">// 哲学家同时进餐互斥量</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 哲学家i进程</span></span><br><span class="line">P_Philosopher_i()&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        P(mutex);    <span class="comment">// 保证最多4个哲学家同时取筷子</span></span><br><span class="line">	P(chopstick[i]);          <span class="comment">// 取左边筷子的互斥性</span></span><br><span class="line">	P(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);    <span class="comment">// 取右边筷子的互斥性</span></span><br><span class="line">        V(mutex);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">//吃饭;</span></span><br><span class="line"> </span><br><span class="line">	V(chopstick[i]);</span><br><span class="line">	V(chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>]);</span><br><span class="line">	</span><br><span class="line">        <span class="comment">//思考;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="其他问题">其他问题</h2><h3 id="狒狒过桥问题">狒狒过桥问题</h3><p>一个主修人类学、辅修计算机科学的学生参加了一个课题，调查非洲狒狒是否能被教会理解死锁。他找到一处很深的峡谷，在上边固定了一根横跨峡谷的绳索，这样狒狒就可以攀住绳索越过峡谷。同一时刻可以有几只狒狒通过，只要它们朝着相同的方向。但如果向东和向西的狒狒同时攀在绳索上则将发生死锁（狒狒将被卡在中间），因为它们无法在吊在峡谷上时从另一只的背上翻过去。如果一只狒狒想越过峡谷，它必须看当前是否有别的狒狒正在逆向通过。使用信号量写一个避免死锁的程序来解决该问题。<br>解法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">semaphore wmutex, emutex, mutex = <span class="number">1</span>; </span><br><span class="line"><span class="type">int</span> wcount, ecount = <span class="number">0</span>;  <span class="comment">//分别记录东西狒狒上绳索的个数</span></span><br><span class="line"><span class="type">void</span> west_monkey &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		wait(wmutex);  <span class="comment">//使if语句互斥</span></span><br><span class="line">		<span class="keyword">if</span>(wcount == <span class="number">0</span>) wait(mutex);  <span class="comment">//第一个西狒狒给东狒狒上锁</span></span><br><span class="line">		wcount++;</span><br><span class="line">		signal(wmutex);  <span class="comment">//使if语句互斥</span></span><br><span class="line">		<span class="comment">//西狒狒过桥；</span></span><br><span class="line">		wait(wmutex);</span><br><span class="line">		wcount--;</span><br><span class="line">		<span class="keyword">if</span>(wcount == <span class="number">0</span>) signal(mutex);</span><br><span class="line">		signal(wmutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> east_monkey &#123;  <span class="comment">//和上面的一样</span></span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		wait(emutex);</span><br><span class="line">		<span class="keyword">if</span>(ecount == <span class="number">0</span>) wait(mutex);</span><br><span class="line">		ecount++;</span><br><span class="line">		signal(emutex);</span><br><span class="line">		<span class="comment">//东狒狒过桥；</span></span><br><span class="line">		wait(emutex);</span><br><span class="line">		ecount--;</span><br><span class="line">		<span class="keyword">if</span>(ecount == <span class="number">0</span>) signal(mutex);</span><br><span class="line">		signal(emutex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该问题属于读者写者问题的改进，如果完全理解了读者写者问题的解法，那么这个问题也能很快解决。东狒狒之间不互斥，西狒狒之间不互斥，东西狒狒之间互斥，思路是第一个东狒狒给西狒狒上锁，第一个西狒狒给东狒狒上锁，注意<code>if</code>判断也要实现互斥。</p><h3 id="理发师理发问题">理发师理发问题</h3><p>理发店里有一位理发师、一把理发椅和<code>n</code>把供等候理发的顾客坐的椅子。如果没有顾客，则理发师便在理发椅上睡觉。当一个顾客到来时，他必须先叫醒理发师，如果理发师正在理发时又有顾客来到，则如果有空椅子可坐，他们就坐下来等。如果没有空椅子，他就离开。这里的问题是为理发师和顾客各编写一段程序来描述他们的行为，要求不能带有竞争条件。<br>解法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">semaphore customer, barber = <span class="number">0</span>;  <span class="comment">//一开始没有顾客，理发师也是睡着的</span></span><br><span class="line">semaphore mutex = <span class="number">1</span>;  <span class="comment">//互斥信号量</span></span><br><span class="line"><span class="type">int</span> empty = N;  <span class="comment">//空椅子数量为N</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Barber</span><span class="params">()</span> &#123;</span><br><span class="line">	<span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">		wait(customer);  <span class="comment">//只有顾客进程的V执行后才能执行，没有顾客就阻塞（睡觉）</span></span><br><span class="line">		wait(mutex);  <span class="comment">//把数量的变化实现互斥，以免影响到顾客进程的if判断语句</span></span><br><span class="line">		empty++;  <span class="comment">//椅子上的顾客起身</span></span><br><span class="line">		signal(barber);  <span class="comment">//有了一个理发师可以理发</span></span><br><span class="line">		signal(mutex);</span><br><span class="line">		<span class="comment">//理发;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">Customer</span><span class="params">()</span> &#123;</span><br><span class="line">	wait(mutex);</span><br><span class="line">	<span class="keyword">if</span>(empty &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		empty--;  <span class="comment">//不管是不是第一个顾客，来了先得坐凳子上，因为理发师在理发椅上睡觉呢</span></span><br><span class="line">		signal(customer);  <span class="comment">//增加一个顾客，唤醒沉睡的理发师</span></span><br><span class="line">		signal(mutex); </span><br><span class="line">		wait(barber);  <span class="comment">//消耗一个理发师，没有理发师就阻塞</span></span><br><span class="line">		<span class="comment">//理发;</span></span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		signal(mutex);</span><br><span class="line">		<span class="comment">//离开;</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这道题本身不难，但其中很多细节的实现需要实现，比如座位是有上限的，这样就不得不设置判断条件和计数，来使超过N个的顾客离开，而加入计数和判断条件后就又要实现其互斥，增加了问题的复杂性。</p><p>其他一些题https://zhuanlan.zhihu.com/p/61326272</p><h2 id="管程-monitor">管程(<code>monitor</code>)</h2><p><strong>所谓管程，指的是管理共享变量以及对共享变量的操作过程，让他们支持并发</strong>。翻译为 Java 的语言，就是管理类的成员变量和成员方法，让这个类是线程安全的。</p><p>可以有多个进程处于管程之中，但同一时间只能有一个处于活跃（<code>active</code>）状态。（这其实实现了最基本的互斥）</p><p>（管程如何实现有限等待？）</p><h3 id="条件变量-Condition-Variable">条件变量(Condition Variable)</h3><p><strong>注意条件变量的<code>wait()</code>和<code>signal()</code>与信号量之间进行区分，二者并不相同！</strong></p><ul><li>管程内部可定义 <code>condition</code> 类型的变量以提供同步机制，称其为条件变量。条件变量可执行操作 <code>wait()</code> 和 <code>signal()</code>。</li><li><strong>条件变量相当于一个阻塞队列，一般来说条件变量对应一个进程运行时所必须的条件</strong>。</li><li>条件变量存在于管程内部，对同一个条件变量调用操作的进程将和条件变量建立一定的联系，或者称之为绑定。<ul><li>对于管程内的条件变量 x，进程 P 调用 <code>x.wait()</code> 将时自身挂起到条件变量 x 上；</li><li>当另一个进程调用 <code>x.signal()</code>时，在 x 上悬挂的进程会被重启，如果此时没有进程悬挂在 x 上，则 <code>x.signal()</code> 操作将被忽略。</li></ul></li><li>管程模式下的 <code>x.signal()</code> 和信号量的 <code>signal()</code> 区别在于：<strong>信号量操作 <code>signal()</code> 会影响信号量的状态</strong>，而<strong>管程下的 <code>x.signal()</code> 在 x 不存在挂起进程的情况下没有任何影响</strong>。</li><li>举例：进程 P 调用<code>x.signal()</code>，且存在悬挂进程 Q 与条件变量 x 关联。根据管程的性质，若进程 Q 开始执行，则进程 P 必须等待。此时可能存在两种可能性，且两种可能性均有合理解释：<ul><li><strong>进程 Q 重启且进程 P 等待(<code>Hoare semantics</code>)</strong>：进程 P 将等待，直到进程 Q 离开管程或者等待另一个进程调用 <code>x.signal()</code></li><li><strong>进程 P 唤醒进程 Q 且进程 P 继续执行(<code>Mesa semantics</code>)</strong>：进程 Q 被唤醒，但仍然会等待，直到进程 P 离开管程，或者另一个触发条件。因为 P 已经在管程中执行，看起来此种方案更合理，但这破坏了进程 Q 正在等待的逻辑条件，进程 Q 已被触发但又未执行，因此状态难以描述</li><li>Pascal 语言采用折中方式，当进程 P 执行 <code>x.signal()</code> 时，它会立刻离开管程，且进程 Q 会立刻重新执行</li></ul></li></ul><h3 id="管程模型">管程模型</h3><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="60.png" style="zoom:45%"><p>注意这个管程与外部的入管进程队列之间有一个互斥锁。<strong>在管程的简单实现中，<a target="_blank" rel="noopener external nofollow noreferrer" href="https://zh.wikipedia.org/wiki/%E7%B7%A8%E8%AD%AF%E5%99%A8">编译器</a>为每个管程对象自动加入一把私有的互斥锁。该互斥锁初始状态为解锁，在管程的每个公共子程序的入口给该互斥锁加锁，在管程的每个公共子程序的出口给该互斥锁解锁（或者将自身挂起时）</strong>。</p><h3 id="哲学家进餐问题的管程解法">哲学家进餐问题的管程解法</h3><ul><li>使用 <strong>进程同步</strong> 中的一种策略：当哲学家在两只筷子均可用的情况下才拿起筷子，且拿起两只筷子的动作是非抢占的。</li><li>为哲学家设置三种状态：<code>enum &#123;THINKING, HUNGRY, EATING&#125; state[5]</code></li><li>哲学家 <code>i</code> 只有在两个邻居都不进餐时才能将变量 <code>state[i]</code> 设置为 <code>EATING</code>，当他处在饥饿状态又无法进餐时可以使自己忍耐一段时间：<code>(state[(i-1)%5] != EATING) &amp;&amp; (state[i] == HUNGRY) &amp;&amp; (state[(i+1)%5] != EATING)</code></li></ul><p>下面给出用管程解决的哲学家进餐问题，只解决了互斥问题，不会导致死锁，但可能导致某个哲学家过度饥饿而死。(没有解决有限边界，且同时只能有一个哲学家在进餐)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">monitor dp&#123;</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> &#123;</span>THINKING, HUNGRY, EATING&#125; state[<span class="number">5</span>];</span><br><span class="line">    condition self[<span class="number">5</span>];<span class="comment">//每个哲学家对应一个条件变量</span></span><br><span class="line">    <span class="type">void</span> <span class="title function_">pickup</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        state[i] = HUNGRY;</span><br><span class="line">        test(i);</span><br><span class="line">        <span class="keyword">if</span> (state[i] != EATING)<span class="comment">//test函数不成功，将自己阻塞</span></span><br><span class="line">            self[i].wait();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">putdown</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        state[i] = THINKING;</span><br><span class="line">        <span class="comment">//唤醒被阻塞的哲学家</span></span><br><span class="line">        test((i<span class="number">-1</span>) % <span class="number">5</span>);</span><br><span class="line">        test((i+<span class="number">1</span>) % <span class="number">5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((state[(i<span class="number">-1</span>)%<span class="number">5</span>] != EATING) &amp;&amp; </span><br><span class="line">            (state[i] == HUNGRY) &amp;&amp;</span><br><span class="line">            (state[(i+<span class="number">1</span>)%<span class="number">5</span>] != EATING))&#123;</span><br><span class="line">            state[i] = EATING;</span><br><span class="line">            self[i].signal();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    initialization_code()&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">            state[i] = THINKING;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个改进版的 <code>Monitor</code> 解决方案如下。筷子本身并不属于 <code>monitor</code> 的一部分，否则同时只能有一个哲学家在进餐。代码中 <code>NUM_PHILS</code> 是哲学家数目。此代码解决了哲学家饥饿问题，来自<a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.csee.wvu.edu/~jdm/classes/cs550/notes/tech/mutex/dp-mon.html">西弗吉尼亚大学</a>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">monitor dp&#123;</span><br><span class="line">    condition self[NUM_PHILS];</span><br><span class="line">    <span class="class"><span class="keyword">enum</span> <span class="title">states</span> &#123;</span>THINKING, HUNGRY, EATING&#125; state[NUM_PHILS<span class="number">-1</span>];</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    initialization_code()&#123;</span><br><span class="line">        <span class="keyword">for</span> (index=<span class="number">0</span>; index&lt;NUM_PHILS; index++)</span><br><span class="line">            flags[index] = THINKING;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">pickup</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        state[i] = HUNGRY;</span><br><span class="line">        <span class="keyword">if</span> ((state[(i<span class="number">-1</span>)%NUM_PHILS] != EATING) &amp;&amp;</span><br><span class="line">            (state[(i+<span class="number">1</span>)%NUM_PHILS] != EATING))</span><br><span class="line">            state[i] = EATING;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 挂起，等待相邻哲学家改变状态时唤醒</span></span><br><span class="line">            self[i].wait;</span><br><span class="line">            <span class="comment">// wait 操作被唤醒后可以改变状态为 EATING</span></span><br><span class="line">            state[i] = EATING;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">void</span> <span class="title function_">putdown</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">        state[i] = THINKING;</span><br><span class="line">        <span class="comment">// 唤醒左侧哲学家</span></span><br><span class="line">        <span class="keyword">if</span> ((state [(i<span class="number">-1</span>)%NUM_PHILS] == HUNGRY) &amp;&amp;</span><br><span class="line">            (state [(i<span class="number">-2</span>)%NUM_PHILS] != EATING))</span><br><span class="line">            self[(i<span class="number">-1</span>)%NUM_PHILS].signal;</span><br><span class="line">        <span class="comment">// 唤醒右侧哲学家</span></span><br><span class="line">        <span class="keyword">if</span> ((state [(i+<span class="number">1</span>)%NUM_PHILS] == HUNGRY) &amp;&amp;</span><br><span class="line">            (state [(i+<span class="number">2</span>)%NUM_PHILS] != EATING))</span><br><span class="line">            self[(i+<span class="number">1</span>)%NUM_PHILS].signal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用信号量实现管程">使用信号量实现管程</h3><ul><li>要实现的管程对于重启进程采用的策略是： <strong>调用 <code>x.signal()</code> 的进程挂起自己，直到重新启动的进程离开或者等待</strong> 。</li><li><strong>每个管程都有一个信号量 <code>mutex</code> 初始化为 1（互斥锁），进程进入管程之前必须通过 <code>wait()</code> 获得允许，离开时需要调用 <code>signal()</code> 释放权限</strong>。</li><li><strong>信号量 <code>next</code> 初始化为 0，供线程在唤醒重启进程时挂起自己，整数变量 <code>next_count</code> 用于对挂起在 <code>next</code> 上的进程数量计数</strong>。</li></ul><p>进入管程的外部子程序结构 F 如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">F</span><span class="params">()</span>&#123;</span><br><span class="line">    wait(mutex);</span><br><span class="line">    <span class="comment">// 子程序执行</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// 子程序执行结束</span></span><br><span class="line">    <span class="keyword">if</span> (next_count &gt; <span class="number">0</span>)</span><br><span class="line">        signal(next);    <span class="comment">//     此前有进程挂起，重启该进程</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        signal(mutex);   <span class="comment">//     管程内无进程挂起，释放互斥锁控制权</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对每个管程内的条件变量 <code>x</code>，引入信号量 <code>x_sem</code> 和整数变量 <code>x_count</code> 记录信号量 x 上挂起的进程数量，均初始化为 0。<code>x.wait()</code> 和 <code>x.signal()</code> 实现如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> x.wait()&#123;</span><br><span class="line">    x_count++;            <span class="comment">// 将进程挂起到 x 上，让计数加一</span></span><br><span class="line">    <span class="keyword">if</span> (next_count &gt; <span class="number">0</span>)   <span class="comment">// 当前仍有进程挂起在管程中</span></span><br><span class="line">        signal(next);     <span class="comment">//说明这个进程此前让出了控制权，现在优先将其唤醒</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        signal(mutex);    <span class="comment">// 无进程在等待，释放管程控制权</span></span><br><span class="line">    wait(x_sem);          <span class="comment">// 等待信号量 x_sem，由信号量决定唤醒哪个挂起进程</span></span><br><span class="line">    <span class="comment">//等待被唤醒</span></span><br><span class="line">    x_count--;            <span class="comment">// 等待结束，进程被唤醒</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> x.signal()&#123;</span><br><span class="line">    <span class="keyword">if</span> (x_count &gt; <span class="number">0</span>)&#123;     <span class="comment">// 当前有程序挂起在条件变量 x</span></span><br><span class="line">        next_count ++;    <span class="comment">// 自己将要被阻塞，故管程挂起数增加</span></span><br><span class="line">        signal(x_sem);    <span class="comment">// 释放信号量，唤醒一个挂起进程</span></span><br><span class="line">        wait(next);       <span class="comment">// 将自身阻塞到管程中（将next的资源数减一）</span></span><br><span class="line">        <span class="comment">//等待被唤醒</span></span><br><span class="line">        next_count--;     <span class="comment">// 被唤醒，继续执行</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 没有程序挂起在条件变量 x，不产生任何影响</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里对挂起和阻塞的区分不是很严谨，实际上挂起跟阻塞是不一样的。</p><h2 id="管程VS信号量">管程<code>VS</code>信号量</h2><p>管程和信号量都能解决并发问题，它们是等价的。所谓等价指的是用管程能够实现信号量，也能用信号量实现管程。但是管程在信号量的基础上提供条件同步，使用更容易，所以 <code>Java</code> 采用的是管程技术。<code>synchronized</code> 关键字及 <code>wait()</code>、<code>notify()</code>、<code>notifyAll()</code> 这三个方法都是管程的组成部分。</p><ul><li><strong>信号量(<code>Semaphere</code>)</strong>：操作系统提供的一种协调共享资源访问的方法。和用软件实现的同步比较，软件同步是平等线程间的的一种同步协商机制，不能保证原子性。而信号量则由操作系统进行管理，地位高于进程，操作系统保证信号量的原子性。</li><li><strong>管程(<code>Monitor</code>)</strong>：解决信号量在临界区的 <code>PV</code> 操作上的配对的麻烦，把配对的 <code>PV</code> 操作集中在一起，生成的一种并发编程方法。其中使用了条件变量这种同步机制。</li></ul><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="61.png" style="zoom:65%"><p><strong>说明：</strong> 信号量将共享变量 <code>S</code> 封装起来，对共享变量 <code>S</code> 的所有操作都只能通过 <code>PV</code> 进行，这是不是和面向对象的思想是不是很像呢？事实上，封装共享变量是并发编程的常用手段。</p><p>在信号量中，当 <code>P</code> 操作无法获取到锁时，将当前线程添加到<strong>同步队列</strong>(<code>syncQueue</code>)中。当其余线程 <code>V</code> 释放锁时，从同步队列中唤醒等待线程。但当有多个线程通过信号量 <code>PV</code> 配对时会异常复杂，所以管程中引入了<strong>等待队列</strong>(<code>waitQueue</code>)的概念，进一步封装这些复杂的操作。</p><h3 id="PS">PS.</h3><p>java管程模型中，阻塞队列有两个操作分别是入队和出队，这两个方法都是先获取互斥锁，类比管程模型中的入口。</p><ol><li>对于入队操作，如果队列已满，就需要等待直到队列不满，即 <code>notFull.await()</code>。</li><li>对于出队操作，如果队列为空，就需要等待直到队列不空，即 <code>notEmpty.await()</code>。</li><li>如果入队成功，那么队列就不空了，就需要通知条件变量：队列不空 <code>notEmpty</code> 对应的等待队列。</li><li>如果出队成功，那就队列就不满了，就需要通知条件变量：队列不满 <code>notFull</code> 对应的等待队列。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BlockedQueue</span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">    <span class="comment">// 条件变量：队列不满</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notFull</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line">    <span class="comment">// 条件变量：队列不空</span></span><br><span class="line">    <span class="keyword">final</span> <span class="type">Condition</span> <span class="variable">notEmpty</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">enq</span><span class="params">(T x)</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (队列已满) &#123;</span><br><span class="line">                <span class="comment">// 等待队列不满</span></span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// add x to queue</span></span><br><span class="line">            <span class="comment">// 入队后,通知可出队</span></span><br><span class="line">            notEmpty.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">deq</span><span class="params">()</span> &#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (队列已空) &#123;</span><br><span class="line">                <span class="comment">// 等待队列不空</span></span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// remove the first element from queue</span></span><br><span class="line">            <span class="comment">// 出队后，通知可入队</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>第六章习题拾遗</h1><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="63.png" style="zoom:55%"><ul><li>首先，局部变量不涉及互斥问题。所以两个进程的<code>a</code>和<code>b</code>不需要互斥。</li><li>其次，两进程的<code>x</code>并不是共享变量，所以两进程各自的<code>x</code>不需要互斥。</li></ul><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="64.png" style="zoom:55%"><ul><li>首先，<code>A</code>肯定错误，显然，并没有进行唤醒。</li><li><code>B</code>是正确的</li><li><code>C</code>错误，因为<code>lock</code>置为<code>false</code>后可能又会被同一进程的<code>while</code>捕获，导致没有实现有限等待</li></ul><h2 id="设计的一般流程">设计的一般流程</h2><ul><li><p>写伪代码</p></li><li><p>找出那些地方可能需要等待</p></li><li><p>看是否要加互斥锁</p></li></ul><h1>论述类习题</h1><p>There are two different ways that commands can be processed by a command interpreter. One way is to allow the command interpreter to contain the code needed to execute the command. The other way is to implement the commands through system programs. Compare and contrast the two approaches.</p><p>Ans: In the first approach, upon the user issuing a command, the interpreter jumps to the appropriate section of code, executes the command, and returns control back to the user. In the second approach, the interpreter loads the appropriate program into memory along with the appropriate arguments. The advantage of the first method is speed and overall simplicity. The disadvantage to this technique is that new commands require rewriting the interpreter program which, after a number of modifications, may get complicated, messy, or too large. The advantage to the second method is that new commands can be added without altering the command interpreter. The disadvantage is reduced speed and the clumsiness of passing parameters from the interpreter to the system program.</p><p>Explain why a modular kernel may be the best of the current operating system design techniques.</p><p>Ans: The modular approach combines the benefits of both the layered and microkernel design techniques. In a modular design, the kernel needs only to have the capability to perform the required functions and know how to communicate between modules. However, if more functionality is required in the kernel, then the user can dynamically load modules into the kernel. The kernel can have sections with well-defined, protected interfaces, a desirable property found in layered systems. More flexibility can be achieved by allowing the modules to communicate with one another.</p><h1>参考</h1><blockquote><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/question/290504400">https://www.zhihu.com/question/290504400</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://blog.forec.cn/2016/11/24/os-concepts-6/">http://blog.forec.cn</a>作者<a target="_blank" rel="noopener external nofollow noreferrer" href="http://forec.cn/">Forec</a></p><p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/binarylei/p/12544002.html">https://www.cnblogs.com/binarylei/p/12544002.html</a></p></blockquote></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="https://zwn2001.space">洛雪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://zwn2001.space/posts/os-note1-6/">https://zwn2001.space/posts/os-note1-6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zwn2001.space" target="_blank">ZWN's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a></div><div class="post_share"><div class="social-share" data-image="/img/cover3/13-min.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/isdu%E6%9A%91%E6%9C%9F%E7%BB%B4%E6%8A%A4%E6%97%A5%E5%BF%97/" title="isdu暑期维护日志"><img class="cover" src="/img/cover1/2.jpg" onerror='onerror=null,src="/img/404.webp"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">isdu暑期维护日志</div></div></a></div><div class="next-post pull-right"><a href="/posts/os-note7-13/" title="操作系统os-chapter7-13"><img class="cover" src="/img/cover2/18-min.jpg" onerror='onerror=null,src="/img/404.webp"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统os-chapter7-13</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/OS%E8%AF%BE%E8%AE%BE/" title="OS课设"><img class="cover" src="/img/cover2/6-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-09</div><div class="title">OS课设</div></div></a></div><div><a href="/posts/os-%E5%AE%9E%E9%AA%8C%E4%B8%83/" title="os-实验七"><img class="cover" src="/img/cover3/7-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-14</div><div class="title">os-实验七</div></div></a></div><div><a href="/posts/os-%E5%AE%9E%E9%AA%8C%E4%B8%89/" title="操作系统实验三-进程调度"><img class="cover" src="/img/cover3/4-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-12</div><div class="title">操作系统实验三-进程调度</div></div></a></div><div><a href="/posts/os-%E5%AE%9E%E9%AA%8C%E4%BA%8C/" title="操作系统实验二-管道通信"><img class="cover" src="/img/cover1/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-03-30</div><div class="title">操作系统实验二-管道通信</div></div></a></div><div><a href="/posts/os-%E5%AE%9E%E9%AA%8C%E4%BA%94/" title="操作系统实验五-进程互斥"><img class="cover" src="/img/cover3/7-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-30</div><div class="title">操作系统实验五-进程互斥</div></div></a></div><div><a href="/posts/os-%E5%AE%9E%E9%AA%8C%E5%9B%9B/" title="操作系统实验四-进程同步"><img class="cover" src="/img/cover3/13-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-04-19</div><div class="title">操作系统实验四-进程同步</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">洛雪</div><div class="author-info__description">我虽无意逐鹿，却知苍生苦楚</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">139</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">43</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ZWN2001"><i class="fab fa-github"></i><span>我的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZWN2001" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">新域名：www.zwn2001.space，有效期：10年。https://www.zwn-blog.xyz已过期。访问时建议科学上网，否则博客内公式渲染会出现问题且速度慢。Ctrl+shift+r可强制刷新网站以避免浏览器缓存造成的更新不及时</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">第一章</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.1.</span> <span class="toc-text">什么是操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%BB%84%E6%88%90"><span class="toc-number">1.1.1.</span> <span class="toc-text">计算机系统组成</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E7%BB%87"><span class="toc-number">1.2.</span> <span class="toc-text">计算机系统的组织</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">计算机系统操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">计算机启动过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8E%E9%99%B7%E9%98%B1"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">中断与陷阱</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.3.</span> <span class="toc-text">IO结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#DMA"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">DMA</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-number">1.3.</span> <span class="toc-text">操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Multiprogramming-%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F"><span class="toc-number">1.3.1.</span> <span class="toc-text">Multiprogramming(多道程序)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#multitasking%EF%BC%88%E5%A4%9A%E4%BB%BB%E5%8A%A1%EF%BC%89"><span class="toc-number">1.3.2.</span> <span class="toc-text">multitasking（多任务）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%93%8D%E4%BD%9C"><span class="toc-number">1.4.</span> <span class="toc-text">操作系统操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%87%8D%E6%A8%A1%E5%BC%8F%EF%BC%88dual-mode"><span class="toc-number">1.4.1.</span> <span class="toc-text">双重模式（dual-mode)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%92%E5%88%86%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">划分的原因</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86"><span class="toc-number">1.5.</span> <span class="toc-text">进程管理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.</span> <span class="toc-text">存储管理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%A1%E7%90%86"><span class="toc-number">1.6.1.</span> <span class="toc-text">文件系统管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">大容量存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IO%E5%AD%90%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.6.3.</span> <span class="toc-text">IO子系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%93%E5%86%B2%E5%8C%BA-Buffer-%E4%B8%8E%E7%BC%93%E5%AD%98-Cache-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.3.1.</span> <span class="toc-text">缓冲区(Buffer)与缓存(Cache)的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A6%82%E5%BF%B5%EF%BC%9ASpooling-%EF%BC%88%E5%8D%B3%E5%A4%96%E9%83%A8%E8%AE%BE%E5%A4%87%E8%81%94%E6%9C%BA%E5%B9%B6%E8%A1%8C%E6%93%8D%E4%BD%9C%EF%BC%89"><span class="toc-number">1.6.3.2.</span> <span class="toc-text">概念：Spooling （即外部设备联机并行操作）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%A1%A5%E5%85%85"><span class="toc-number">1.7.</span> <span class="toc-text">补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-number">1.7.1.</span> <span class="toc-text">并行与并发</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">第一章重点拾遗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%89%B9%E5%BE%81"><span class="toc-number">2.1.</span> <span class="toc-text">操作系统特征</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%AE%BE%E8%AE%A1%E7%9B%AE%E6%A0%87"><span class="toc-number">2.2.</span> <span class="toc-text">操作系统的两个设计目标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BD%A2%E6%88%90%E4%B8%8E%E5%8F%91%E5%B1%95"><span class="toc-number">2.3.</span> <span class="toc-text">操作系统形成与发展</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%88%86%E7%B1%BB"><span class="toc-number">2.4.</span> <span class="toc-text">操作系统分类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.1.</span> <span class="toc-text">单道批处理系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">2.4.1.1.</span> <span class="toc-text">特点：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E6%89%B9%E5%A4%84%E7%90%86%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.2.</span> <span class="toc-text">多道批处理操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F"><span class="toc-number">2.4.2.1.</span> <span class="toc-text">工作方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">2.4.2.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SPOOLing%E7%B3%BB%E7%BB%9F%E7%89%B9%E7%82%B9"><span class="toc-number">2.4.2.3.</span> <span class="toc-text">SPOOLing系统特点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.3.</span> <span class="toc-text">分时操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B7%A5%E4%BD%9C%E6%96%B9%E5%BC%8F-2"><span class="toc-number">2.4.3.1.</span> <span class="toc-text">工作方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E7%82%B9-2"><span class="toc-number">2.4.3.2.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%97%B6%E7%B3%BB%E7%BB%9F%E7%9B%AE%E6%A0%87%E4%B8%8E%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E7%9B%AE%E6%A0%87%E7%9A%84%E5%AF%B9%E6%AF%94"><span class="toc-number">2.4.3.3.</span> <span class="toc-text">分时系统目标与多道程序目标的对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E6%97%B6%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.4.</span> <span class="toc-text">实时操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BB%E8%A6%81%E8%BF%BD%E6%B1%82%E7%9B%AE%E6%A0%87"><span class="toc-number">2.4.4.1.</span> <span class="toc-text">主要追求目标</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.5.</span> <span class="toc-text">分布式操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.4.5.1.</span> <span class="toc-text">分布式系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81"><span class="toc-number">2.4.5.2.</span> <span class="toc-text">特征</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD"><span class="toc-number">2.5.</span> <span class="toc-text">中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">2.5.1.</span> <span class="toc-text">中断系统的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%A4%84%E7%90%86%E5%8E%9F%E7%90%86"><span class="toc-number">2.5.2.</span> <span class="toc-text">中断系统的处理原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E9%81%93%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E6%8A%80%E6%9C%AF%E4%B8%8E%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="toc-number">2.5.3.</span> <span class="toc-text">多道程序设计技术与中断系统</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9A%E9%81%93"><span class="toc-number">2.6.</span> <span class="toc-text">通道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8E%9F%E8%AF%AD"><span class="toc-number">2.7.</span> <span class="toc-text">原语</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">第二章：操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1"><span class="toc-number">3.1.</span> <span class="toc-text">操作系统服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%BD%BF%E7%94%A8%E5%92%8C%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B"><span class="toc-number">3.2.1.</span> <span class="toc-text">系统调用使用和执行过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%BB%E8%A6%81%E6%93%8D%E4%BD%9C"><span class="toc-number">3.2.1.1.</span> <span class="toc-text">执行系统调用的主要操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%88%86%E7%B1%BB"><span class="toc-number">3.2.2.</span> <span class="toc-text">系统调用分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E4%B8%8EAPI"><span class="toc-number">3.2.3.</span> <span class="toc-text">系统调用与API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%8D%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E8%80%8C%E6%98%AF%E4%BD%BF%E7%94%A8API%E7%9A%84%E5%8E%9F%E5%9B%A0"><span class="toc-number">3.2.3.1.</span> <span class="toc-text">不用系统调用而是使用API的原因</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">3.2.4.</span> <span class="toc-text">系统调用接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92"><span class="toc-number">3.2.5.</span> <span class="toc-text">系统调用的参数传递</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.3.</span> <span class="toc-text">操作系统设计与实现</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%BA%E5%88%B6%E4%B8%8E%E7%AD%96%E7%95%A5"><span class="toc-number">3.3.1.</span> <span class="toc-text">机制与策略</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84-2"><span class="toc-number">3.4.</span> <span class="toc-text">操作系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.1.</span> <span class="toc-text">模块结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">3.4.1.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9"><span class="toc-number">3.4.1.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.2.</span> <span class="toc-text">层次结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-2"><span class="toc-number">3.4.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-2"><span class="toc-number">3.4.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AE%E5%86%85%E6%A0%B8%E7%BB%93%E6%9E%84"><span class="toc-number">3.4.3.</span> <span class="toc-text">微内核结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%82%B9-3"><span class="toc-number">3.4.3.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%BA%E7%82%B9-3"><span class="toc-number">3.4.3.2.</span> <span class="toc-text">缺点</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">一二章习题拾遗</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">第三章：进程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A8%8B%E5%BA%8F%E4%B8%8E%E8%BF%9B%E7%A8%8B%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.1.</span> <span class="toc-text">程序与进程之间的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6%E5%9D%97"><span class="toc-number">5.2.</span> <span class="toc-text">进程控制块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PCB%E7%9A%84%E5%86%85%E5%AE%B9"><span class="toc-number">5.2.1.</span> <span class="toc-text">PCB的内容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E5%B9%B6%E5%8F%91%E5%BA%A6%EF%BC%88PCB%E8%A1%A8%EF%BC%89"><span class="toc-number">5.2.2.</span> <span class="toc-text">系统并发度（PCB表）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%84%E6%88%90%EF%BC%9A%E7%A8%8B%E5%BA%8F-%E6%95%B0%E6%8D%AE-PCB%EF%BC%88%E6%9E%84%E6%88%90%E8%BF%9B%E7%A8%8B%E4%B8%89%E8%A6%81%E7%B4%A0%EF%BC%89"><span class="toc-number">5.2.3.</span> <span class="toc-text">进程的组成：程序 + 数据 + PCB（构成进程三要素）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E5%8F%8A%E5%85%B6%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.3.</span> <span class="toc-text">进程的状态及其转换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">5.3.1.</span> <span class="toc-text">进程的创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B0%B1%E7%BB%AA-%E8%BF%90%E8%A1%8C"><span class="toc-number">5.3.2.</span> <span class="toc-text">就绪 -&gt; 运行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C-%E5%B0%B1%E7%BB%AA"><span class="toc-number">5.3.3.</span> <span class="toc-text">运行 -&gt; 就绪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%90%E8%A1%8C-%E7%AD%89%E5%BE%85-%E9%98%BB%E5%A1%9E"><span class="toc-number">5.3.4.</span> <span class="toc-text">运行 -&gt; 等待&#x2F;阻塞</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AD%89%E5%BE%85-%E9%98%BB%E5%A1%9E-%E5%B0%B1%E7%BB%AA"><span class="toc-number">5.3.5.</span> <span class="toc-text">等待&#x2F;阻塞 -&gt; 就绪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E-%E5%94%A4%E9%86%92%E8%BF%9B%E7%A8%8B"><span class="toc-number">5.3.6.</span> <span class="toc-text">阻塞&#x2F;唤醒进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E5%8E%9F%E8%AF%AD%EF%BC%88Block%EF%BC%89%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">5.3.6.1.</span> <span class="toc-text">阻塞原语（Block）的执行过程如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%94%A4%E9%86%92%E5%8E%9F%E8%AF%AD%EF%BC%88Wakeup%EF%BC%89%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">5.3.6.2.</span> <span class="toc-text">唤醒原语（Wakeup）的执行过程如下：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E4%B8%8E%E6%BF%80%E6%B4%BB"><span class="toc-number">5.3.7.</span> <span class="toc-text">挂起与激活</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%82%E8%B5%B7%E5%8E%9F%E8%AF%AD%EF%BC%88Suspend%EF%BC%89%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">5.3.7.1.</span> <span class="toc-text">挂起原语（Suspend）的执行过程如下：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%BF%80%E6%B4%BB%E5%8E%9F%E8%AF%AD%EF%BC%88Active%EF%BC%89%E7%9A%84%E6%89%A7%E8%A1%8C%E8%BF%87%E7%A8%8B%E5%A6%82%E4%B8%8B%EF%BC%9A"><span class="toc-number">5.3.7.2.</span> <span class="toc-text">激活原语（Active）的执行过程如下：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2"><span class="toc-number">5.4.</span> <span class="toc-text">进程切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E6%8D%A2%E8%BF%87%E7%A8%8B"><span class="toc-number">5.4.1.</span> <span class="toc-text">切换过程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%BB%88%E6%AD%A2"><span class="toc-number">5.4.1.1.</span> <span class="toc-text">进程的终止</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E9%98%9F%E5%88%97"><span class="toc-number">5.5.</span> <span class="toc-text">进程调度队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E5%99%A8%E7%9A%84%E4%B8%89%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">5.6.</span> <span class="toc-text">处理器的三级调度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%9C%E4%B8%9A%E8%B0%83%E5%BA%A6%EF%BC%88%E9%95%BF%E6%9C%9F%E8%B0%83%E5%BA%A6%E3%80%81%E9%AB%98%E7%BA%A7%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">5.6.1.</span> <span class="toc-text">作业调度（长期调度、高级调度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E8%B0%83%E5%BA%A6%EF%BC%88%E4%B8%AD%E7%BA%A7%E8%B0%83%E5%BA%A6%E3%80%81%E4%BA%A4%E6%8D%A2%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">5.6.2.</span> <span class="toc-text">内存调度（中级调度、交换调度）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%EF%BC%88%E4%BD%8E%E7%BA%A7%E8%B0%83%E5%BA%A6%E3%80%81CPU%E8%B0%83%E5%BA%A6%EF%BC%89"><span class="toc-number">5.6.3.</span> <span class="toc-text">进程调度（低级调度、CPU调度）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%8D%E8%AE%AE%E8%BF%9B%E7%A8%8B%E5%88%9B%E5%BB%BA%E4%B8%8E%E7%BB%88%E6%AD%A2"><span class="toc-number">5.7.</span> <span class="toc-text">再议进程创建与终止</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA"><span class="toc-number">5.7.1.</span> <span class="toc-text">创建</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82%E9%97%AE%E9%A2%98"><span class="toc-number">5.7.1.1.</span> <span class="toc-text">一些细节问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%88%E6%AD%A2"><span class="toc-number">5.7.2.</span> <span class="toc-text">终止</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1"><span class="toc-number">5.8.</span> <span class="toc-text">进程间通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">5.8.1.</span> <span class="toc-text">高级通信方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%AD%98%E5%82%A8%E5%99%A8%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.8.1.1.</span> <span class="toc-text">共享存储器系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92%E7%B3%BB%E7%BB%9F"><span class="toc-number">5.8.1.2.</span> <span class="toc-text">消息传递系统</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E7%BC%93%E5%86%B2%E9%80%9A%E4%BF%A1"><span class="toc-number">5.8.1.2.1.</span> <span class="toc-text">消息缓冲通信</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BF%A1%E7%AE%B1%E9%80%9A%E4%BF%A1"><span class="toc-number">5.8.1.2.2.</span> <span class="toc-text">信箱通信</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93%EF%BC%88%E5%85%B1%E4%BA%AB%E6%96%87%E4%BB%B6%EF%BC%89%E9%80%9A%E4%BF%A1"><span class="toc-number">5.8.1.3.</span> <span class="toc-text">管道（共享文件）通信</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%88%E4%BA%86%E8%A7%A3%EF%BC%89"><span class="toc-number">5.8.2.</span> <span class="toc-text">Linux系统中的进程间通信的机制（了解）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%A1%E9%81%93"><span class="toc-number">5.8.2.1.</span> <span class="toc-text">管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-number">5.8.2.2.</span> <span class="toc-text">消息队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">5.8.2.3.</span> <span class="toc-text">共享内存</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7"><span class="toc-number">5.8.2.4.</span> <span class="toc-text">信号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Socket"><span class="toc-number">5.8.2.5.</span> <span class="toc-text">Socket</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9-TCP-%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E7%9A%84-socket-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.8.2.5.1.</span> <span class="toc-text">针对 TCP 协议通信的 socket 编程模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9-UDP-%E5%8D%8F%E8%AE%AE%E9%80%9A%E4%BF%A1%E7%9A%84-socket-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.8.2.5.2.</span> <span class="toc-text">针对 UDP 协议通信的 socket 编程模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%92%88%E5%AF%B9%E6%9C%AC%E5%9C%B0%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84-socket-%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">5.8.2.5.3.</span> <span class="toc-text">针对本地进程间通信的 socket 编程模型</span></a></li></ol></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">第三章习题拾遗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%BB%E5%A1%9E%E4%B8%8E%E5%94%A4%E9%86%92"><span class="toc-number">6.1.</span> <span class="toc-text">阻塞与唤醒</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">6.1.1.</span> <span class="toc-text">临界区</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%88%B6%E5%AD%90%E8%BF%9B%E7%A8%8B%E4%B8%8D%E8%83%BD%E5%85%B1%E4%BA%AB%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">6.2.</span> <span class="toc-text">父子进程不能共享虚拟地址空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4"><span class="toc-number">6.3.</span> <span class="toc-text">虚拟地址空间</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E6%AE%B5"><span class="toc-number">6.3.1.</span> <span class="toc-text">内存分段</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%A1%B5"><span class="toc-number">6.3.2.</span> <span class="toc-text">内存分页</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%A1%B5%E8%A1%A8"><span class="toc-number">6.3.3.</span> <span class="toc-text">多级页表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#TLB"><span class="toc-number">6.3.4.</span> <span class="toc-text">TLB</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%AE%B5%E9%A1%B5%E5%BC%8F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">6.3.5.</span> <span class="toc-text">段页式内存管理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Linux-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">6.3.6.</span> <span class="toc-text">Linux 内存管理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">第四章：线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">单线程与多线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F"><span class="toc-number">7.2.</span> <span class="toc-text">线程概念与实现方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">7.3.</span> <span class="toc-text">多线程模型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E4%B8%80"><span class="toc-number">7.3.1.</span> <span class="toc-text">多对一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E5%AF%B9%E4%B8%80"><span class="toc-number">7.3.2.</span> <span class="toc-text">一对一</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E5%AF%B9%E5%A4%9A"><span class="toc-number">7.3.3.</span> <span class="toc-text">多对多</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">第四章习题拾遗</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">第五章：CPU调度</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">9.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU-IO-burst-cycle-%E7%90%86%E8%A7%A3%E4%B8%8E%E5%9B%BE%E5%83%8F"><span class="toc-number">9.1.1.</span> <span class="toc-text">CPU&#x2F;IO burst cycle 理解与图像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CPU%E8%B0%83%E5%BA%A6%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.1.2.</span> <span class="toc-text">CPU调度程序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%95%E6%97%B6%E5%8F%AF%E8%83%BD%E5%8F%91%E7%94%9F%E8%B0%83%E5%BA%A6%E5%86%B3%E7%AD%96"><span class="toc-number">9.1.2.1.</span> <span class="toc-text">何时可能发生调度决策</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E4%B8%8E%E9%9D%9E%E6%8A%A2%E5%8D%A0%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%9B%B8%E5%BA%94%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.2.2.</span> <span class="toc-text">抢占与非抢占的区别与相应问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98"><span class="toc-number">9.1.2.2.1.</span> <span class="toc-text">一个问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%B4%BE%E7%A8%8B%E5%BA%8F"><span class="toc-number">9.1.2.3.</span> <span class="toc-text">分派程序</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99%E4%B8%8E%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.</span> <span class="toc-text">调度准则与算法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E5%BA%A6%E5%87%86%E5%88%99"><span class="toc-number">9.2.1.</span> <span class="toc-text">调度准则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%88%B0%E5%85%88%E6%9C%8D%E5%8A%A1%EF%BC%88FCFS%EF%BC%8CFirst-Come-First-Served-%EF%BC%89"><span class="toc-number">9.2.2.</span> <span class="toc-text">先到先服务（FCFS，First-Come, First-Served ）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E4%BD%9C%E4%B8%9A%E4%BC%98%E5%85%88%E8%B0%83%E5%BA%A6%EF%BC%88SJF%EF%BC%89"><span class="toc-number">9.2.3.</span> <span class="toc-text">最短作业优先调度（SJF）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8FSJF"><span class="toc-number">9.2.3.1.</span> <span class="toc-text">非抢占式SJF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8FSJF"><span class="toc-number">9.2.3.2.</span> <span class="toc-text">抢占式SJF</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%80%E4%B8%AA%E9%97%AE%E9%A2%98-2"><span class="toc-number">9.2.3.3.</span> <span class="toc-text">一个问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">9.2.3.4.</span> <span class="toc-text">优缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E5%85%88%E7%BA%A7%E8%B0%83%E5%BA%A6"><span class="toc-number">9.2.4.</span> <span class="toc-text">优先级调度</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E6%9D%83%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.4.1.</span> <span class="toc-text">非抢占式优先权算法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%A2%E5%8D%A0%E5%BC%8F%E4%BC%98%E5%85%88%E6%9D%83%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95"><span class="toc-number">9.2.4.2.</span> <span class="toc-text">抢占式优先权调度算法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AE%E8%BD%AC%E6%B3%95%E8%B0%83%E5%BA%A6-RR%EF%BC%8CRound-Robin"><span class="toc-number">9.2.5.</span> <span class="toc-text">轮转法调度(RR，Round Robin )</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E9%98%9F%E5%88%97"><span class="toc-number">9.2.6.</span> <span class="toc-text">多级队列</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E7%BA%A7%E5%8F%8D%E9%A6%88%E9%98%9F%E5%88%97"><span class="toc-number">9.2.7.</span> <span class="toc-text">多级反馈队列</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Unix%E3%80%81Linux%E4%B8%8EWindows%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AD%96%E7%95%A5"><span class="toc-number">9.3.</span> <span class="toc-text">Unix、Linux与Windows进程调度策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">第五章习题拾遗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">10.1.</span> <span class="toc-text">上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5-2"><span class="toc-number">10.1.1.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CPU-%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-number">10.1.1.1.</span> <span class="toc-text">什么是 CPU 上下文</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-CPU-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">10.1.1.2.</span> <span class="toc-text">什么是 CPU 上下文切换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">10.1.2.</span> <span class="toc-text">系统调用的上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">10.1.3.</span> <span class="toc-text">进程上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E6%BD%9C%E5%9C%A8%E7%9A%84%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98"><span class="toc-number">10.1.3.1.</span> <span class="toc-text">进程上下文切换潜在的性能问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">10.1.4.</span> <span class="toc-text">线程上下文切换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%91%E7%94%9F%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E7%9A%84%E5%9C%BA%E6%99%AF"><span class="toc-number">10.1.4.1.</span> <span class="toc-text">发生线程上下文切换的场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-number">10.1.5.</span> <span class="toc-text">中断上下文切换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80%E4%BA%9B%E8%AE%A8%E8%AE%BA"><span class="toc-number">10.1.6.</span> <span class="toc-text">一些讨论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">第六章：进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E5%BC%95%E5%85%A5"><span class="toc-number">11.1.</span> <span class="toc-text">问题引入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%EF%BC%9A%E4%B8%B4%E7%95%8C%E5%8C%BA%E9%97%AE%E9%A2%98"><span class="toc-number">11.2.</span> <span class="toc-text">问题解决：临界区问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Peterson%E7%AE%97%E6%B3%95"><span class="toc-number">11.3.</span> <span class="toc-text">Peterson算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E5%90%8C%E6%AD%A5"><span class="toc-number">11.4.</span> <span class="toc-text">硬件同步</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E5%8E%9F%E5%AD%90%E6%8C%87%E4%BB%A4%E8%BF%9B%E8%A1%8C%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5"><span class="toc-number">11.4.1.</span> <span class="toc-text">利用原子指令进行进程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#TestAndSet"><span class="toc-number">11.4.1.1.</span> <span class="toc-text">TestAndSet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Swap"><span class="toc-number">11.4.1.2.</span> <span class="toc-text">Swap</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">11.4.1.3.</span> <span class="toc-text">存在的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%88-semaphore%EF%BC%89"><span class="toc-number">11.5.</span> <span class="toc-text">信号量（ semaphore）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8PV%E6%93%8D%E4%BD%9C%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9%EF%BC%9A"><span class="toc-number">11.5.1.</span> <span class="toc-text">使用PV操作注意事项：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%97%AE%E9%A2%98"><span class="toc-number">11.5.2.</span> <span class="toc-text">问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%99%E7%AD%89"><span class="toc-number">11.5.2.1.</span> <span class="toc-text">忙等</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%B1%E4%BA%AB%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98"><span class="toc-number">11.5.2.2.</span> <span class="toc-text">共享变量问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%EF%BC%88Deadlock%EF%BC%89%E4%B8%8E%E9%A5%BF%E6%AD%BB%EF%BC%88Starvation%EF%BC%89"><span class="toc-number">11.5.2.3.</span> <span class="toc-text">死锁（Deadlock）与饿死（Starvation）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98"><span class="toc-number">11.6.</span> <span class="toc-text">经典问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">11.6.1.</span> <span class="toc-text">生产者消费者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%BB%E8%80%85%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98"><span class="toc-number">11.6.2.</span> <span class="toc-text">读者写者问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-number">11.6.3.</span> <span class="toc-text">哲学家进餐问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96%E9%97%AE%E9%A2%98"><span class="toc-number">11.7.</span> <span class="toc-text">其他问题</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%92%E7%8B%92%E8%BF%87%E6%A1%A5%E9%97%AE%E9%A2%98"><span class="toc-number">11.7.1.</span> <span class="toc-text">狒狒过桥问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%90%86%E5%8F%91%E5%B8%88%E7%90%86%E5%8F%91%E9%97%AE%E9%A2%98"><span class="toc-number">11.7.2.</span> <span class="toc-text">理发师理发问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B-monitor"><span class="toc-number">11.8.</span> <span class="toc-text">管程(monitor)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F-Condition-Variable"><span class="toc-number">11.8.1.</span> <span class="toc-text">条件变量(Condition Variable)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-number">11.8.2.</span> <span class="toc-text">管程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98%E7%9A%84%E7%AE%A1%E7%A8%8B%E8%A7%A3%E6%B3%95"><span class="toc-number">11.8.3.</span> <span class="toc-text">哲学家进餐问题的管程解法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BD%BF%E7%94%A8%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E7%AE%A1%E7%A8%8B"><span class="toc-number">11.8.4.</span> <span class="toc-text">使用信号量实现管程</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%A1%E7%A8%8BVS%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">11.9.</span> <span class="toc-text">管程VS信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#PS"><span class="toc-number">11.9.1.</span> <span class="toc-text">PS.</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">第六章习题拾遗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E7%9A%84%E4%B8%80%E8%88%AC%E6%B5%81%E7%A8%8B"><span class="toc-number">12.1.</span> <span class="toc-text">设计的一般流程</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">论述类习题</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">参考</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/%E6%AF%95%E8%AE%BE%E4%BB%8E%E8%B0%83%E7%A0%94%E5%88%B0%E5%AE%8C%E5%B7%A5/" title="毕设从调研到完工"><img src="/img/cover2/2-min.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="毕设从调研到完工"></a><div class="content"><a class="title" href="/posts/%E6%AF%95%E8%AE%BE%E4%BB%8E%E8%B0%83%E7%A0%94%E5%88%B0%E5%AE%8C%E5%B7%A5/" title="毕设从调研到完工">毕设从调研到完工</a><time datetime="2024-01-03T13:30:28.000Z" title="发表于 2024-01-03 21:30:28">2024-01-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/2023%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E8%AE%BE%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" title="2023数据库课设经验分享"><img src="/img/cover3/4-min.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="2023数据库课设经验分享"></a><div class="content"><a class="title" href="/posts/2023%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%BE%E8%AE%BE%E7%BB%8F%E9%AA%8C%E5%88%86%E4%BA%AB/" title="2023数据库课设经验分享">2023数据库课设经验分享</a><time datetime="2023-08-18T08:01:49.000Z" title="发表于 2023-08-18 16:01:49">2023-08-18</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E5%88%A0%E9%99%A4gitignore%E4%BF%AE%E6%94%B9%E5%89%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%A7%E6%96%87%E4%BB%B6/" title="删除gitignore修改前提交的大文件"><img src="/img/cover1/18.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="删除gitignore修改前提交的大文件"></a><div class="content"><a class="title" href="/posts/%E5%88%A0%E9%99%A4gitignore%E4%BF%AE%E6%94%B9%E5%89%8D%E6%8F%90%E4%BA%A4%E7%9A%84%E5%A4%A7%E6%96%87%E4%BB%B6/" title="删除gitignore修改前提交的大文件">删除gitignore修改前提交的大文件</a><time datetime="2023-07-10T13:50:49.000Z" title="发表于 2023-07-10 21:50:49">2023-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E6%8E%92%E6%9F%A5/" title="记一次博客公式渲染排查"><img src="/img/cover1/1.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="记一次博客公式渲染排查"></a><div class="content"><a class="title" href="/posts/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E6%8E%92%E6%9F%A5/" title="记一次博客公式渲染排查">记一次博客公式渲染排查</a><time datetime="2023-06-23T01:21:51.000Z" title="发表于 2023-06-23 09:21:51">2023-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/A-star%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/" title="A-star路径规划"><img src="/img/cover1/33.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="A-star路径规划"></a><div class="content"><a class="title" href="/posts/A-star%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/" title="A-star路径规划">A-star路径规划</a><time datetime="2023-06-19T13:17:15.000Z" title="发表于 2023-06-19 21:17:15">2023-06-19</time></div></div></div></div></div></div></main><footer id="footer" style="background:0 0"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();" rel="external nofollow noreferrer"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());" rel="external nofollow noreferrer"><i class="iconfont icon-baidu"></i><span>搜索</span></a><a class="rightMenu-item" href="javascript:rmf.searchinThisPage();" rel="external nofollow noreferrer"><i class="fas fa-search"></i><span>站内搜索</span></a><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()" rel="external nofollow noreferrer"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()" rel="external nofollow noreferrer"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.translate();" rel="external nofollow noreferrer"><i class="iconfont icon-fanti"></i><span>繁简转换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="javascript:fullScreen();" rel="external nofollow noreferrer"><i class="fas fa-expand"></i><span>进入全屏</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script src="https://unpkg.com/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://unpkg.com/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://unpkg.com/katex/dist/katex.min.css"><script src="https://unpkg.com/katex/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach(a=>{btf.wrap(a,"div",{class:"katex-wrap"})})</script><script>function getGiscusTheme(e){return"dark"===e?"dark":"light"}function loadGiscus(){var e,t=Object.assign({src:"https://giscus.app/client.js","data-repo":"ZWN2001/ZWN2001.github.io","data-repo-id":"R_kgDOGH1XWg","data-category-id":"DIC_kwDOGH1XWs4CXnHJ","data-mapping":"pathname","data-theme":getGiscusTheme(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0},{"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous","data-mapping":"og:title","data-input-position":"top","data-category":"Announcements"}),a=document.createElement("script");for(e in t)a.setAttribute(e,t[e]);document.getElementById("giscus-wrap").insertAdjacentElement("afterbegin",a)}function changeGiscusTheme(e){var t;e={setConfig:{theme:getGiscusTheme(e)}},(t=document.querySelector("iframe.giscus-frame"))&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}function loadOtherComment(){loadGiscus()}btf.addModeChange("giscus",changeGiscusTheme),btf.loadComment(document.getElementById("giscus-wrap"),loadGiscus)</script></div><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax src="https://fastly.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script><script data-pjax>function GithubCalendarConfig(){var t=document.getElementById("recent-posts");t&&"/"==location.pathname&&(console.log("已挂载github calendar"),t.insertAdjacentHTML("afterbegin",'<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>')),GithubCalendar("https://my-hexo-github-calender.vercel.app/api/?ZWN2001",["#ebedf0","#f1f8ff","#dbedff","#c8e1ff","#79b8ff","#2188ff","#0366d6","#005cc5","#044289","#032f62","#05264c"],"ZWN2001")}document.getElementById("recent-posts")&&GithubCalendarConfig()</script><style>#github_container{min-height:280px}@media screen and (max-width:650px){#github_container{min-height:0}}</style><style></style><script data-pjax>var parent,child;document.getElementById("recent-posts")&&"/"===location.pathname&&(parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/编程知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 洛雪の编程知识 (17)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/实用知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 洛雪の实用知识 (14)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/学习-课外拓展/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 洛雪の学习-课外拓展 (20)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/学习-课内知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 洛雪の学习-课内知识 (57)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://zwn2001.space/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>',console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child))</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#b30070}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style></body></html>