<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"><title>BUAA复试专业课拾遗 | ZWN's blog</title><meta name="author" content="琉璃月"><meta name="copyright" content="琉璃月"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="BUAA复试专业课拾遗 数据库 什么是关系代数 关系代数是关系数据库系统中的一种数学基础，用于描述和操作关系数据库中的数据。它包括一组操作，这些操作可以对关系（表）进行操作和组合，以生成所需的结果。关系代数操作通常包括选择、投影、连接、并、差等操作，这些操作可以用来查询数据库、插入数据、更新数据等。 关系代数提供了一种抽象的方式来描述数据库操作，使得数据库管理系统能够根据用户的查询需求来优化查询执"><meta property="og:type" content="article"><meta property="og:title" content="BUAA复试专业课拾遗"><meta property="og:url" content="https://zwn2001.space/posts/Graduate-Works/Experiences/2024BUAA%E5%A4%8D%E8%AF%95%E4%B8%93%E4%B8%9A%E8%AF%BE%E6%8B%BE%E9%81%97/index.html"><meta property="og:site_name" content="ZWN&#39;s blog"><meta property="og:description" content="BUAA复试专业课拾遗 数据库 什么是关系代数 关系代数是关系数据库系统中的一种数学基础，用于描述和操作关系数据库中的数据。它包括一组操作，这些操作可以对关系（表）进行操作和组合，以生成所需的结果。关系代数操作通常包括选择、投影、连接、并、差等操作，这些操作可以用来查询数据库、插入数据、更新数据等。 关系代数提供了一种抽象的方式来描述数据库操作，使得数据库管理系统能够根据用户的查询需求来优化查询执"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://zwn2001.space/img/cover/2.jpg"><meta property="article:published_time" content="2024-04-01T06:00:52.000Z"><meta property="article:modified_time" content="2024-04-01T12:20:21.000Z"><meta property="article:author" content="琉璃月"><meta property="article:tag" content="考研"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://zwn2001.space/img/cover/2.jpg"><link rel="shortcut icon" href="/img/favicon.webp"><link rel="canonical" href="https://zwn2001.space/posts/Graduate-Works/Experiences/2024BUAA%E5%A4%8D%E8%AF%95%E4%B8%93%E4%B8%9A%E8%AF%BE%E6%8B%BE%E9%81%97/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://unpkg.com/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"/search.xml",preload:!0,top_n_per_article:-1,unescape:!1,languages:{hits_empty:"找不到您查询的内容：${query}",hits_stats:"共找到 ${hits} 篇文章"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:{limitDay:200,position:"top",messagePrev:"距离上次更新已经过去",messageNext:"天啦！注意内容可能过时。"},highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:300},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",dateSuffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://unpkg.com/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://unpkg.com/flickr-justified-gallery/dist/fjGallery.css"}},isPhotoFigcaption:!0,islazyload:!1,isAnchor:!0,percent:{toc:!0,rightside:!0},autoDarkmode:!1}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"BUAA复试专业课拾遗",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2024-04-01 20:20:21"}</script><noscript><style type="text/css">#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,a){0!==a&&(a=864e5*a,t={value:t,expiry:(new Date).getTime()+a},localStorage.setItem(e,JSON.stringify(t)))},get:function(e){var t=localStorage.getItem(e);if(t){t=JSON.parse(t);if(!((new Date).getTime()>t.expiry))return t.value;localStorage.removeItem(e)}}},e.getScript=o=>new Promise((t,e)=>{const a=document.createElement("script");a.src=o,a.async=!0,a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.getCSS=(o,n=!1)=>new Promise((t,e)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=o,n&&(a.id=n),a.onerror=e,a.onload=a.onreadystatechange=function(){var e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,t())},document.head.appendChild(a)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","ffffff")};e=saveToLocal.get("theme"),"dark"===e?activateDarkMode():"light"===e&&activateLightMode(),e=saveToLocal.get("aside-status");void 0!==e&&("hide"===e?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/rightmenu.css"><link rel="stylesheet" href="/css/loadimg.css"><link rel="stylesheet" href="/css/project.css"><link type="text/html" rel="stylesheet" href="/css/wide_screen.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"><style>#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags:before{content:"\A";white-space:pre}#recent-posts>.recent-post-item>.recent-post-info>.article-meta-wrap>.tags>.article-meta__separator{display:none}</style><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" src="/img/favicon.webp"><div class="loading-image-dot"></div><div id="loading-percentage"></div></div></div><script>const loadingPercentage=document.getElementById("loading-percentage");loadingPercentage.style.color="black";let loadingPercentageTimer=setInterval(function(){var e=document.querySelector(".pace-progress");e&&(e=e.getAttribute("data-progress-text"))!==loadingPercentage.textContent&&"60%"===(loadingPercentage.textContent=e)&&clearInterval(loadingPercentageTimer)},100);const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",()=>{preloader.endLoading()})</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.webp" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">171</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(/img/cover/2.jpg)"><nav id="nav"><span id="blog-info"><a href="/" title="ZWN's blog"><span class="site-name">ZWN's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">BUAA复试专业课拾遗</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-04-01T06:00:52.000Z" title="发表于 2024-04-01 14:00:52">2024-04-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-04-01T12:20:21.000Z" title="更新于 2024-04-01 20:20:21">2024-04-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E6%9D%82%E8%AE%B0/">杂记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">23.3k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>69分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>BUAA复试专业课拾遗</h1><h2 id="数据库">数据库</h2><h3 id="什么是关系代数">什么是关系代数</h3><p>关系代数是关系数据库系统中的一种数学基础，用于描述和操作关系数据库中的数据。它包括一组操作，这些操作可以对关系（表）进行操作和组合，以生成所需的结果。关系代数操作通常包括选择、投影、连接、并、差等操作，这些操作可以用来查询数据库、插入数据、更新数据等。</p><p>关系代数提供了一种抽象的方式来描述数据库操作，使得数据库管理系统能够根据用户的查询需求来优化查询执行计划。关系代数是关系数据库理论的基础之一，它为关系数据库系统的设计和实现提供了重要的理论支持。</p><h3 id="数据库概念中，什么是聚集函数">数据库概念中，什么是聚集函数</h3><p>在数据库中，聚集函数（Aggregate Functions）是用于对一组值进行计算并返回单个值作为结果的函数。这些函数通常用于对数据库表中的数据进行统计、汇总或计算，例如计算平均值、总和、最大值、最小值等。</p><p>常见的数据库聚集函数包括：</p><ol><li>COUNT：用于计算指定列或行的行数。</li><li>SUM：用于计算指定列的总和。</li><li>AVG：用于计算指定列的平均值。</li><li>MAX：用于找出指定列的最大值。</li><li>MIN：用于找出指定列的最小值。</li></ol><p>通过使用聚集函数，可以对数据库中的数据进行汇总和分析，从而得出有用的统计信息。这些函数通常与SELECT语句结合使用，以便从数据库中提取所需的汇总数据。</p><h3 id="数据库概念中，什么是索引">数据库概念中，什么是索引</h3><p>在数据库中，索引（Index）是一种数据结构，用于加快对数据库表中数据的检索速度。索引类似于书籍的目录，它提供了一种快速查找数据的方法，可以帮助数据库系统快速定位到包含特定值的行，而不必逐行扫描整个表。</p><p>通过在数据库表的一个或多个列上创建索引，可以提高查询的性能，特别是在大型数据集上。当执行查询时，数据库系统可以利用索引直接定位到包含查询条件的数据行，而不必扫描整个表。这样可以减少查询所需的时间，并提高数据库系统的效率。</p><p>索引通常可以在唯一值列上创建，以确保列中的值是唯一的（唯一索引），也可以在非唯一值列上创建，以加快对这些列的检索速度（非唯一索引）。但是，索引的创建也会增加数据库的存储空间，并在插入、更新和删除数据时增加一定的开销，因此需要根据具体情况进行权衡和优化。</p><h3 id="数据库概念中，什么是视图">数据库概念中，什么是视图</h3><p>在数据库中，视图（View）是一种虚拟表，它是基于一个或多个实际表的查询结果集。视图本身不包含实际存储的数据，而是根据定义的查询语句动态生成结果。通过视图，用户可以以一种逻辑上的方式查看数据，而无需访问实际的表结构。</p><p>视图的主要作用包括：</p><ol><li>简化复杂查询：视图可以将复杂的查询逻辑封装在一个视图中，使用户可以通过简单的查询来访问数据。</li><li>数据安全性：通过视图，可以限制用户只能访问他们需要的数据，隐藏敏感数据，提高数据安全性。</li><li>数据独立性：视图可以隐藏实际表结构的变化，使应用程序与数据库表的结构解耦。</li><li>简化权限管理：可以通过视图控制用户对数据的访问权限，而不必直接操作表级权限。</li></ol><p>创建视图时，需要定义视图的查询语句，并为视图指定一个名称。用户可以像查询表一样查询视图，数据库系统会根据视图的定义动态生成结果。视图在数据库中起到类似于虚拟表的作用，提供了一种便捷的数据访问方式。</p><h3 id="数据库概念中，什么是正则覆盖">数据库概念中，什么是正则覆盖</h3><p>在数据库理论中，正则覆盖（Canonical Cover）是指关系模式的一组函数依赖中的最小且等价的集合。函数依赖是关系数据库中用来描述数据之间的约束关系的概念，它表示一个属性集合的取值决定另一个属性集合的取值。</p><p>正则覆盖的目的是简化函数依赖集合，去除冗余和重复的依赖关系，以便更有效地表示数据之间的关系。一个函数依赖集合的正则覆盖应当满足以下条件：</p><ol><li>要包含原始函数依赖的所有关键属性。</li><li>要包含原始函数依赖的所有冗余依赖，即可以通过其他依赖推导出来的依赖关系。</li></ol><p>通过计算正则覆盖，可以消除不必要的函数依赖，减少数据冗余，提高数据库设计的规范性和效率。正则覆盖是关系数据库设计中的重要概念，有助于确保数据库模式的一致性和正确性。</p><p>函数依赖集可能拥有可从其他推导出来的冗余的依赖，F的正则覆盖是一个与F相等的<strong>最小的函数依赖集</strong>，没有冗余的依赖，也没有<strong>无关属性</strong>。</p><blockquote><p>无关属性：如果去除一个函数依赖中的属性，不会改变该函数依赖集的闭包，则称该属性是无关的(extraneous)</p></blockquote><p>无关属性的核心：能够被函数依赖集F逻辑蕴涵的函数依赖，不必出现在F中。</p><p>满足下列条件的函数依赖集F称为正则覆盖，记作��<em>F**c</em>：</p><ul><li>Fc 与 F 等价（F逻辑蕴涵Fc,中的所有依赖； Fc 逻辑蕴涵 F 中的所有依赖）</li><li>Fc 中任何函数依赖都不含无关属性</li><li>Fc 中函数依赖的<strong>左半部都是唯一</strong>的</li></ul><p>F的正则覆盖作用：</p><ul><li>假设在一个关系模式上有一个函数依赖集F。当用户对于关系进行更新时，数据库系统将保证此操作不会破坏任何一个函数依赖</li><li>可以通过测试与给定函数依赖集有相同闭包的简化集的方式，来降低检测的开销</li></ul><h3 id="数据库概念中，什么是函数依赖">数据库概念中，什么是函数依赖</h3><p>在数据库理论中，函数依赖（Functional Dependency）是指一个属性（或属性集合）的取值决定另一个属性（或属性集合）的取值的约束关系。在关系数据库中，函数依赖用来描述数据之间的约束和规则，帮助我们理解数据之间的关系。</p><p>函数依赖通常表示为X -&gt; Y，其中X和Y是属性（或属性集合）。这个函数依赖的意思是，给定一个关系实例中X的值，可以唯一确定该实例中Y的值。换句话说，如果两个元组在属性X上的取值相同，那么它们在属性Y上的取值也必须相同。</p><p>函数依赖有几种类型，其中包括：</p><ol><li>完全函数依赖（Full Functional Dependency）：在X -&gt; Y中，如果去掉X中任何一个属性，Y就不再函数依赖于X，则称为完全函数依赖。</li><li>部分函数依赖（Partial Functional Dependency）：在X -&gt; Y中，如果Y依赖于X的一个子集，而不是整个X，则称为部分函数依赖。</li><li>传递函数依赖（Transitive Functional Dependency）：在X -&gt; Y和Y -&gt; Z中，如果Z依赖于X，而不是直接依赖于Y，则称为传递函数依赖。</li></ol><p>函数依赖是关系数据库设计中的重要概念，可以帮助我们规范化数据库模式，减少数据冗余，并确保数据的一致性和完整性。</p><h3 id="数据库概念中，什么是多值依赖">数据库概念中，什么是多值依赖</h3><p>在数据库理论中，多值依赖（Multivalued Dependency）是一种特殊类型的依赖关系，用于描述关系数据库中的数据约束。多值依赖涉及到属性之间的关系，其中一个属性集合的取值决定另一属性集合的取值。</p><p>多值依赖通常表示为X -&gt;-&gt; Y，其中X和Y是属性集合。这个多值依赖的含义是，给定一个关系实例中X的值，可以唯一确定该实例中Y的值，但X和Y之间并不是简单的一对一关系，而是一对多的关系。</p><p>举个例子来说明多值依赖：假设有一个关系模式R(A, B, C)，如果对于每个A值，存在多个B值和多个C值相关联，且B值和C值之间是独立的（即B值的变化不会影响C值，反之亦然），那么就存在一个多值依赖A -&gt;-&gt; B, C。</p><p>多值依赖在数据库设计中起着重要作用，它有助于规范化数据库模式，减少数据冗余，并确保数据的一致性和完整性。处理多值依赖需要特殊的技术和规范化方法，以确保数据库设计的正确性和高效性。</p><h3 id="E-R模型合并会有哪些问题">E-R模型合并会有哪些问题</h3><p>在数据库设计中，E-R模型（实体-关系模型）是一种用于描述实体之间关系的图形化工具。当合并多个E-R模型时，可能会遇到以下一些问题：</p><ol><li><p><strong>实体冲突</strong>：不同的E-R模型可能包含相同名称的实体，但其含义可能不同。在合并时需要解决这些实体冲突，确保每个实体在整个数据库模型中有清晰而唯一的定义。</p></li><li><p><strong>关系冲突</strong>：不同的E-R模型可能定义了相同名称的关系，但其语义可能有所不同。合并时需要确保关系的定义一致，避免混淆。</p></li><li><p><strong>属性冲突</strong>：不同的E-R模型可能对相同实体定义了不同的属性，或者同一属性在不同模型中有不同的数据类型或含义。在合并模型时需要解决这些属性冲突，统一属性定义。</p></li><li><p><strong>关系重叠</strong>：不同的E-R模型可能存在重叠的关系，即多个关系描述了相同的实体之间的联系。在合并时需要合理地整合这些关系，避免冗余和混淆。</p></li><li><p><strong>一致性问题</strong>：合并多个E-R模型可能导致一致性问题，例如数据冗余、不一致的约束条件等。在合并过程中需要仔细检查和调整，确保数据库设计的一致性和完整性。</p></li><li><p><strong>性能问题</strong>：合并多个E-R模型可能导致数据库结构复杂化，影响查询性能和数据操作效率。在设计合并后的数据库模型时需要考虑性能优化的问题。</p></li></ol><p>解决这些问题需要仔细分析不同E-R模型之间的差异，进行适当的调整和整合，确保合并后的数据库模型能够满足需求、保持一致性，并具有良好的性能。</p><h3 id="对“全部”的表示">对“全部”的表示</h3><p>其实就是对关系代数里除法的实现和理解，一般：</p><ul><li>使用<code>NOT EXISTS (B EXCEPT A)</code></li><li>使用<code>NOT IN ( NOT IN )</code></li><li>使用<code>NOT EXISTS (NOT EXISTS)</code></li></ul><p>需要注意的是通常需要在进行除法之前先将数据投影出来。</p><h3 id="数据库的特征">数据库的特征</h3><ul><li>数据按一定的数据模型组织、描述和储存</li><li>可为各种用户共享</li><li>冗余度较小</li><li>易扩展</li></ul><h3 id="关系模式">关系模式</h3><p><strong>关系</strong>：若干元组的集合，说白了就是指数据库表<br><strong>关系模式</strong>：对关系的描述称为关系模式，最后会详细描述</p><p>关系模式是对关系的描述（有哪些属性，各个属性之间的依赖关系如何），模式的一个具体值称为模式的一个实例。模式反应是数据的结构及其联系，是型，是相对稳定的，实例反应的是关系某一时刻的状态，是值，是相对变动的。</p><ol><li>关系和关系模式的区别<ol><li>关系模式是型,关系是值,关系模式是对关系的描述</li><li>关系是关系模式在某一个时刻的状态或者内容,关系模式是静态的,稳定的,而关系是动态的,随时间不断变化的,因为关系操作在不断地更新着数据库中的数据</li><li>类似于面向对象程序设计中”类“与”对象“的区别。”关系“是”关系模式“的一个实例，可以把”关系”理解为一张带数据的表，而“关系模式”是这张数据表的表结构。</li></ol></li><li>关系模型和关系的区别<ul><li>关系模型包含关系,关系是关系模型的数据结构,在关系模型中,现实世界的实体以及实体间的各级联系均用单一的结构类型,即关系来表示</li></ul></li></ol><h3 id="讲讲数据库Armstrong公理">讲讲数据库Armstrong公理</h3><p>Armstrong公理是关系数据库理论中的一组重要公理，用于推导关系数据库中的函数依赖。函数依赖描述了一个属性集合的值如何决定另一个属性集合的值。Armstrong公理由Armstrong在20世纪70年代提出，是数据库规范化和优化的基础之一。</p><p>Armstrong公理包括以下三条规则：</p><ol><li><p><strong>自反性（Reflexivity）</strong>：如果Y是X的子集，那么X -&gt; Y，即X的属性集合能够决定Y的属性集合。</p></li><li><p><strong>增广性（Augmentation）</strong>：如果X -&gt; Y，那么对于任何Z，XZ -&gt; YZ，即在X的基础上增加属性Z，依赖关系仍然成立。</p></li><li><p><strong>传递性（Transitivity）</strong>：如果X -&gt; Y且Y -&gt; Z，那么X -&gt; Z，即如果X能够决定Y的属性，Y又能够决定Z的属性，那么X也能够决定Z的属性。</p></li></ol><p>基于这些公理，我们可以推导出更多的函数依赖关系，帮助数据库设计者理解和优化数据库模式。Armstrong公理在数据库规范化过程中起着重要的作用，可以帮助设计者识别和消除冗余数据，确保数据库结构的合理性和一致性。</p><h3 id="数据库锁">数据库锁</h3><p>在数据库管理系统中，锁是用于控制并发访问的机制，以确保数据的一致性和完整性。数据库锁可以分为不同类型，常见的包括：</p><ol><li><p><strong>共享锁（Shared Lock）</strong>：也称为读锁，允许多个事务同时读取一个数据项，但不允许任何事务修改该数据项。共享锁之间不互斥，多个事务可以同时持有共享锁。</p></li><li><p><strong>排他锁（Exclusive Lock）</strong>：也称为写锁，只允许一个事务对数据项进行修改，其他事务无法同时持有排他锁或共享锁，确保数据的独占性。</p></li><li><p><strong>意向锁（Intention Lock）</strong>：用于表示事务对某个数据对象有意向获取共享锁或排他锁，可以帮助提高并发性能。</p></li><li><p><strong>行级锁（Row-level Lock）</strong>：锁定数据库表中的单个行，可以控制对行级数据的访问，避免并发修改导致数据不一致。</p></li><li><p><strong>表级锁（Table-level Lock）</strong>：锁定整个数据库表，限制对整个表的读写操作，通常会影响并发性能。</p></li></ol><p>数据库锁的主要作用包括：</p><ul><li><p><strong>保证数据一致性</strong>：通过锁机制，避免多个事务同时对同一数据进行读写操作，确保数据的正确性和一致性。</p></li><li><p><strong>控制并发访问</strong>：数据库锁可以协调多个事务之间的并发访问，避免数据竞争和冲突，提高系统的并发性能。</p></li><li><p><strong>实现事务隔离级别</strong>：数据库管理系统通过锁机制来实现不同的事务隔离级别，如读未提交、读已提交、可重复读和串行化。</p></li><li><p><strong>避免死锁</strong>：合理设计锁的获取顺序和释放时机，可以避免事务之间发生死锁情况，保证系统的稳定性。</p></li></ul><p>在实际应用中，数据库锁的设计和管理是数据库系统性能和并发控制的关键因素之一，需要根据具体应用场景和需求合理选择和配置锁机制。</p><h3 id="数据库的三个完整性是什么？">数据库的三个完整性是什么？</h3><p>数据库的三个完整性是指实体完整性、参照完整性和用户定义的完整性。这些完整性约束确保数据库中的数据保持一致性和有效性。</p><ol><li><p><strong>实体完整性（Entity Integrity）</strong>：</p><ul><li>实体完整性要求每个表必须有一个主键，并且主键不能包含空值（NULL）或重复值。主键是唯一标识表中每个记录的属性或属性组合。</li></ul></li><li><p><strong>参照完整性（Referential Integrity）</strong>：</p><ul><li>参照完整性确保在表之间的关系中，外键值（子表中的外键）必顋是父表中主键值的约束。换句话说，如果在一个表中有外键引用另一个表的主键，那么外键值必须是父表中主键值的一个有效引用。</li></ul></li><li><p><strong>用户定义的完整性（User-defined Integrity）</strong>：</p><ul><li>用户定义的完整性是由用户自定义的业务规则或约束，用于确保数据满足特定的业务要求。这些规则可以包括数据格式、取值范围、业务逻辑等方面的约束。</li></ul></li></ol><p>这些完整性约束在数据库设计和管理中起着重要作用，可以保证数据的有效性、一致性和完整性。实体完整性和参照完整性是数据库管理系统内置的约束，而用户定义的完整性则是根据具体业务需求自定义的约束。综合使用这三种完整性约束可以有效地维护数据库的数据质量和一致性。</p><h3 id="数据库主从复制的原理">数据库主从复制的原理</h3><p>数据库主从复制（Master-Slave Replication）是一种常见的数据库复制技术，用于在多个数据库服务器之间同步数据，提高系统的可用性、可扩展性和容错能力。主从复制的原理如下：</p><ol><li><p><strong>角色划分</strong>：</p><ul><li><strong>主数据库（Master）</strong>：主数据库是数据更新的源头，负责接收客户端的写操作（INSERT、UPDATE、DELETE）并记录这些操作，然后将这些操作日志传播给从数据库。</li><li><strong>从数据库（Slave）</strong>：从数据库接收主数据库传来的更新操作，并将这些操作在本地执行，从而保持与主数据库的数据一致性。</li></ul></li><li><p><strong>数据传输流程</strong>：</p><ul><li>主数据库记录所有的数据更新操作，将这些操作以日志形式记录在日志文件中（如二进制日志），从数据库定期轮询主数据库的日志文件，将主数据库的操作日志复制到从数据库。</li><li>从数据库接收到主数据库的操作日志后，按照主数据库的操作顺序逐一执行这些操作，从而实现数据在主从之间的同步。</li></ul></li><li><p><strong>数据同步机制</strong>：</p><ul><li>主从数据库之间的数据同步可以采用异步方式或半同步方式。在异步复制中，主数据库将操作日志发送给从数据库后即认为操作完成，而在半同步复制中，主数据库等待至少一个从数据库确认已经接收到操作日志后才认为操作完成。</li><li>数据同步的方式可以根据需求选择，异步复制可以提高性能但可能存在数据延迟，而半同步复制可以提高数据一致性但会增加主数据库的负担。</li></ul></li><li><p><strong>故障处理</strong>：</p><ul><li>主从复制可以提供故障转移的能力，当主数据库发生故障时，可以将一个从数据库提升为新的主数据库，确保系统的持续可用性。</li><li>此外，主从复制还可以用于读写分离，将读操作分发给从数据库，从而提高系统的读取性能。</li></ul></li></ol><p>通过主从复制技术，可以实现数据库之间的数据同步和备份，提高系统的可用性和可靠性，同时也可以用于负载均衡和数据分发。</p><h3 id="数据库中关系运算有哪些？">数据库中关系运算有哪些？</h3><p>数据库中的关系运算是指对关系数据库中的关系（表）进行操作和处理的一组操作。常见的关系运算包括以下几种：</p><ol><li><p><strong>选择（Selection）</strong>：选择操作用于从表中选择满足指定条件的行。语法为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{condition}(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight">n</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">o</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span> 是表，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>n</mi><mi>d</mi><mi>i</mi><mi>t</mi><mi>i</mi><mi>o</mi><mi>n</mi></mrow><annotation encoding="application/x-tex">condition</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">co</span><span class="mord mathnormal">n</span><span class="mord mathnormal">d</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">i</span><span class="mord mathnormal">o</span><span class="mord mathnormal">n</span></span></span></span> 是选择条件。</p></li><li><p><strong>投影（Projection）</strong>：投影操作用于从表中选择指定的列。语法为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>m</mi><mi>n</mi><mi>s</mi></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{columns}(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-.25em"></span><span class="mord"><span class="mord mathnormal" style="margin-right:.03588em">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:.33610799999999996em"><span style="top:-2.5500000000000003em;margin-left:-.03588em;margin-right:.05em"><span class="pstrut" style="height:2.7em"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">co</span><span class="mord mathnormal mtight" style="margin-right:.01968em">l</span><span class="mord mathnormal mtight">u</span><span class="mord mathnormal mtight">mn</span><span class="mord mathnormal mtight">s</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:.15em"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mclose">)</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span> 是表，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>o</mi><mi>l</mi><mi>u</mi><mi>m</mi><mi>n</mi><mi>s</mi></mrow><annotation encoding="application/x-tex">columns</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.69444em;vertical-align:0"></span><span class="mord mathnormal">co</span><span class="mord mathnormal" style="margin-right:.01968em">l</span><span class="mord mathnormal">u</span><span class="mord mathnormal">mn</span><span class="mord mathnormal">s</span></span></span></span> 是要选择的列。</p></li><li><p><strong>并（Union）</strong>：并操作用于合并两个表中的元组，并去除重复的元组。语法为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∪</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R \cup S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 是两个表。</p></li><li><p><strong>交（Intersection）</strong>：交操作用于找出两个表中共同存在的元组。语法为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>∩</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R \cap S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 是两个表。</p></li><li><p><strong>差（Difference）</strong>：差操作用于找出存在于第一个表中但不存在于第二个表中的元组。语法为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>−</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R - S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">−</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 是两个表。</p></li><li><p><strong>笛卡尔积（Cartesian Product）</strong>：笛卡尔积操作用于将两个表的每个元组组合在一起。语法为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>×</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R \times S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">×</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 是两个表。</p></li><li><p><strong>连接（Join）</strong>：连接操作用于根据两个表之间的共同属性将它们连接在一起。常见的连接包括内连接、外连接（左外连接、右外连接、全外连接）等。</p></li><li><p><strong>除（Division）</strong>：除操作用于找出满足一个表中所有值都能在另一个表中找到的元组。语法为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi><mo>÷</mo><mi>S</mi></mrow><annotation encoding="application/x-tex">R \div S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.76666em;vertical-align:-.08333em"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span><span class="mspace" style="margin-right:.2222222222222222em"></span><span class="mbin">÷</span><span class="mspace" style="margin-right:.2222222222222222em"></span></span><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span>，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>R</mi></mrow><annotation encoding="application/x-tex">R</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.00773em">R</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord mathnormal" style="margin-right:.05764em">S</span></span></span></span> 是两个表。</p></li></ol><p>这些关系运算是关系型数据库中常用的操作，用于查询、筛选、合并和处理数据，帮助实现复杂的数据操作和查询需求。</p><h3 id="实体之间的联系有那些？">实体之间的联系有那些？</h3><p>一对一联系：指实体集E1中的一个实体最多只与实体集E2中的一个实体相联系。</p><p>例如：电影院的座位和观众实体之间的联系。</p><p>一对多联系：表示实体集E1中的一个实体可与实体集E2中的多个实体相联系。</p><p>例如：部门和职工两个实体集 之间的联系。</p><p>多对多联系：表示实体集E1中的多个实体可与实体集E2中的多个实体相联系。</p><p>例如：工程项目和职工两个实体集之间的联系。</p><h2 id="编译原理">编译原理</h2><h3 id="编译原理中DFA与NFA的作用">编译原理中DFA与NFA的作用</h3><p>在编译原理中，DFA（Deterministic Finite Automaton）和NFA（Nondeterministic Finite Automaton）是有限自动机的两种类型，它们在词法分析和语法分析阶段起着重要作用。</p><ol><li><p>DFA（确定有限自动机）：</p><ul><li>DFA 是一种自动机模型，用于识别正则语言。在编译原理中，DFA 主要用于实现词法分析器（Lexer）。</li><li>词法分析器根据给定的词法规则（如正则表达式）将源代码分解为词法单元（tokens）。DFA 可以用来识别和匹配这些词法单元。</li><li>DFA 具有确定性，即从任何给定状态和输入符号，只有一种转移选择。这种确定性使得 DFA 在实际应用中更易于实现和理解。</li></ul></li><li><p>NFA（非确定有限自动机）：</p><ul><li>NFA 也是一种自动机模型，与 DFA 不同的是，NFA 允许在某个状态下有多个可能的转移。</li><li>在编译原理中，NFA 通常用于实现正则表达式到 NFA 的转换。这种转换通常在词法分析器的构建过程中使用。</li><li>尽管 NFA 不如 DFA 易于实现和理解，但在某些情况下，NFA 可以更简洁地表达一些复杂的正则语言。</li></ul></li></ol><p>总的来说，DFA 和 NFA 在编译原理中都有各自的作用。DFA 主要用于实际的词法分析器的实现，而 NFA 则在词法分析器构建的过程中经常用于正则表达式的处理和转换。</p><h3 id="编译原理中什么是文法">编译原理中什么是文法</h3><p>在编译原理中，文法（Grammar）是描述编程语言结构的形式化规则集合。文法用于定义编程语言的语法结构，规定了程序员如何编写有效的代码。文法通常用于语法分析阶段，帮助编译器理解源代码的结构。</p><p>文法通常由一组产生式（Production Rules）组成，每个产生式规定了如何将一个非终结符号（Non-terminal symbol）替换为一个终结符号串（Terminal symbol sequence）。在文法中，非终结符号代表语法结构的抽象符号，而终结符号则是实际出现在代码中的符号（如关键字、标识符、运算符等）。</p><p>文法通常分为不同的类型，其中最常见的是上下文无关文法（Context-Free Grammar，CFG）。上下文无关文法的产生式规则中，左侧只有一个非终结符号，右侧可以是任意符号串。在编译原理中，通常使用上下文无关文法来描述程序的语法结构。</p><p>通过定义文法，编译器可以根据语法规则进行语法分析，将源代码转换为抽象语法树（Abstract Syntax Tree，AST），从而为后续的语义分析、优化和代码生成阶段提供基础。文法在编译原理中扮演着非常重要的角色，是编译器设计和实现中的核心概念之一。</p><h3 id="编译原理中什么是语法">编译原理中什么是语法</h3><p>在编译原理中，语法（Syntax）指的是编程语言中规定了有效的代码结构和组织方式的规则集合。语法规定了哪些代码结构是合法的、如何组合各种元素以形成有效的程序，以及如何避免语法错误。</p><p>编程语言的语法通常由两个方面组成：</p><ol><li><p>词法结构（Lexical Structure）：词法结构定义了编程语言中的基本单元（tokens），如关键字、标识符、运算符等的组成规则。词法分析器负责将源代码分解为这些基本单元。</p></li><li><p>语法结构（Syntactic Structure）：语法结构定义了如何组合这些基本单元以及其他语法成分（如表达式、语句、函数定义等）来构建有效的程序。语法规则通常用文法来描述。</p></li></ol><p>在编译原理中，语法的正确性对于编译器的正常工作至关重要。编译器会根据编程语言的语法规则对源代码进行语法分析，以确保代码符合语法规范。如果源代码包含语法错误，编译器将无法正确解析代码结构，导致编译失败并生成错误信息。</p><p>总的来说，语法在编译原理中是描述编程语言结构和组织方式的规则集合，它是编译器理解和处理源代码的基础。通过定义清晰的语法规则，编程语言的设计者可以确保程序员编写的代码能够被编译器正确解析和执行。</p><h3 id="自上而下和自下而上方法：两种不同的构建语法分析树的思路">自上而下和自下而上方法：两种不同的构建语法分析树的思路</h3><p>自上而下方法是一种语法分析方法，它从起始符号开始，尝试将输入符号串推导为目标符号串。在自上而下方法中，有两种主要的分析技术：递归下降法和LL(1)分析法。</p><ol><li>递归下降法（Recursive Descent Parsing）：<br>递归下降法是一种简单且直观的自上而下语法分析方法。在递归下降法中，每个非终结符号对应一个分析函数，该函数尝试根据当前输入符号来选择正确的产生式进行推导。递归下降法的每个分析函数对应于文法中的一个非终结符号。</li></ol><p>递归下降法的主要特点包括：</p><ul><li>每个非终结符号对应一个分析函数。</li><li>分析函数中包含递归调用，用于处理非终结符号的展开。</li><li>根据当前输入符号选择正确的产生式进行推导。</li></ul><p>递归下降法的缺点是容易产生左递归和回溯（Backtracking）问题，需要谨慎设计文法以避免这些问题。</p><ol start="2"><li>LL(1) 分析法：<br>LL(1)分析法是一种预测分析方法，它在进行语法分析时预先查看输入符号串的若干个符号，并根据这些符号来选择正确的产生式。LL(1)表示从左到右扫描输入，同时从左到右建立推导，并使用一个符号向前看一个符号来做出决定。</li></ol><p>LL(1)分析法的特点包括：</p><ul><li>预测性：在分析时预测下一个要用到的产生式。</li><li>一次向前查看一个符号：根据当前输入符号和一个向前查看符号来做出决定。</li></ul><p>LL(1)文法是一种特殊类型的文法，满足以下条件：</p><ul><li>对于每个非终结符号和每个向前查看符号的组合，最多有一个产生式。</li><li>没有左递归。</li><li>没有公共前缀。</li></ul><p>LL(1)分析法通常用于构建递归下降分析器或表驱动分析器，是一种高效且常用的语法分析方法之一。</p><p>自下而上方法是另一种常见的语法分析方法，与自上而下方法相反，自下而上方法从输入符号串推导出起始符号。在自下而上方法中，LR分析器是最常见和广泛应用的一类分析器，包括LR(0)、LR(1)、SLR(1)和LALR(1)。</p><ol><li>LR(0) 分析法：<br>LR(0)分析法是一种自下而上的语法分析方法，其中的LR表示从左到右扫描输入，同时从右到左建立推导。LR(0)分析法使用零向前查看（lookahead）符号，即只查看当前输入符号来做出决策。</li></ol><p>LR(0)分析法的特点包括：</p><ul><li>使用 LR(0) 项集族（LR(0) item sets）来表示状态。</li><li>通过构建 LR(0) 项集族和 LR(0) 自动机来进行语法分析。</li><li>LR(0)文法是一种更强大的文法类别，可以处理更广泛的文法。</li></ul><ol start="2"><li>LR(1) 分析法：<br>LR(1)分析法是对LR(0)分析法的改进，它允许在做决策时查看一个符号的向前看。LR(1)分析法通过考虑一个符号的向前看来解决LR(0)分析法中的移入-规约冲突。</li></ol><p>LR(1)分析法的特点包括：</p><ul><li>使用 LR(1) 项集族来表示状态。</li><li>通过考虑一个符号的向前看来区分移入-规约冲突。</li><li>LR(1)文法比LR(0)文法更强大，能够处理更复杂的语法。</li></ul><ol start="3"><li>SLR(1) 分析法：<br>SLR(1)分析法是对LR(1)分析法的简化版本，它在构建分析表时使用了更弱的冲突解决策略，因此在某些情况下可能会导致冲突。</li></ol><p>SLR(1)分析法的特点包括：</p><ul><li>使用 SLR(1) 项集族来表示状态。</li><li>在构建分析表时采用了更弱的冲突解决策略。</li><li>SLR(1)文法相对于LR(1)文法来说更简单，但可能会导致更多的冲突。</li></ul><ol start="4"><li>LALR(1) 分析法：<br>LALR(1)分析法是对LR(1)分析法的进一步简化和合并，以减少状态数量和冲突。LALR(1)分析法通常比SLR(1)更强大，但比LR(1)更节省空间。</li></ol><p>LALR(1)分析法的特点包括：</p><ul><li>使用 LALR(1) 项集族来表示状态。</li><li>在合并LR(1)项集时，减少了状态数量和冲突。</li><li>LALR(1)文法相对于LR(1)文法来说更节省空间，但在某些情况下可能会牺牲一些分析能力。</li></ul><p>这些自下而上的分析方法在编译器设计中扮演着重要的角色，帮助编译器理解和分析源代码的结构，从而生成有效的目标代码。不同的方法在处理文法和冲突时有不同的优势和限制，设计者需要根据实际需求选择适合的分析方法。</p><h3 id="什么是语法制导翻译">什么是语法制导翻译</h3><p>语法制导翻译的基本思想在于为CFG中的文法符号设置语义属性，以表示其对应的语义信息。对于语义属性的计算，需要由语义规则来给出规定。</p><p>在制定与执行语义规则上，提出了语法制导定义（SDD）和语法制导翻译方案（SDT）。</p><h4 id="语法制导定义（SDD）">语法制导定义（SDD）</h4><p>SDD是对CFG的推广，将每个文法符和一个语义属性集合相关联。</p><p>将每个产生式和一组语义规则相关联，这些规则用于产生该产生式中各文法符号的属性值。</p><h4 id="语法制导翻译方案">语法制导翻译方案</h4><p>SDT是在产生式右部嵌入了程序片段的CFG，这 些程序片段被称为语义动作。</p><p>SDT可以看作是对SDD的一种补充，是SDD的具体实施方案；它明确指明语义规则的计算顺序，说明实现细节。</p><h3 id="编译过程是怎样的？">编译过程是怎样的？</h3><p>编译过程是将高级语言源代码转换为目标代码（通常是机器代码）的过程。编译器是执行编译过程的工具，通常包括以下阶段：</p><ol><li><p><strong>词法分析（Lexical Analysis）</strong>：</p><ul><li>词法分析器（Lexer）读取源代码字符流，并将其转换为标记（Token）序列。</li><li>标记是词法单元的抽象表示，如关键字、标识符、常量等。</li></ul></li><li><p><strong>语法分析（Syntax Analysis）</strong>：</p><ul><li>语法分析器（Parser）根据语法规则分析标记序列，构建抽象语法树（Abstract Syntax Tree，AST）。</li><li>AST表示源代码的结构，有助于后续阶段的处理。</li></ul></li><li><p><strong>语义分析（Semantic Analysis）</strong>：</p><ul><li>语义分析器检查语法树，确保代码符合语言的语义规则。</li><li>进行类型检查、作用域分析等，为后续阶段做准备。</li></ul></li><li><p><strong>中间代码生成（Intermediate Code Generation）</strong>：</p><ul><li>生成中间表示（Intermediate Representation，IR），可以是抽象的中间代码或类似汇编语言的表示形式。</li><li>中间代码简化了后续优化和目标代码生成的过程。</li></ul></li><li><p><strong>优化（Optimization）</strong>：</p><ul><li>对中间代码进行各种优化，包括减少代码大小、提高执行速度等。</li><li>优化可以包括常量折叠、死代码消除、循环优化等。</li></ul></li><li><p><strong>目标代码生成（Code Generation）</strong>：</p><ul><li>将优化后的中间代码转换为目标机器代码，通常是汇编代码或机器代码。</li><li>目标代码生成器根据目标机器的特性生成相应的代码。</li></ul></li><li><p><strong>目标代码优化（Target Code Optimization）</strong>：</p><ul><li>针对特定目标机器的代码优化，以提高代码执行效率。</li><li>包括寄存器分配、指令调度等。</li></ul></li><li><p><strong>链接（Linking）</strong>：</p><ul><li>如果程序由多个源文件组成，链接器将这些文件组合在一起，解析外部引用，生成最终可执行文件。</li></ul></li></ol><p>编译过程中的各个阶段相互关联，形成一个连续的流水线，确保源代码能够被正确地转换为可执行代码。每个阶段都有特定的任务和功能，共同完成编译过程。</p><h3 id="简述什么是符号表，符号表有什么作用">简述什么是符号表，符号表有什么作用</h3><p>符号表（Symbol Table）是编译器中用于存储程序中出现的标识符（如变量名、函数名等）及其相关信息的数据结构。符号表是编译器中重要的组成部分，用于跟踪和管理程序中的符号信息，以便在编译过程中进行语义分析、代码生成和优化等操作。</p><p>符号表通常包含以下信息：</p><ol><li><strong>标识符名称</strong>：如变量名、函数名等。</li><li><strong>数据类型</strong>：标识符的数据类型，如整数、浮点数、字符等。</li><li><strong>作用域信息</strong>：标识符所属的作用域，如全局作用域、局部作用域等。</li><li><strong>存储位置</strong>：标识符在内存中的存储位置或寄存器分配信息。</li><li><strong>是否已被定义</strong>：标识符是否已经在程序中被定义。</li><li><strong>其他属性</strong>：如常量值、数组维度等。</li></ol><p>符号表的作用包括但不限于以下几点：</p><ol><li><strong>语义分析</strong>：符号表用于检查程序中的标识符是否符合语义规则，如类型匹配、作用域规则等。</li><li><strong>代码生成</strong>：编译器在生成目标代码时需要访问符号表，以获取标识符的信息，如存储位置、数据类型等。</li><li><strong>优化</strong>：符号表中的信息可以帮助编译器进行优化操作，如常量传播、死代码消除等。</li><li><strong>错误检测</strong>：通过符号表，编译器可以检测未声明的标识符、重复定义等错误。</li><li><strong>作用域管理</strong>：符号表帮助编译器维护不同作用域中的标识符，确保作用域规则的正确性。</li></ol><p>总之，符号表在编译器中扮演着存储和管理程序中标识符信息的重要角色，为编译过程中的各个阶段提供必要的数据支持，确保编译器能够正确地分析、转换和优化源代码。</p><h3 id="讲讲编译原理的回填技术">讲讲编译原理的回填技术</h3><p>在编译原理中，回填技术是一种常见的技术，通常用于处理编译器中语法制导翻译中的属性计算和翻译动作。回填技术主要应用于自下而上的语法分析方法，如LR分析或语法制导的递归下降分析。</p><p>具体来说，回填技术涉及在语法分析过程中延迟生成代码或计算属性值，直到分析器能够确定如何处理这些信息。这种技术通常涉及两个步骤：</p><ol><li><p><strong>推迟动作</strong>：在语法分析过程中，当遇到需要进行某些动作的情况时，但由于当前上下文不足以立即执行这些动作，编译器会推迟执行这些动作，而是将它们标记为需要回填的位置。</p></li><li><p><strong>回填</strong>：在后续分析过程中，当分析器能够确定如何执行这些动作时，它会返回到之前标记的位置，并填充或执行相应的动作，以完成语法制导翻译的过程。</p></li></ol><p>回填技术的一个常见应用是在LR分析中，特别是LR语法分析器生成抽象语法树时。在LR分析中，当遇到归约动作时，可能需要在归约时计算某些属性值或生成代码，但由于LR分析器的先行性质，这些动作可能需要延迟执行。</p><p>通过回填技术，编译器可以在需要时灵活地处理属性计算和代码生成，避免在语法分析阶段过早地执行这些操作。这种技术使得编译器可以更高效地处理语法制导翻译，同时保持语法分析和语义处理的分离，使编译器的设计更加模块化和灵活。</p><h2 id="软件工程">软件工程</h2><h3 id="软件错误、缺陷、故障和失效">软件错误、缺陷、故障和失效</h3><ul><li><p>错误（Error）：在软件开发过程中的错误，停留在<strong>需求工作和编码过程</strong>中。</p><blockquote><p>例如：误解了需求，敲错了代码。</p></blockquote></li><li><p>缺陷（Fault）：存在于软件（文档、数据、程序）之中的那些<strong>不希望或不可接受的偏差</strong>。由于错误而引起的，存在于某些功能实现处的问题，属于<strong>功能实现</strong>层面。</p><blockquote><p>例如：对需求的误解导致的需求文档错误和与设计意图不相符的设计，敲错代码导致的错误的功能实现 （缺陷是错误的结果/表现）。</p></blockquote><blockquote><p>软件缺陷的主要特征：</p><ul><li>软件未达到软件产品需求说明书指明的要求。</li><li>软件出现了软件产品需求说明书中指明不应出现的错误。</li><li>软件功能超出软件产品说明书指明的范围。</li><li>软件未达到软件产品说明书未指明但应达到的要求。</li><li>软件测试人员认为难以理解、不易使用、运行速度慢或最终用户认为不好。</li></ul></blockquote></li><li><p>软件故障：在一个计算机程序中出现的不正确的步骤、过程或数据定义常称为故障。是指<strong>软件运行时丧失了在规定的限度内执行所需功能的能力，执行输出错误结果，导致失效</strong>。</p></li><li><p>软件失效：是指<strong>软件运行时产生的一种不希望或不可接受的外部行为</strong>，偏离了用户需求。</p></li></ul><h3 id="CMM">CMM</h3><p>CMM（Capability Maturity Model，能力成熟度模型）是一种用于评估和改进软件工程组织过程质量的方法。CMM定义了五个成熟度级别。</p><p>引入能力成熟度模型的主要目的包括：</p><ol><li><strong>评估和改进软件开发过程</strong>：CMM提供了一种评估组织软件开发过程能力的框架，帮助组织了解当前状态并识别改进的方向。</li><li><strong>指导最佳实践</strong>：CMM定义了与每个能力级别相关的最佳实践，为组织提供了一套可执行的指导方针，帮助组织提高软件开发过程的质量和效率。</li><li><strong>提高组织绩效</strong>：通过逐步提升软件开发过程的成熟度，组织可以提高项目交付的质量、减少成本和交付时间，增强组织的竞争力。</li><li><strong>建立标准化和可衡量性</strong>：CMM鼓励组织建立标准化的软件开发过程，并提供了一套可衡量的指标来评估过程的成熟度和改进效果。</li></ol><p>总的来说，引入能力成熟度模型可以帮助组织建立起可持续改进的文化，提高软件开发过程的可预测性、稳定性和质量，从而实现组织的长期成功和发展</p><h3 id="讲讲UML顺序图">讲讲UML顺序图</h3><p>UML顺序图（Sequence Diagram）是一种用于描述对象之间交互行为的图形化建模工具，常用于软件系统设计和分析阶段。顺序图显示了对象之间的交互顺序，展示了消息在对象之间的传递顺序和时间顺序。</p><p>以下是顺序图中常见的元素和符号：</p><ol><li><p><strong>参与者（Actor）</strong>：参与者代表系统的外部实体或角色，可以是人、其他系统或组织。通常以一个小图标代表，位于顺序图的顶部。</p></li><li><p><strong>对象（Object）</strong>：对象表示系统中的实际实例，具有特定的属性和行为。对象通常用矩形表示，包括对象名称。</p></li><li><p><strong>生命线（Lifeline）</strong>：生命线表示对象在一段时间内的存在或活动。生命线通常沿着垂直方向延伸，上面标有对象名称。</p></li><li><p><strong>消息（Message）</strong>：消息表示对象之间的通信或交互。消息可以是同步消息（实线箭头表示）或异步消息（虚线箭头表示），还可以是返回消息（带有带箭头的虚线）。</p></li><li><p><strong>激活（Activation）</strong>：激活表示对象执行操作或处理消息的时间段。激活通常用垂直的虚线框表示，显示对象的活动期间。</p></li><li><p><strong>片段（Fragment）</strong>：片段用于表示条件或循环结构，可以使用矩形框来包围一组消息，以表示这些消息在特定条件下或循环中发生。</p></li></ol><p>在顺序图中，对象按照时间顺序从左到右排列，消息从一个对象传递到另一个对象，显示了对象之间的交互关系和顺序。顺序图可以帮助软件开发人员更好地理解系统的行为和交互方式，有助于设计和分析系统的交互过程。</p><p>顺序图是UML中的一种重要建模工具，可以与其他类型的图（如用例图、类图、活动图等）结合使用，为软件系统的设计和实现提供指导和支持。</p><h3 id="集成测试">集成测试</h3><p>集成测试验证系统组件<strong>是否能正确的协同工作</strong>，选择策略要兼顾系统特性和客户需求。</p><ul><li>驱动模块：<strong>代替上级模块传递测试用例</strong>的程序（出现在<strong>自底而上</strong>集成测试中）。</li><li>桩模块：<strong>代替下级模块的仿真程序</strong>（出现在<strong>自顶向下</strong>）。</li></ul><p>集成测试的方法有四种：</p><ul><li><p><strong>自底向上的集成测试</strong>：从模块结构图的最底层开始，<strong>由下而上按调用关系逐步添加新模块</strong>，组成子系统分别测试，直到全部组装完毕。典型特征是：添加的新模块调用的下层模块都必须被全部测试完毕、 <strong>使用驱动模块</strong>。</p><blockquote><p>其优点在于：</p><ul><li>容易生成测试用例（因为底层都是真实模块）。</li><li>适合面向对象方法（每次加入的是经过测试的对象，也符合消息的传递方式）。</li><li>当许多低级组件经常在各个地方被调用时，这种方法十分适用</li></ul><p>缺点是许多存在于高层模块中的关键错误无法被及时发现。</p></blockquote></li><li><p><strong>自顶向下的集成测试</strong>：从顶层控制组件开始进行测试，然后<strong>逐步将调用的下级组件组合起来</strong>，再对更大的子系统测试，直到全部组装完毕；典型特征是：添加的新模块，调用它的上层模块必须被测试过、 使用桩模块。</p><blockquote><p>其优点在于上层的问题常常是影响更大的，自顶向下更利于发现这些关键问题。</p><p>缺点：</p><ul><li>生成测试用例更难。</li><li>可能需要很多桩。</li></ul></blockquote></li><li><p><strong>莽撞/一次性测试</strong>：先测试每一个模块，之后将所有模块一并集成。</p></li><li><p><strong>混合方式/三明治方式测试</strong>：从上到下将模块分为三层：上层、目标层、下层。上层自顶向下，下层自底向上，中层直接使用<strong>驱动模块+桩模块</strong>独立测试，最后集成三层，测试集中于目标层。</p></li></ul><h3 id="模块的内聚是什么，怎样才能做到高内聚？">模块的内聚是什么，怎样才能做到高内聚？</h3><p>模块的内聚是指模块内部各个元素（如函数、类、子程序等）彼此之间相关性的度量。高内聚表示模块内的元素彼此关联紧密，共同实现单一目标或功能。内聚度高通常被认为是软件设计中的一个良好属性，因为它有助于提高模块的可维护性、可重用性和可测试性。</p><p>为了实现高内聚，可以采取以下方法：</p><ol><li><p><strong>单一职责原则</strong>：确保每个模块只负责一个明确的功能或任务，避免功能交叉和耦合。</p></li><li><p><strong>模块化设计</strong>：将系统分解为独立的模块，每个模块负责特定的功能，降低模块之间的依赖性。</p></li><li><p><strong>合理的抽象</strong>：将相关的功能和数据进行合理的抽象和封装，提高模块的独立性和可重用性。</p></li><li><p><strong>清晰的接口</strong>：定义清晰简洁的接口，限制模块之间的交互，减少耦合度。</p></li><li><p><strong>代码复审</strong>：定期进行代码复审，识别模块内部的耦合问题，并进行优化和重构。</p></li></ol><p>通过遵循这些原则和方法，设计和实现高内聚的模块，可以提高软件系统的可维护性、可扩展性和可重用性，从而更好地满足软件开发的需求和要求。</p><h3 id="解释业务需求、用户需求、功能需求">解释业务需求、用户需求、功能需求</h3><p>在软件开发过程中，需求分析是一个至关重要的阶段，其中包括业务需求、用户需求和功能需求。这些需求类型之间存在一定的层次关系，下面对它们进行解释：</p><ol><li><p><strong>业务需求（Business Requirements）</strong>（Why）：</p><ul><li><strong>定义</strong>：业务需求描述了组织或企业需要解决的问题或实现的目标。这些需求通常从组织的角度出发，关注于解决业务问题、提高效率、降低成本或实现战略目标。</li><li><strong>特点</strong>：业务需求通常不涉及具体的技术实现细节，而更侧重于业务流程、组织结构、市场需求等方面。</li><li><strong>例子</strong>：提高客户满意度、优化供应链管理、增加销售额等。</li></ul></li><li><p><strong>用户需求（User Requirements）</strong>（What）：</p><ul><li><strong>定义</strong>：用户需求描述了最终用户希望软件系统具备的功能和特性，以解决其实际问题或满足需求。</li><li><strong>特点</strong>：用户需求通常从最终用户的角度出发，关注于用户体验、易用性、功能需求等方面。</li><li><strong>例子</strong>：用户希望能够轻松浏览产品信息、方便地下订单、快速查找所需信息等。</li></ul></li><li><p><strong>功能需求（Functional Requirements）</strong>（How）：</p><ul><li><strong>定义</strong>：功能需求描述了系统应该具备的具体功能、行为和操作，以满足业务需求和用户需求。</li><li><strong>特点</strong>：功能需求是对系统功能性的详细描述，包括输入、输出、处理逻辑、数据存储等方面。</li><li><strong>例子</strong>：用户登录、添加商品到购物车、生成报告、发送邮件通知等。</li></ul></li></ol><p>在软件开发过程中，这三种需求类型之间通常存在一种逐步细化的关系。业务需求是最高层次的需求，用户需求在业务需求的基础上进一步细化，而功能需求则是在用户需求的基础上具体描述系统应该实现的功能。通过逐步细化需求，开发团队可以更好地理解并满足用户和业务的实际需求，从而设计和开发出符合预期的软件系统。</p><h3 id="面向对象软件工程有哪些特点？">面向对象软件工程有哪些特点？</h3><p>面向对象软件工程是一种常用的软件开发方法，具有许多特点和优势。以下是面向对象软件工程的一些主要特点：</p><ol><li><p><strong>封装（Encapsulation）</strong>：封装是将数据和操作（方法）封装在一个对象内部，隐藏对象的内部实现细节，只暴露必要的接口给外部使用。这有助于提高安全性、减少耦合度和简化复杂性。</p></li><li><p><strong>继承（Inheritance）</strong>：继承允许一个对象（子类）基于另一个对象（父类）的属性和行为来定义自己的属性和行为。通过继承，可以实现代码重用、扩展和层次化设计。</p></li><li><p><strong>多态（Polymorphism）</strong>：多态性允许不同对象对同一消息做出不同的响应。通过多态，可以实现方法重载、方法重写和接口多态，提高代码的灵活性和可扩展性。</p></li><li><p><strong>抽象（Abstraction）</strong>：抽象是将对象的共同特征提取出来形成抽象类或接口，隐藏对象的具体实现细节，使得代码更易于理解和维护。</p></li><li><p><strong>类和对象</strong>：面向对象软件工程基于类和对象的概念，通过类定义对象的属性和行为，实例化对象进行操作和交互。</p></li><li><p><strong>消息通信</strong>：面向对象系统中的对象通过消息传递进行通信，对象之间通过调用方法来交互和共享信息。</p></li><li><p><strong>灵活性和可维护性</strong>：面向对象软件工程提供了更灵活、可扩展和易维护的代码结构，使得软件系统更容易适应变化和需求的变更。</p></li><li><p><strong>模块化设计</strong>：面向对象方法倡导将系统分解为独立的模块（类），每个模块负责特定的功能，降低模块之间的依赖性，提高系统的可重用性和可测试性。</p></li><li><p><strong>面向对象分析、设计和编程</strong>：面向对象软件工程强调从问题领域的对象和关系出发进行分析和设计，然后通过面向对象编程语言实现系统。</p></li></ol><p>这些特点使得面向对象软件工程在实际开发中具有广泛的应用，能够提高软件的质量、可维护性和可重用性，同时也有助于团队协作和项目管理。</p><h3 id="配置管理系统中基线的作用">配置管理系统中基线的作用</h3><p>在配置管理系统中，基线（Baseline）是一个非常重要的概念，它在软件开发过程中扮演着关键的角色。基线的作用包括但不限于以下几点：</p><ol><li><p><strong>版本控制</strong>：基线用于标记特定时间点或阶段的软件配置状态，类似于一个快照。通过创建基线，可以记录软件的特定版本，使得在将来可以方便地回溯、比较和恢复到特定的软件状态。</p></li><li><p><strong>变更管理</strong>：基线用于跟踪软件的变更历史。一旦创建了基线，任何对软件配置的修改都可以与基线进行比较，从而帮助开发团队了解变更的影响和历史。</p></li><li><p><strong>质量控制</strong>：基线可以作为质量控制的参考点。通过在关键阶段创建基线，可以确保软件在特定时间点的质量和功能符合预期，并且有助于评估软件开发过程中的进展和质量。</p></li><li><p><strong>配置管理</strong>：基线是配置管理的基础。通过定义和管理基线，可以确保软件的配置在不同环境和阶段之间保持一致，有助于团队协作和软件交付的可靠性。</p></li><li><p><strong>审计和验证</strong>：基线可以用于审计和验证软件的配置状态。在软件交付或验收阶段，基线可以作为参考点，帮助验证软件是否符合要求和规范。</p></li></ol><p>总的来说，基线在配置管理系统中扮演着重要的角色，它不仅是记录软件配置状态的标记，还是软件开发过程中管理、控制和验证的重要工具，有助于确保软件的质量、可靠性和可维护性。</p><h2 id="数据结构">数据结构</h2><h3 id="最小生成树">最小生成树</h3><p>Prim算法和Kruskal算法都是用于解决最小生成树（Minimum Spanning Tree）问题的经典算法，它们的目标是找到连接图中所有顶点的最小权重边集合。</p><h4 id="Prim算法：">Prim算法：</h4><ol><li><strong>工作原理</strong>：Prim算法是一种贪心算法，从一个初始顶点开始，逐步扩展最小生成树，每次选择与当前最小生成树连接的权重最小的边所连接的顶点加入最小生成树中，直到所有顶点都被包含在最小生成树中为止。</li><li><strong>步骤</strong>：<ul><li>选择一个起始顶点作为初始最小生成树。</li><li>将与最小生成树相邻且权重最小的边加入最小生成树。</li><li>重复上述步骤，直到所有顶点都被包含在最小生成树中。</li></ul></li><li><strong>复杂度</strong>：Prim算法的时间复杂度为O(V^2)或O(E + V log V)，取决于使用邻接矩阵还是邻接表来表示图。</li></ol><h4 id="Kruskal算法：">Kruskal算法：</h4><ol><li><strong>工作原理</strong>：Kruskal算法也是一种贪心算法，它通过按照边的权重递增的顺序选择边，并确保选择的边不会形成环路，直到生成树中包含了所有的顶点。</li><li><strong>步骤</strong>：<ul><li>将所有边按照权重排序。</li><li>从权重最小的边开始，如果加入该边不会形成环路，则将其加入最小生成树。</li><li>重复上述步骤，直到最小生成树包含了所有的顶点。</li></ul></li><li><strong>复杂度</strong>：Kruskal算法的时间复杂度为O(E log E)，其中E为边的数量。它通常适用于稀疏图，因为它的时间复杂度与边的数量相关。</li></ol><h4 id="区别：">区别：</h4><ul><li><strong>Prim算法</strong>是从一个顶点开始，逐步扩展生成树，直到包含所有顶点；而<strong>Kruskal算法</strong>是按照边的权重递增的顺序选择边，直到生成树包含所有的顶点。</li><li>Prim算法更适用于稠密图，而Kruskal算法更适用于稀疏图。</li><li>Prim算法通常使用邻接矩阵实现，而Kruskal算法通常使用并查集来判断是否形成环路。</li></ul><p>这两种算法都是解决最小生成树问题的有效方法，选择哪种算法取决于具体的图的特性以及实现的需求。</p><h3 id="迪杰斯特拉算法和Floyd算法">迪杰斯特拉算法和Floyd算法</h3><p>迪杰斯特拉算法（Dijkstra Algorithm）和Floyd算法（Floyd-Warshall Algorithm）都是用于解决图论中的最短路径问题的经典算法，但它们的应用场景和实现方式有所不同。</p><h4 id="迪杰斯特拉算法：">迪杰斯特拉算法：</h4><ol><li><strong>工作原理</strong>：迪杰斯特拉算法是一种单源最短路径算法，用于找到图中从一个起始顶点到其他所有顶点的最短路径。</li><li><strong>步骤</strong>：<ul><li>初始化起始顶点到自身的距离为0，其他顶点到起始顶点的距离为无穷大。</li><li>从未标记的顶点中选择距离起始顶点最近的顶点，标记该顶点并更新与其相邻的顶点的距禷。</li><li>重复上述步骤，直到所有顶点都被标记。</li></ul></li><li><strong>复杂度</strong>：迪杰斯特拉算法的时间复杂度为O(V^2)或O(E log V)，取决于使用邻接矩阵还是邻接表来表示图。</li></ol><h4 id="Floyd算法：">Floyd算法：</h4><ol><li><strong>工作原理</strong>：Floyd算法是一种多源最短路径算法，用于计算图中任意两个顶点之间的最短路径。</li><li><strong>步骤</strong>：<ul><li>初始化一个二维数组来存储任意两个顶点之间的最短路径长度。</li><li>通过动态规划的方式逐步更新最短路径长度，直到得到所有顶点对之间的最短路径长度。</li></ul></li><li><strong>复杂度</strong>：Floyd算法的时间复杂度为O(V^3)，其中V为顶点的数量。</li></ol><h4 id="区别：-2">区别：</h4><ul><li><strong>迪杰斯特拉算法</strong>适用于单源最短路径问题，适合用于稀疏图；<strong>Floyd算法</strong>适用于多源最短路径问题，适合用于稠密图。</li><li>迪杰斯特拉算法使用贪心策略，每次选择距离起始顶点最近的未标记顶点来更新距离；而Floyd算法通过动态规划的方式逐步更新最短路径长度。</li><li>迪杰斯特拉算法通常用于计算单源最短路径，适合于网络路由等应用；而Floyd算法用于计算任意两个顶点之间的最短路径，适合于需要计算所有顶点对之间最短路径的情况。</li></ul><p>这两种算法在解决最短路径问题时有着不同的特点和适用场景，选择合适的算法取决于具体的需求和图的特性。</p><h3 id="索引查找、-B＋树查找、折半查找，-这三种方法有啥不同？">索引查找、 B＋树查找、折半查找， 这三种方法有啥不同？</h3><p>索引查找、B+树查找和折半查找是常见的查找算法或数据结构，它们在不同的场景下有着不同的特点和应用。</p><h4 id="折半查找（Binary-Search）：">折半查找（Binary Search）：</h4><ol><li><p><strong>工作原理</strong>：折半查找是一种基于有序数组的查找算法，通过比较中间元素与目标值的大小关系，缩小查找范围直到找到目标值或确定目标值不存在。</p></li><li><p><strong>特点</strong>：</p><ul><li>适用于有序数组。</li><li>时间复杂度为O(log n)。</li><li>简单高效，但要求数据有序。</li></ul></li></ol><h4 id="索引查找（Index-Search）：">索引查找（Index Search）：</h4><ol><li><p><strong>工作原理</strong>：索引查找是一种通过索引结构来加速查找的方法，索引结构通常包含关键字和对应记录的指针。</p></li><li><p><strong>特点</strong>：</p><ul><li>通过索引结构快速定位记录。</li><li>适用于大型数据集。</li><li>可以减少查找时间，但需要额外的空间存储索引。</li></ul></li></ol><h4 id="B-树查找（B-Tree-Search）：">B+树查找（B+ Tree Search）：</h4><ol><li><p><strong>工作原理</strong>：B+树是一种平衡树结构，常用于数据库索引中，其内部节点仅存储索引，叶子节点存储实际数据。</p></li><li><p><strong>特点</strong>：</p><ul><li>适用于磁盘存储，减少磁盘I/O次数。</li><li>高效支持范围查询和范围删除操作。</li><li>时间复杂度为O(log n)。</li></ul></li></ol><h4 id="区别：-3">区别：</h4><ul><li><p><strong>折半查找</strong>适用于有序数组，时间复杂度为O(log n)；<strong>索引查找</strong>通过索引结构加速查找，适用于大型数据集；<strong>B+树查找</strong>适用于磁盘存储，减少磁盘I/O次数，并支持范围查询。</p></li><li><p><strong>折半查找</strong>是一种基本的查找算法，适用于内存中的有序数组；<strong>索引查找</strong>和<strong>B+树查找</strong>更适用于大型数据集或数据库中的查找操作，通过索引结构或树结构实现快速查找。</p></li><li><p><strong>索引查找</strong>和<strong>B+树查找</strong>都是通过额外的数据结构来提高查找效率，而<strong>折半查找</strong>则是直接在有序数组上进行查找。</p></li></ul><p>根据具体的应用场景和数据特性，选择合适的查找方法可以提高查找效率和性能。</p><h3 id="什么是尾递归">什么是尾递归</h3><p>尾递归（Tail Recursion）是指一个递归函数的最后一个操作是对自身的递归调用。具体来说，尾递归发生在函数的最后一步操作中，递归调用是当前函数返回值的一部分。</p><p>尾递归和非尾递归的区别在于递归调用的位置。在非尾递归中，递归调用之后还有一些操作需要执行，而在尾递归中，递归调用是函数的最后一步操作。</p><p>尾递归在某些编程语言中具有优化的潜力，称为尾递归优化。尾递归优化可以将尾递归转化为迭代形式，避免在每次递归调用时都需要保留调用前的状态，从而节省内存空间。这种优化可以有效地避免栈溢出的问题，特别是在需要多次递归调用的情况下。</p><p>尾递归优化的关键在于编译器或解释器能够识别尾递归，并将其转换为迭代形式。一些编程语言（如Scheme）对尾递归有着内建的优化支持，而其他语言（如Java）可能需要开发者手动设计尾递归优化的算法。</p><p>总之，尾递归是指递归函数中递归调用出现在函数的最后一步操作中的情况，尾递归优化可以提高程序的性能并避免栈溢出的问题。</p><h3 id="为什么B＋树分支不放数据">为什么B＋树分支不放数据</h3><p>B+树是一种常用的平衡树数据结构，通常用于数据库索引的实现。B+树的特点是内部节点不存储数据，只存储键值信息，而所有的数据都存储在叶子节点上。这种设计有以下几个优点：</p><ol><li><p><strong>提高检索性能</strong>：由于内部节点只存储键值信息，而数据都存储在叶子节点上，这样可以使得一次检索就能够找到对应的数据，减少了检索的时间。</p></li><li><p><strong>提高磁盘IO效率</strong>：在数据库系统中，通常数据量很大，无法完全存放在内存中，需要存储在磁盘上。B+树的设计使得在进行范围查询时，可以更快地定位到叶子节点，从而减少磁盘IO次数。</p></li><li><p><strong>有利于范围查询</strong>：B+树的叶子节点之间通过指针连接成链表，可以方便地进行范围查询，只需要遍历叶子节点链表即可。</p></li><li><p><strong>有利于顺序访问</strong>：由于叶子节点之间有指针连接，数据在磁盘上是顺序存储的，这有利于顺序访问。</p></li><li><p><strong>减少内存占用</strong>：内部节点只存储键值信息，不存储数据，这样可以减少内存占用，使得每个节点能够包含更多的键值信息，减少树的高度，提高检索效率。</p></li></ol><p>因此，B+树的设计使得它更适合用于数据库索引，能够提高检索性能、磁盘IO效率，适合范围查询和顺序访问，并且节省内存空间。这些优点使得B+树成为数据库系统中常用的索引结构。</p><h3 id="散列函数构造的方法有哪些？">散列函数构造的方法有哪些？</h3><p>散列函数是将不固定长度的输入数据转换为固定长度的输出数据的函数，通常用于散列表（Hash Table）等数据结构中。构造一个好的散列函数是非常重要的，因为它直接影响到散列表的性能。以下是一些常见的散列函数构造方法：</p><ol><li><p><strong>直接寻址法（Direct Addressing）</strong>：直接使用关键字作为散列地址。适用于关键字的取值范围较小的情况。</p></li><li><p><strong>除留余数法（Division Method）</strong>：将关键字 k 除以一个不大于散列表大小 m 的数 p，然后取余数作为散列地址。通常选择一个质数作为 p，可以减少冲突。</p></li><li><p><strong>乘法散列法（Multiplicative Hashing）</strong>：将关键字 k 乘以一个常数 A（0 &lt; A &lt; 1），然后取结果的小数部分再乘以 m，最后取整数部分作为散列地址。</p></li><li><p><strong>全域散列法（Universal Hashing）</strong>：根据随机选择的一组散列函数中的一个来计算散列地址，可以在运行时选择一个散列函数，以减少冲突的可能性。</p></li><li><p><strong>折叠法（Folding Method）</strong>：将关键字分割成若干部分，然后将这些部分相加，再取模得到散列地址。</p></li><li><p><strong>平方取中法（Mid-Square Method）</strong>：将关键字的平方进行位数截取，再取模得到散列地址。</p></li><li><p><strong>位运算法（Bit Manipulation）</strong>：通过位运算操作（如位与、位或、位异或等）对关键字进行处理，得到散列地址。</p></li><li><p><strong>分离链接法（Separate Chaining）</strong>：将冲突的元素存储在同一个链表中，散列表中的每个槽都指向一个链表。</p></li><li><p><strong>开放定址法（Open Addressing）</strong>：当发生冲突时，通过一定的探测序列找到下一个可用的槽位存放冲突的元素。</p></li></ol><p>这些是常见的散列函数构造方法，选择合适的散列函数取决于具体的应用场景和数据特点。在设计散列函数时，需要考虑尽量减少冲突，同时保证散列函数的计算效率和均匀性。</p><h3 id="函数指针，整型指针，数组指针的大小关系，为什么？">函数指针，整型指针，数组指针的大小关系，为什么？</h3><p>在大多数现代计算机系统中，不同类型的指针（如函数指针、整型指针、数组指针）在内存中通常占据相同的大小，这是因为指针的大小取决于计算机的体系结构和操作系统的设计。在下面的讨论中，我们将假设使用的是一个典型的32位操作系统。</p><ol><li><p><strong>函数指针</strong>：函数指针用于存储函数的地址。在大多数32位系统中，函数指针的大小为4个字节（32位），因为函数的地址通常可以用一个32位的地址来表示。</p></li><li><p><strong>整型指针</strong>：整型指针用于存储整数型变量的地址。同样在大多数32位系统中，整型指针的大小也为4个字节，因为它们需要存储与函数指针相同的地址长度。</p></li><li><p><strong>数组指针</strong>：数组指针指向数组的首地址。对于数组指针，其大小也是4个字节，因为它们存储的是数组的起始地址，与函数指针和整型指针相同。</p></li></ol><p>总结起来，函数指针、整型指针和数组指针在大多数情况下在内存中占据相同的大小，即4个字节（32位系统）。这是因为在32位系统中，地址总线的宽度为32位，因此指针的大小也通常为32位，以便能够准确地表示内存中的地址范围。</p><p>需要注意的是，在64位系统中，这些指针的大小通常会是8个字节（64位），因为64位系统的地址总线宽度为64位，需要更多的位数来表示更大的地址范围。因此，在不同的系统架构下，指针的大小可能会有所不同。</p><h2 id="操作系统">操作系统</h2><h3 id="操作系统的特征">操作系统的特征</h3><ul><li><p>并发：两个或多个事件在同一间隔内发生。</p><blockquote><p>注意并发和并行的区别。</p></blockquote></li><li><p>共享：资源共享即共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。资源共享有两种方式：</p><ul><li><p>互斥共享</p><blockquote><p>被互斥共享的资源称为临界资源。</p></blockquote></li><li><p>同时访问</p></li></ul></li><li><p>虚拟：操作系统运用多种虚拟化技术实现虚拟处理器、虚拟内存和虚拟外部设备等。操作系统的虚拟化技术可分类为：<strong>时分复用技术和空分复用技术</strong>。</p></li><li><p>异步</p></li></ul><h3 id="虚拟存储器特征">虚拟存储器特征</h3><ol><li><strong>多次性</strong>。是指无须在作业运行时一次性地全部装入内存，而允许被分成多次调入内存运行，即只需将当前要运行的那部分程序和数据装入内存即可开始运行。以后每当要运行到尚未调入的那部分程序时，再将它调入。多次性是虚拟存储器最重要的特征。</li><li><strong>对换性</strong>。是指无须在作业运行时一直常驻内存，在进程运行期间，允许将那些哲不使用的程序和数据从内存调至外存的对换区（换出），待以后需要时再将它们从外存调至内存 (换进）。正是由于对换性，才使得虚拟存储器得以正常运行。</li><li><strong>虛拟性</strong>。是指从逻辑上扩充内存的容量，使用户所看到的内存容量远大于实际的内存容量。这是虛拟存储器所表现出的最重要特征，也是实现虛拟存储器的最重要目标。</li></ol><h3 id="请求分页管理方式">请求分页管理方式</h3><p><strong>请求分页系统</strong>建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了<strong>请求调页功能</strong>和<strong>页面置换功</strong>能。请求分页是目前最常用的一种实现虛拟存储器的方法。</p><p>在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存中时，再通过调页功能将其调入，同时还可通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。为了实现请求分页，系统必须提供一定的硬件支持。除了需要一定容量的内存及外存的计算机系统，还需要有页表机制、缺页中断机构和地址机构。</p><p>请求分页机制下必须面临<strong>如何发现和处理页面不在内存中</strong>的情况，这需要向页表项中添加四个字段：</p><p><img src="https://s2.loli.net/2023/06/21/HDfVzKqkyXRwtUP.png" alt="请求分页系统中的页表项"></p><ul><li><strong>状态位P</strong>：用于指示该页是否己调入内存，供程序访问时参考。</li><li>访问字段A：用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时问未被访问，供置换算法换出页面时参考。</li><li><strong>修改位M</strong>：标识该页在调入内存后是否被修改过，以确定页面置换时是否写回外存。</li><li>外存地址：用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</li></ul><p>在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个<strong>缺页中断</strong>，请求操作系统将所缺的页调入内存。缺页中断作为中断，同样要经历诸如保护 CPU 环境、分析中断原因、转入缺页中断处理程序、恢复 CPU 环境等几个步骤。但与一般的中断相比，它<strong>有以下两个明显的区别</strong>：</p><ul><li>在<strong>指令执行期间而非一条指令执行完后产生和处理中断信号</strong>，属于内部异常。</li><li>一条指令在执行期间，<strong>可能产生多次缺页中断</strong>。</li></ul><h3 id="页框分配">页框分配</h3><p>操作系统必须决定读取多少页也就是给进程分配几个页框，一个进程分配的物理页框的集合就是这个进程的<strong>驻留集</strong>。需要考虑以下几点：</p><ul><li>分配给<strong>一个进程的页框越少，驻留在主存中的进程就越多</strong>，从而可提高 CPU 的利用率。</li><li>若<strong>一个进程在主存中的页面过少，则尽管有局部性原理，缺页率仍相对较高</strong>。</li><li>若分配的页框过多，则由于局部性原理，对该进程的缺页率没有太明显的影响。</li></ul><p>请求分页系统有<strong>固定分配</strong>和<strong>可变分配</strong>两种内存分配策略，置换时有<strong>全局置换</strong>和<strong>局部置换</strong>两种策略，因此能<strong>组合出三种策略</strong>：</p><ul><li><strong>固定分配局部置换</strong>：为<strong>每个进程分配一定数目的物理块，在进程运行期问都不改变</strong>。所谓局部置换，是指如果<strong>进程在运行中发生缺页，则只能从分配给该进程在内存的页面中选出一页换出，然后再调入一页</strong>， 以保证分配给该进程的内存空间不变。实现这种策略时，难以确定应为每个进程分配的物理块数目：太少会频繁出现缺页中断，太多又会降低CPU和其他资源的利用率。</li><li><strong>可变分配全局置换</strong>：先<strong>为每个进程分配一定数目的物理块，在进程运行期间可根据情况适当地增加或减少</strong>。所谓全局置换，是指如果<strong>进程在运行中发生缺页，系统从空闲物理块队列中取出一块分配给该进程， 并将所缺页调入</strong>。这种方法比固定分配局部置换更加灵活，可以动态增加进程的物理块，但也存在弊端，如它会盲目地给进程增加物理块，从而导致系统多道程序的并发能力下降。</li><li><strong>可变分配局部置换</strong>：为每个进程分配一定数目的物埋块，当<strong>某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，因此不会影响其他进程的运行</strong>。若进程在运行中<strong>频繁地发生缺页中断，则系统再为该进程分配若干物理块，直至该进程的缺页率趋于适当程度：反之，若进程在运行中的缺页率特别低，则可适当减少分配给该进程的物理块</strong>，但不能引(起其缺页率的明显增加。这种方法在保证进程不会过多地调页的同时，也保持了系统的多道程序并发能力。当然它需要更复杂的实现，也需要更大的开销，但对比频繁地换入/换出所浪费的计算机资源，这种牲是值得的。</li></ul><h3 id="操作系统什么是虚拟内存">操作系统什么是虚拟内存</h3><p>虚拟内存是一种计算机操作系统的技术，它允许将磁盘空间用作RAM（随机存取存储器）的扩展，从而扩大了计算机系统可用的内存空间。虚拟内存的基本思想是将物理内存和磁盘空间结合起来，使得操作系统能够更有效地管理内存并为运行的程序提供一个连续的内存地址空间。</p><p>当程序运行时，操作系统会将程序需要的部分加载到物理内存中，而不是一次性将整个程序加载进内存。如果物理内存不足以容纳所有需要的程序和数据，操作系统会将暂时不需要的部分存储到磁盘上，然后在需要时再将其调入内存。这样，操作系统就可以为每个程序提供一个连续的地址空间，而程序本身可能并没有实际使用连续的物理内存空间。</p><p>通过虚拟内存技术，操作系统可以更灵活地管理内存资源，允许多个程序同时运行，并为每个程序提供独立的内存空间，从而提高了系统的稳定性和性能。</p><h3 id="设备驱动作用是什么？">设备驱动作用是什么？</h3><p>设备驱动程序是一种软件，它充当计算机操作系统和硬件设备之间的桥梁，使操作系统能够与硬件设备进行通信和控制。设备驱动程序的作用包括以下几个方面：</p><ol><li><p><strong>硬件控制</strong>：设备驱动程序负责控制硬件设备的操作，包括发送命令、接收数据、处理中断等。它们与硬件设备之间的交互是通过设备的接口和控制器实现的。</p></li><li><p><strong>资源管理</strong>：设备驱动程序管理硬件设备所需的资源，如内存空间、中断请求等。它们协调不同设备之间的资源分配，以确保系统中的各个设备能够有效地共享资源。</p></li><li><p><strong>提供接口</strong>：设备驱动程序为操作系统提供了统一的接口，使操作系统能够通过标准的命令和数据格式与各种设备进行通信。这样，应用程序可以通过操作系统的接口访问硬件设备，而不需要直接与硬件通信。</p></li><li><p><strong>错误处理</strong>：设备驱动程序负责处理硬件设备可能出现的错误和异常情况。它们监视设备的状态，并在发生故障或错误时采取适当的措施，如重新初始化设备或向操作系统报告错误信息。</p></li></ol><p>总之，设备驱动程序在计算机系统中起着至关重要的作用，它们使操作系统能够有效地管理和控制硬件设备，为应用程序提供访问硬件设备的接口，从而实现计算机系统中软件和硬件之间的有效交互。</p><h3 id="物理地址和逻辑地址的区别">物理地址和逻辑地址的区别</h3><p>物理地址和逻辑地址是计算机系统中两种不同类型的地址，用于在内存中定位数据或指令。它们之间的区别在于以下几个方面：</p><ol><li><p><strong>物理地址</strong>：</p><ul><li>物理地址是指在计算机系统中实际的硬件内存地址，用于标识内存中存储单元的位置。</li><li>物理地址是由内存管理单元（MMU）翻译的最终地址，用于在内存中准确定位数据或指令。</li><li>物理地址是实际存在于计算机系统中的地址，是硬件直接访问内存的地址。</li></ul></li><li><p><strong>逻辑地址</strong>：</p><ul><li>逻辑地址是指由程序生成的地址，用于在程序中访问内存中的数据或指令。</li><li>逻辑地址是相对于程序的起始地址的偏移量，程序员或编译器在编程时使用逻辑地址来访问内存。</li><li>逻辑地址是在程序执行时使用的虚拟地址，需要通过内存管理单元（MMU）转换为物理地址才能访问实际的内存位置。</li></ul></li><li><p><strong>转换关系</strong>：</p><ul><li>当程序使用逻辑地址访问内存时，内存管理单元（MMU）会将逻辑地址转换为对应的物理地址，以便访问实际的内存单元。</li><li>逻辑地址和物理地址之间的转换是通过内存管理单元（MMU）中的地址映射机制完成的，包括分页机制和分段机制等。</li></ul></li></ol><p>总的来说，逻辑地址是程序员或编译器看到的地址，而物理地址是实际存在于硬件中的地址。操作系统通过内存管理单元（MMU）来管理逻辑地址和物理地址之间的映射关系，实现程序的正确执行和数据的准确访问。</p><h2 id="计网">计网</h2><h3 id="从浏览器中输入信息到这个信息被我们看到，-这都用到了计算机网络中的哪些层">从浏览器中输入信息到这个信息被我们看到， 这都用到了计算机网络中的哪些层</h3><p>从浏览器输入信息到最终被我们看到，涉及到计算机网络中的多个层。这个过程主要涉及到OSI（Open Systems Interconnection）模型或TCP/IP模型中的不同层次。以下是一个简要的描述：</p><ol><li><p><strong>应用层（Application Layer）</strong>：用户在浏览器中输入信息，这些信息首先由应用层处理。这里涉及到诸如HTTP（超文本传输协议）、HTTPS（安全超文本传输协议）、SMTP（简单邮件传输协议）等协议。</p></li><li><p><strong>传输层（Transport Layer）</strong>：信息被传输到传输层，这里负责数据的分段、传输控制等。主要协议有TCP（传输控制协议）和UDP（用户数据报协议）。</p></li><li><p><strong>网络层（Network Layer）</strong>：在网络层，数据被打包成数据包，添加了IP地址等信息，以便在网络中传输。IP协议就是在这一层起作用的。</p></li><li><p><strong>数据链路层（Data Link Layer）</strong>：在数据链路层，数据包被转换为比特流，这些比特通过物理介质传输。以太网协议是在这一层起作用的一个例子。</p></li><li><p><strong>物理层（Physical Layer）</strong>：最后一层是物理层，负责数据在网络中的传输。这包括电缆、光纤、无线信号等传输媒介。</p></li></ol><p>综上所述，从浏览器输入信息到最终被我们看到，涉及到了应用层、传输层、网络层、数据链路层和物理层这些计算机网络中的不同层次。</p><h3 id="OSPF和BGP">OSPF和BGP</h3><p>OSPF（Open Shortest Path First）和BGP（Border Gateway Protocol）是两种不同类型的路由协议，常用于不同规模和用途的网络中。以下是关于OSPF和BGP的一些解释和比较：</p><p><strong>OSPF（Open Shortest Path First）：</strong></p><ol><li><p><strong>类型</strong>：OSPF是一种内部网关协议（IGP），用于在单一自治系统（AS）内部进行路由选择和路径计算。</p></li><li><p><strong>作用范围</strong>：OSPF通常用于大型企业网络或互联网服务提供商网络中。它适用于需要快速收敛、支持分层设计和具有复杂拓扑结构的网络环境。</p></li><li><p><strong>路由计算</strong>：OSPF使用链路状态信息来计算最短路径，并通过交换链路状态更新来维护路由表。</p></li><li><p><strong>区域设计</strong>：OSPF采用区域设计，将网络划分为不同的区域，每个区域有自己的链路状态数据库，有助于提高网络的可扩展性和管理性。</p></li></ol><p><strong>BGP（Border Gateway Protocol）：</strong></p><ol><li><p><strong>类型</strong>：BGP是一种外部网关协议（EGP），用于在不同自治系统之间进行路由选择和互联。</p></li><li><p><strong>作用范围</strong>：BGP通常用于连接不同的自治系统，例如互联网服务提供商之间或大型企业与互联网之间的边界路由器之间。</p></li><li><p><strong>路径矢量协议</strong>：BGP是一种路径矢量协议，它基于路径向量来选择最佳路径，并支持策略路由，允许管理员根据需要调整路由选择。</p></li><li><p><strong>自治系统之间路由</strong>：BGP用于交换不同自治系统之间的路由信息，维护全球互联网的路由表。</p></li></ol><p><strong>比较：</strong></p><ol><li><p><strong>作用范围</strong>：OSPF主要用于单一自治系统内部的路由选择，而BGP用于不同自治系统之间的路由选择。</p></li><li><p><strong>路由计算</strong>：OSPF是基于链路状态的协议，而BGP是基于路径矢量的协议。</p></li><li><p><strong>灵活性</strong>：BGP更灵活，允许管理员定义路由策略和控制路由传播的细节，而OSPF更适用于内部网络的快速收敛和路径计算。</p></li></ol><p>综上所述，OSPF和BGP是两种不同类型的路由协议，各自适用于不同的网络环境和需求。 OSPF用于内部网络中的路由选择，而BGP用于自治系统之间的路由选择和互联。</p><h3 id="交换机、-网桥和-HUB-的区别">交换机、 网桥和 HUB 的区别</h3><p>交换机（Switch）、网桥（Bridge）和集线器（Hub）是网络中常见的设备，它们在网络中起着不同的作用。以下是它们之间的区别：</p><ol><li><p><strong>集线器（Hub）</strong>：</p><ul><li><strong>功能</strong>：集线器是一个物理层设备，用于将多个网络设备连接在一起形成局域网（LAN）。它会接收来自一个端口的数据，并将数据广播到所有其他端口。</li><li><strong>工作方式</strong>：集线器不具备智能，无法识别数据包的目的地址，因此会将数据包广播到所有端口，可能导致网络拥堵和冲突。</li><li><strong>碰撞域</strong>：所有连接到集线器的设备属于同一个碰撞域，因此碰撞可能会发生。</li></ul></li><li><p><strong>网桥（Bridge）</strong>：</p><ul><li><strong>功能</strong>：网桥是数据链路层设备，用于连接两个或多个局域网，根据MAC地址在不同网络之间转发数据包。</li><li><strong>工作方式</strong>：网桥能够学习网络中各设备的MAC地址，并根据目的MAC地址选择性地转发数据包，减少了网络中的广播风暴。</li><li><strong>碰撞域</strong>：网桥可以将不同端口划分为不同的碰撞域，有助于减少碰撞，提高网络性能。</li></ul></li><li><p><strong>交换机（Switch）</strong>：</p><ul><li><strong>功能</strong>：交换机是数据链路层设备，用于连接多个设备并在它们之间传输数据包。交换机比网桥更智能，具有更多端口和更高的性能。</li><li><strong>工作方式</strong>：交换机能够学习设备的MAC地址，并根据目的MAC地址将数据包转发到特定端口，实现点对点通信，避免了广播风暴。</li><li><strong>碰撞域</strong>：每个端口连接的设备在交换机中形成独立的碰撞域，因此碰撞通常不会发生。</li></ul></li></ol><p><strong>总结区别</strong>：</p><ul><li>集线器是最简单的设备，广播数据到所有端口，容易导致网络拥堵和碰撞。</li><li>网桥能够学习MAC地址并选择性地转发数据包，减少了广播风暴。</li><li>交换机比网桥更智能，能够实现更高效的数据包转发，避免了广播风暴，并提供更大的端口数量和更高的性能。</li></ul><p>在现代网络中，交换机已经取代了网桥和集线器，因为交换机具有更高的性能、更智能的数据包转发能力和更好的网络管理功能。</p><h3 id="慢启动、拥塞避免、快速重传、快速恢复">慢启动、拥塞避免、快速重传、快速恢复</h3><p>慢启动（Slow Start）、拥塞避免（Congestion Avoidance）、快速重传（Fast Retransmit）和快速恢复（Fast Recovery）是TCP（传输控制协议）中用于控制拥塞和优化传输效率的算法。这些算法一起工作，以确保在网络中传输数据时的高效性和稳定性。</p><ol><li><p><strong>慢启动（Slow Start）</strong>：</p><ul><li><strong>作用</strong>：慢启动是TCP连接刚开始时使用的算法，用于在网络中逐渐增加发送窗口大小，以便测试网络的容量。</li><li><strong>过程</strong>：发送方开始以一个较小的发送窗口大小发送数据，每次收到对端的确认就将发送窗口大小加倍，直到达到一个阈值（拥塞窗口大小）。</li></ul></li><li><p><strong>拥塞避免（Congestion Avoidance）</strong>：</p><ul><li><strong>作用</strong>：一旦发送方达到拥塞窗口大小，就会进入拥塞避免阶段，此时发送方会以更加保守的方式逐渐增加发送窗口的大小，以避免引起网络拥塞。</li><li><strong>过程</strong>：拥塞避免阶段通过线性增长的方式逐步增加发送窗口大小，以减缓数据包的发送速率。</li></ul></li><li><p><strong>快速重传（Fast Retransmit）</strong>：</p><ul><li><strong>作用</strong>：快速重传是一种机制，用于快速检测丢失的数据包并进行重传，而不必等待超时定时器到期。</li><li><strong>过程</strong>：当接收方收到一个失序的数据包时，它会立即发送重复确认（duplicate ACK）给发送方，发送方在收到一定数量的重复确认后会立即重传丢失的数据包。</li></ul></li><li><p><strong>快速恢复（Fast Recovery）</strong>：</p><ul><li><strong>作用</strong>：快速恢复是与快速重传结合使用的一种机制，用于在发生丢包时快速调整拥塞窗口大小，以减少传输的中断时间。</li><li><strong>过程</strong>：当发送方收到三个重复确认时，会将拥塞窗口减半（而不是像慢启动那样将窗口设置为1），然后继续以拥塞避免算法中的方式逐渐增加拥塞窗口大小。</li></ul></li></ol><p>这些算法在TCP协议中起着关键作用，帮助网络中的发送方和接收方协调数据传输，以避免网络拥塞，提高传输效率，并确保数据的可靠传输。</p><h3 id="ISO七层模型与各层的设备和协议">ISO七层模型与各层的设备和协议</h3><p>ISO（国际标准化组织）的七层模型（也称为OSI模型）是一个用于网络通信的参考模型，将网络通信划分为七个不同的层次。每个层次负责不同的功能，从物理连接到应用程序之间的通信。以下是ISO七层模型各层的设备和常见协议：</p><ol><li><p><strong>物理层（Physical Layer）</strong>：</p><ul><li><strong>功能</strong>：负责定义物理设备如何传输数据。</li><li><strong>设备</strong>：集线器（Hub）、中继器（Repeater）等。</li><li><strong>协议</strong>：Ethernet、RS-232、V.35等。</li></ul></li><li><p><strong>数据链路层（Data Link Layer）</strong>：</p><ul><li><strong>功能</strong>：负责在直接相连的设备之间传输数据。</li><li><strong>设备</strong>：网桥（Bridge）、交换机（Switch）等。</li><li><strong>协议</strong>：Ethernet、PPP（Point-to-Point Protocol）、HDLC（High-Level Data Link Control）等。</li></ul></li><li><p><strong>网络层（Network Layer）</strong>：</p><ul><li><strong>功能</strong>：负责在不同网络之间传输数据。</li><li><strong>设备</strong>：路由器（Router）、三层交换机（Layer 3 Switch）等。</li><li><strong>协议</strong>：IP（Internet Protocol）、ICMP（Internet Control Message Protocol）、ARP（Address Resolution Protocol）等。</li></ul></li><li><p><strong>传输层（Transport Layer）</strong>：</p><ul><li><strong>功能</strong>：负责端到端的数据传输。</li><li><strong>设备</strong>：无。</li><li><strong>协议</strong>：TCP（Transmission Control Protocol）、UDP（User Datagram Protocol）等。</li></ul></li><li><p><strong>会话层（Session Layer）</strong>：</p><ul><li><strong>功能</strong>：负责建立、管理和终止会话。</li><li><strong>设备</strong>：无。</li><li><strong>协议</strong>：NetBIOS（Network Basic Input/Output System）、RPC（Remote Procedure Call）等。</li></ul></li><li><p><strong>表示层（Presentation Layer）</strong>：</p><ul><li><strong>功能</strong>：负责数据格式的转换、加密和压缩。</li><li><strong>设备</strong>：无。</li><li><strong>协议</strong>：SSL（Secure Sockets Layer）、JPEG、ASCII等。</li></ul></li><li><p><strong>应用层（Application Layer）</strong>：</p><ul><li><strong>功能</strong>：提供用户接口和网络服务。</li><li><strong>设备</strong>：服务器、客户端等。</li><li><strong>协议</strong>：HTTP（Hypertext Transfer Protocol）、FTP（File Transfer Protocol）、SMTP（Simple Mail Transfer Protocol）等。</li></ul></li></ol><p>ISO七层模型提供了一个通用的框架，帮助理解和组织不同网络协议和设备之间的关系，以便实现网络通信的互操作性和可靠性。</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zwn2001.space">琉璃月</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwn2001.space/posts/Graduate-Works/Experiences/2024BUAA%E5%A4%8D%E8%AF%95%E4%B8%93%E4%B8%9A%E8%AF%BE%E6%8B%BE%E9%81%97/">https://zwn2001.space/posts/Graduate-Works/Experiences/2024BUAA%E5%A4%8D%E8%AF%95%E4%B8%93%E4%B8%9A%E8%AF%BE%E6%8B%BE%E9%81%97/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zwn2001.space" target="_blank">ZWN's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%80%83%E7%A0%94/">考研</a></div><div class="post_share"><div class="social-share" data-image="/img/cover/2.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://unpkg.com/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://unpkg.com/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/Graduate-Works/Experiences/2024BUAA%E8%BD%AF%E9%99%A2%E4%B8%93%E7%A1%95%E8%80%83%E7%A0%94tips/" title="2024BUAA软院专硕考研tips"><img class="cover" src="/img/cover/34.jpg" onerror='onerror=null,src="/img/404.webp"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2024BUAA软院专硕考研tips</div></div></a></div><div class="next-post pull-right"><a href="/posts/Undergraduate-Course/%E6%AF%95%E8%AE%BE%E4%BB%8E%E8%B0%83%E7%A0%94%E5%88%B0%E5%AE%8C%E5%B7%A5/" title="毕设从调研到完工"><img class="cover" src="/img/cover/31.jpg" onerror='onerror=null,src="/img/404.webp"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">毕设从调研到完工</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/Graduate-Works/Experiences/2024BUAA%E8%BD%AF%E9%99%A2%E4%B8%93%E7%A1%95%E8%80%83%E7%A0%94tips/" title="2024BUAA软院专硕考研tips"><img class="cover" src="/img/cover/34.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-04-01</div><div class="title">2024BUAA软院专硕考研tips</div></div></a></div><div><a href="/posts/Graduate-Works/Experiences/%E8%B7%A8%E8%80%83991%E4%B9%8B%E8%BD%AF%E5%B7%A5%E5%A4%8D%E4%B9%A0%E8%A7%81%E8%A7%A3/" title="跨考991之软工复习见解"><img class="cover" src="/img/cover/50.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-07-04</div><div class="title">跨考991之软工复习见解</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.webp" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">琉璃月</div><div class="author-info__description">我虽无意逐鹿，却知苍生苦楚</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">171</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">52</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ZWN2001"><i class="fab fa-github"></i><span>我的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZWN2001" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">新域名：www.zwn2001.space，有效期：10年。https://www.zwn-blog.xyz已过期。访问时建议科学上网，否则博客内公式渲染会出现问题且速度慢。Ctrl+shift+r可强制刷新网站以避免浏览器缓存造成的更新不及时</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">BUAA复试专业课拾遗</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-number">1.1.</span> <span class="toc-text">数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0"><span class="toc-number">1.1.1.</span> <span class="toc-text">什么是关系代数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E8%81%9A%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.2.</span> <span class="toc-text">数据库概念中，什么是聚集函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E7%B4%A2%E5%BC%95"><span class="toc-number">1.1.3.</span> <span class="toc-text">数据库概念中，什么是索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E8%A7%86%E5%9B%BE"><span class="toc-number">1.1.4.</span> <span class="toc-text">数据库概念中，什么是视图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A6%86%E7%9B%96"><span class="toc-number">1.1.5.</span> <span class="toc-text">数据库概念中，什么是正则覆盖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96"><span class="toc-number">1.1.6.</span> <span class="toc-text">数据库概念中，什么是函数依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%E4%B8%AD%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E5%A4%9A%E5%80%BC%E4%BE%9D%E8%B5%96"><span class="toc-number">1.1.7.</span> <span class="toc-text">数据库概念中，什么是多值依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#E-R%E6%A8%A1%E5%9E%8B%E5%90%88%E5%B9%B6%E4%BC%9A%E6%9C%89%E5%93%AA%E4%BA%9B%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.8.</span> <span class="toc-text">E-R模型合并会有哪些问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E2%80%9C%E5%85%A8%E9%83%A8%E2%80%9D%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="toc-number">1.1.9.</span> <span class="toc-text">对“全部”的表示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.1.10.</span> <span class="toc-text">数据库的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.1.11.</span> <span class="toc-text">关系模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E6%95%B0%E6%8D%AE%E5%BA%93Armstrong%E5%85%AC%E7%90%86"><span class="toc-number">1.1.12.</span> <span class="toc-text">讲讲数据库Armstrong公理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81"><span class="toc-number">1.1.13.</span> <span class="toc-text">数据库锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%89%E4%B8%AA%E5%AE%8C%E6%95%B4%E6%80%A7%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.1.14.</span> <span class="toc-text">数据库的三个完整性是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">1.1.15.</span> <span class="toc-text">数据库主从复制的原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%AD%E5%85%B3%E7%B3%BB%E8%BF%90%E7%AE%97%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.16.</span> <span class="toc-text">数据库中关系运算有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E4%B9%8B%E9%97%B4%E7%9A%84%E8%81%94%E7%B3%BB%E6%9C%89%E9%82%A3%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.1.17.</span> <span class="toc-text">实体之间的联系有那些？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86"><span class="toc-number">1.2.</span> <span class="toc-text">编译原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%ADDFA%E4%B8%8ENFA%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.1.</span> <span class="toc-text">编译原理中DFA与NFA的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E6%96%87%E6%B3%95"><span class="toc-number">1.2.2.</span> <span class="toc-text">编译原理中什么是文法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B8%AD%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%AD%E6%B3%95"><span class="toc-number">1.2.3.</span> <span class="toc-text">编译原理中什么是语法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%87%AA%E4%B8%8A%E8%80%8C%E4%B8%8B%E5%92%8C%E8%87%AA%E4%B8%8B%E8%80%8C%E4%B8%8A%E6%96%B9%E6%B3%95%EF%BC%9A%E4%B8%A4%E7%A7%8D%E4%B8%8D%E5%90%8C%E7%9A%84%E6%9E%84%E5%BB%BA%E8%AF%AD%E6%B3%95%E5%88%86%E6%9E%90%E6%A0%91%E7%9A%84%E6%80%9D%E8%B7%AF"><span class="toc-number">1.2.4.</span> <span class="toc-text">自上而下和自下而上方法：两种不同的构建语法分析树的思路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91"><span class="toc-number">1.2.5.</span> <span class="toc-text">什么是语法制导翻译</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E5%AE%9A%E4%B9%89%EF%BC%88SDD%EF%BC%89"><span class="toc-number">1.2.5.1.</span> <span class="toc-text">语法制导定义（SDD）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AF%AD%E6%B3%95%E5%88%B6%E5%AF%BC%E7%BF%BB%E8%AF%91%E6%96%B9%E6%A1%88"><span class="toc-number">1.2.5.2.</span> <span class="toc-text">语法制导翻译方案</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">1.2.6.</span> <span class="toc-text">编译过程是怎样的？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E8%BF%B0%E4%BB%80%E4%B9%88%E6%98%AF%E7%AC%A6%E5%8F%B7%E8%A1%A8%EF%BC%8C%E7%AC%A6%E5%8F%B7%E8%A1%A8%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8"><span class="toc-number">1.2.7.</span> <span class="toc-text">简述什么是符号表，符号表有什么作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%9A%84%E5%9B%9E%E5%A1%AB%E6%8A%80%E6%9C%AF"><span class="toc-number">1.2.8.</span> <span class="toc-text">讲讲编译原理的回填技术</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.3.</span> <span class="toc-text">软件工程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BD%AF%E4%BB%B6%E9%94%99%E8%AF%AF%E3%80%81%E7%BC%BA%E9%99%B7%E3%80%81%E6%95%85%E9%9A%9C%E5%92%8C%E5%A4%B1%E6%95%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">软件错误、缺陷、故障和失效</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CMM"><span class="toc-number">1.3.2.</span> <span class="toc-text">CMM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%B2%E8%AE%B2UML%E9%A1%BA%E5%BA%8F%E5%9B%BE"><span class="toc-number">1.3.3.</span> <span class="toc-text">讲讲UML顺序图</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E6%B5%8B%E8%AF%95"><span class="toc-number">1.3.4.</span> <span class="toc-text">集成测试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E7%9A%84%E5%86%85%E8%81%9A%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%80%8E%E6%A0%B7%E6%89%8D%E8%83%BD%E5%81%9A%E5%88%B0%E9%AB%98%E5%86%85%E8%81%9A%EF%BC%9F"><span class="toc-number">1.3.5.</span> <span class="toc-text">模块的内聚是什么，怎样才能做到高内聚？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%A3%E9%87%8A%E4%B8%9A%E5%8A%A1%E9%9C%80%E6%B1%82%E3%80%81%E7%94%A8%E6%88%B7%E9%9C%80%E6%B1%82%E3%80%81%E5%8A%9F%E8%83%BD%E9%9C%80%E6%B1%82"><span class="toc-number">1.3.6.</span> <span class="toc-text">解释业务需求、用户需求、功能需求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E6%9C%89%E5%93%AA%E4%BA%9B%E7%89%B9%E7%82%B9%EF%BC%9F"><span class="toc-number">1.3.7.</span> <span class="toc-text">面向对象软件工程有哪些特点？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E5%9F%BA%E7%BA%BF%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">1.3.8.</span> <span class="toc-text">配置管理系统中基线的作用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.4.1.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.1.1.</span> <span class="toc-text">Prim算法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.1.2.</span> <span class="toc-text">Kruskal算法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A"><span class="toc-number">1.4.1.3.</span> <span class="toc-text">区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%E5%92%8CFloyd%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.2.</span> <span class="toc-text">迪杰斯特拉算法和Floyd算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.2.1.</span> <span class="toc-text">迪杰斯特拉算法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd%E7%AE%97%E6%B3%95%EF%BC%9A"><span class="toc-number">1.4.2.2.</span> <span class="toc-text">Floyd算法：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A-2"><span class="toc-number">1.4.2.3.</span> <span class="toc-text">区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%E3%80%81-B%EF%BC%8B%E6%A0%91%E6%9F%A5%E6%89%BE%E3%80%81%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%8C-%E8%BF%99%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95%E6%9C%89%E5%95%A5%E4%B8%8D%E5%90%8C%EF%BC%9F"><span class="toc-number">1.4.3.</span> <span class="toc-text">索引查找、 B＋树查找、折半查找， 这三种方法有啥不同？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%88Binary-Search%EF%BC%89%EF%BC%9A"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">折半查找（Binary Search）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E6%9F%A5%E6%89%BE%EF%BC%88Index-Search%EF%BC%89%EF%BC%9A"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">索引查找（Index Search）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B-%E6%A0%91%E6%9F%A5%E6%89%BE%EF%BC%88B-Tree-Search%EF%BC%89%EF%BC%9A"><span class="toc-number">1.4.3.3.</span> <span class="toc-text">B+树查找（B+ Tree Search）：</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB%EF%BC%9A-3"><span class="toc-number">1.4.3.4.</span> <span class="toc-text">区别：</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B0%BE%E9%80%92%E5%BD%92"><span class="toc-number">1.4.4.</span> <span class="toc-text">什么是尾递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88B%EF%BC%8B%E6%A0%91%E5%88%86%E6%94%AF%E4%B8%8D%E6%94%BE%E6%95%B0%E6%8D%AE"><span class="toc-number">1.4.5.</span> <span class="toc-text">为什么B＋树分支不放数据</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E6%9E%84%E9%80%A0%E7%9A%84%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">1.4.6.</span> <span class="toc-text">散列函数构造的方法有哪些？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E6%8C%87%E9%92%88%EF%BC%8C%E6%95%B4%E5%9E%8B%E6%8C%87%E9%92%88%EF%BC%8C%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88%E7%9A%84%E5%A4%A7%E5%B0%8F%E5%85%B3%E7%B3%BB%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.4.7.</span> <span class="toc-text">函数指针，整型指针，数组指针的大小关系，为什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.5.</span> <span class="toc-text">操作系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81"><span class="toc-number">1.5.1.</span> <span class="toc-text">操作系统的特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8%E7%89%B9%E5%BE%81"><span class="toc-number">1.5.2.</span> <span class="toc-text">虚拟存储器特征</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E7%AE%A1%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-number">1.5.3.</span> <span class="toc-text">请求分页管理方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%B5%E6%A1%86%E5%88%86%E9%85%8D"><span class="toc-number">1.5.4.</span> <span class="toc-text">页框分配</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">1.5.5.</span> <span class="toc-text">操作系统什么是虚拟内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">1.5.6.</span> <span class="toc-text">设备驱动作用是什么？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80%E5%92%8C%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.5.7.</span> <span class="toc-text">物理地址和逻辑地址的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%BD%91"><span class="toc-number">1.6.</span> <span class="toc-text">计网</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%8E%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E8%BE%93%E5%85%A5%E4%BF%A1%E6%81%AF%E5%88%B0%E8%BF%99%E4%B8%AA%E4%BF%A1%E6%81%AF%E8%A2%AB%E6%88%91%E4%BB%AC%E7%9C%8B%E5%88%B0%EF%BC%8C-%E8%BF%99%E9%83%BD%E7%94%A8%E5%88%B0%E4%BA%86%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E5%B1%82"><span class="toc-number">1.6.1.</span> <span class="toc-text">从浏览器中输入信息到这个信息被我们看到， 这都用到了计算机网络中的哪些层</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#OSPF%E5%92%8CBGP"><span class="toc-number">1.6.2.</span> <span class="toc-text">OSPF和BGP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%9C%BA%E3%80%81-%E7%BD%91%E6%A1%A5%E5%92%8C-HUB-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.6.3.</span> <span class="toc-text">交换机、 网桥和 HUB 的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%85%A2%E5%90%AF%E5%8A%A8%E3%80%81%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D%E3%80%81%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0%E3%80%81%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8D"><span class="toc-number">1.6.4.</span> <span class="toc-text">慢启动、拥塞避免、快速重传、快速恢复</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ISO%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8E%E5%90%84%E5%B1%82%E7%9A%84%E8%AE%BE%E5%A4%87%E5%92%8C%E5%8D%8F%E8%AE%AE"><span class="toc-number">1.6.5.</span> <span class="toc-text">ISO七层模型与各层的设备和协议</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/Graduate-Works/Works/Defects4J%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" title="Defects4J使用"><img src="/img/cover/57.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="Defects4J使用"></a><div class="content"><a class="title" href="/posts/Graduate-Works/Works/Defects4J%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/" title="Defects4J使用">Defects4J使用</a><time datetime="2025-04-29T09:40:59.000Z" title="发表于 2025-04-29 17:40:59">2025-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Graduate-Works/Works/LLM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" title="LLM基础知识整理"><img src="/img/cover/28.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="LLM基础知识整理"></a><div class="content"><a class="title" href="/posts/Graduate-Works/Works/LLM%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%95%B4%E7%90%86/" title="LLM基础知识整理">LLM基础知识整理</a><time datetime="2025-04-29T09:40:59.000Z" title="发表于 2025-04-29 17:40:59">2025-04-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Graduate-Works/Paper-Read/%E8%AF%BBpaper20-%E5%9F%BA%E4%BA%8ELLM%E7%9A%84%E7%BC%BA%E9%99%B7%E4%BF%AE%E5%A4%8D6/" title="读paper20-基于LLM的缺陷修复6"><img src="/img/cover/6.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="读paper20-基于LLM的缺陷修复6"></a><div class="content"><a class="title" href="/posts/Graduate-Works/Paper-Read/%E8%AF%BBpaper20-%E5%9F%BA%E4%BA%8ELLM%E7%9A%84%E7%BC%BA%E9%99%B7%E4%BF%AE%E5%A4%8D6/" title="读paper20-基于LLM的缺陷修复6">读paper20-基于LLM的缺陷修复6</a><time datetime="2025-04-23T08:23:38.000Z" title="发表于 2025-04-23 16:23:38">2025-04-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Graduate-Works/Paper-Read/%E8%AF%BBpaper19-%E5%9F%BA%E4%BA%8ELLM%E7%9A%84%E7%BC%BA%E9%99%B7%E4%BF%AE%E5%A4%8D5/" title="读paper19-基于LLM的缺陷修复5与总结"><img src="/img/cover/51.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="读paper19-基于LLM的缺陷修复5与总结"></a><div class="content"><a class="title" href="/posts/Graduate-Works/Paper-Read/%E8%AF%BBpaper19-%E5%9F%BA%E4%BA%8ELLM%E7%9A%84%E7%BC%BA%E9%99%B7%E4%BF%AE%E5%A4%8D5/" title="读paper19-基于LLM的缺陷修复5与总结">读paper19-基于LLM的缺陷修复5与总结</a><time datetime="2025-03-14T12:44:13.000Z" title="发表于 2025-03-14 20:44:13">2025-03-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/Graduate-Works/Paper-Read/%E8%AF%BBpaper18-Agent_for_code/" title="读paper18-Agent_for_code"><img src="/img/cover/43.jpg" onerror='this.onerror=null,this.src="/img/404.webp"' alt="读paper18-Agent_for_code"></a><div class="content"><a class="title" href="/posts/Graduate-Works/Paper-Read/%E8%AF%BBpaper18-Agent_for_code/" title="读paper18-Agent_for_code">读paper18-Agent_for_code</a><time datetime="2025-02-23T06:42:54.000Z" title="发表于 2025-02-23 14:42:54">2025-02-23</time></div></div></div></div></div></div></main><footer id="footer" style="background:0 0"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();" rel="external nofollow noreferrer"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());" rel="external nofollow noreferrer"><i class="iconfont icon-baidu"></i><span>搜索</span></a><a class="rightMenu-item" href="javascript:rmf.searchinThisPage();" rel="external nofollow noreferrer"><i class="fas fa-search"></i><span>站内搜索</span></a><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>粘贴</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()" rel="external nofollow noreferrer"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()" rel="external nofollow noreferrer"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.translate();" rel="external nofollow noreferrer"><i class="iconfont icon-fanti"></i><span>繁简转换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa fa-book"></i><span>阅读模式</span></a><a class="rightMenu-item" href="javascript:fullScreen();" rel="external nofollow noreferrer"><i class="fas fa-expand"></i><span>进入全屏</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://unpkg.com/@fancyapps/ui/dist/fancybox/fancybox.umd.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://unpkg.com/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){GLOBAL_CONFIG_SITE.isPost&&panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://unpkg.com/katex/dist/katex.min.css"><script src="https://unpkg.com/katex/dist/contrib/copy-tex.min.js"></script><script>document.querySelectorAll("#article-container span.katex-display").forEach(a=>{btf.wrap(a,"div",{class:"katex-wrap"})})</script><script>function getGiscusTheme(e){return"dark"===e?"dark":"light"}function loadGiscus(){var e,t=Object.assign({src:"https://giscus.app/client.js","data-repo":"ZWN2001/ZWN2001.github.io","data-repo-id":"R_kgDOGH1XWg","data-category-id":"DIC_kwDOGH1XWs4CXnHJ","data-mapping":"pathname","data-theme":getGiscusTheme(document.documentElement.getAttribute("data-theme")),"data-reactions-enabled":"1",crossorigin:"anonymous",async:!0},{"data-lang":"zh-CN","data-loading":"lazy",crossorigin:"anonymous","data-mapping":"og:title","data-input-position":"top","data-category":"Announcements"}),a=document.createElement("script");for(e in t)a.setAttribute(e,t[e]);document.getElementById("giscus-wrap").insertAdjacentElement("afterbegin",a)}function changeGiscusTheme(e){var t;e={setConfig:{theme:getGiscusTheme(e)}},(t=document.querySelector("iframe.giscus-frame"))&&t.contentWindow.postMessage({giscus:e},"https://giscus.app")}function loadOtherComment(){loadGiscus()}btf.addModeChange("giscus",changeGiscusTheme),btf.loadComment(document.getElementById("giscus-wrap"),loadGiscus)</script></div><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.7.1/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span> 数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><script data-pjax>var parent,child;document.getElementById("recent-posts")&&"/"===location.pathname&&(parent=document.getElementById("recent-posts"),child='<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/编程知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 琉璃月の编程知识 (13)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/实用知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 琉璃月の实用知识 (10)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/学习-课外拓展/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 琉璃月の学习-课外拓展 (39)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/学习-课内知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 琉璃月の学习-课内知识 (59)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://zwn2001.space/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>',console.log("已挂载magnet"),parent.insertAdjacentHTML("afterbegin",child))</script><style>#catalog_magnet{flex-wrap:wrap;display:flex;width:100%;justify-content:space-between;padding:10px 10px 0 10px;align-content:flex-start}.magnet_item{flex-basis:calc(50% - 5px);background:#f2f2f2;margin-bottom:10px;border-radius:8px;transition:all .2s ease-in-out}.magnet_item:hover{background:#b30070}.magnet_link_more{color:#555}.magnet_link{color:#000}.magnet_link:hover{color:#fff}@media screen and (max-width:600px){.magnet_item{flex-basis:100%}}.magnet_link_context{display:flex;padding:10px;font-size:16px;transition:all .2s ease-in-out}.magnet_link_context:hover{padding:10px 20px}</style><style></style></body></html>