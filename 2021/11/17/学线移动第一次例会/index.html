<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>学线移动第一次例会 | ZWN's blog</title><meta name="keywords" content="学线培训"><meta name="author" content="ZWN"><meta name="copyright" content="ZWN"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="学线移动第一次培训 1.作业点评 略 2.细说MVC架构与项目分包 参考： https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;MVC https:&#x2F;&#x2F;draveness.me&#x2F;mvx&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_39218605&#x2F;article&#x2F;details&#x2F;80779349?utm_medium&#x3D;distribute.pc_relevant.none-task">
<meta property="og:type" content="article">
<meta property="og:title" content="学线移动第一次例会">
<meta property="og:url" content="https://zwn2001.github.io/2021/11/17/%E5%AD%A6%E7%BA%BF%E7%A7%BB%E5%8A%A8%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BE%8B%E4%BC%9A/index.html">
<meta property="og:site_name" content="ZWN&#39;s blog">
<meta property="og:description" content="学线移动第一次培训 1.作业点评 略 2.细说MVC架构与项目分包 参考： https:&#x2F;&#x2F;zh.wikipedia.org&#x2F;wiki&#x2F;MVC https:&#x2F;&#x2F;draveness.me&#x2F;mvx&#x2F; https:&#x2F;&#x2F;blog.csdn.net&#x2F;qq_39218605&#x2F;article&#x2F;details&#x2F;80779349?utm_medium&#x3D;distribute.pc_relevant.none-task">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zwn2001.github.io/img/default_top_img/44.jpg">
<meta property="article:published_time" content="2021-11-17T13:01:23.000Z">
<meta property="article:modified_time" content="2021-12-09T13:19:42.409Z">
<meta property="article:author" content="ZWN">
<meta property="article:tag" content="学线培训">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zwn2001.github.io/img/default_top_img/44.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zwn2001.github.io/2021/11/17/%E5%AD%A6%E7%BA%BF%E7%A7%BB%E5%8A%A8%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BE%8B%E4%BC%9A/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":50,"languages":{"author":"作者: ZWN","link":"链接: ","source":"来源: ZWN's blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '学线移动第一次例会',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2021-12-09 21:19:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><style type="text/css">.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><meta name="generator" content="Hexo 5.4.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/default_top_img/44.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">ZWN's blog</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">学线移动第一次例会</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-11-17T13:01:23.000Z" title="发表于 2021-11-17 21:01:23">2021-11-17</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2021-12-09T13:19:42.409Z" title="更新于 2021-12-09 21:19:42">2021-12-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD/">学线培训</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">9.7k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="学线移动第一次例会"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>学线移动第一次培训</h1>
<h2 id="1-作业点评">1.作业点评</h2>
<p>略</p>
<h2 id="2-细说MVC架构与项目分包">2.细说MVC架构与项目分包</h2>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MVC">https://zh.wikipedia.org/wiki/MVC</a></p>
<p><a target="_blank" rel="noopener" href="https://draveness.me/mvx/">https://draveness.me/mvx/</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_39218605/article/details/80779349?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&amp;spm=1001.2101.3001.4242.1">https://blog.csdn.net/qq_39218605/article/details/80779349?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-0.no_search_link&amp;spm=1001.2101.3001.4242.1</a></p>
<p>参考文献http://www.dgp.toronto.edu/~dwigdor/teaching/csc2524/2012_F/papers/mvc.pdf</p>
<h3 id="基本概念">基本概念</h3>
<p>我们将应用程序划分为三种组件，模型 - 视图 - 控制器（MVC）设计定义它们之间的相互作用。</p>
<p><img src="0.jpg" alt=""></p>
<p>在上面那篇论文中是这样描述这三部分的：</p>
<blockquote>
<p>In the MVC paradigm the user input, the modeling of the external world, and the visual feedback to the user are explicitly separated and handled by three types of object, each specialized for its task.</p>
<p>The <strong>view</strong> manages the graphical and/or textual output to the portion of the bitmapped display that is allocated to its application.</p>
<p>The <strong>controller</strong> interprets the mouse and keyboard inputs from the user, commanding the model and/or the view to change as appropriate.</p>
<p>Finally, the <strong>model</strong> manages the behavior and data of the application domain, responds to requests for information about its state (usually from the view), and responds to instructions to change state (usually from the controller).</p>
</blockquote>
<ul>
<li><strong>模型 (Model)</strong> <strong>用于封装与应用程序的业务逻辑相关的数据以及对数据的逻辑。“ Model ”有对数据直接访问的权力，例如对数据库的访问。“Model”不依赖“View”和“Controller”，也就是说， <strong>Model 不关心它会被如何显示或是如何被操作</strong>。但是 Model 中数据的变化一般会通过一种刷新机制被公布。为了实现这种机制，那些用于监视此 Model 的 View 必须事先在此 Model 上注册，从而，View 可以了解在数据 Model 上发生的改变。（比如：<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F">观察者模式</a>）(比如实体类)</strong></li>
<li>**视图 (View)**能够实现数据有目的的显示（理论上，这不是必需的）。在 View 中一般没有程序上的逻辑。为了实现 View 上的刷新功能，<strong>View 需要访问它监视的数据模型（Model），因此应该事先在被它监视的数据那里注册。（<code>findViewbyId</code>方法）</strong></li>
<li>**控制器 (Controller)**起到不同层面间的组织作用，<strong>用于控制应用程序的流程。它处理事件并作出响应</strong>。“事件”包括用户的行为和数据 Model 上的改变。</li>
</ul>
<h3 id="依赖关系">依赖关系</h3>
<p>虽然我们对 MVC 中的各个模块的交互不是特别了解，但是三者之间的依赖关系却是非常明确的；<strong>在 MVC 中，模型层可以单独工作，而视图层和控制器层都依赖与模型层中的数据。</strong></p>
<p><img src="1.jpg" alt=""></p>
<blockquote>
<p>虽然如上图所示，视图和控制器之间没有相互依赖，不过因为视图和控制器之间的依赖并不常用，所以图中将视图和控制器之间的依赖省略了。</p>
</blockquote>
<h3 id="优点">优点</h3>
<p>首先，多个 View 能共享一个 Model 。如今，同一个Web应用程序会提供多种用户界面，例如用户希望既能够通过浏览器来收发<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E4%BB%B6">电子邮件</a>，还希望通过手机来访问<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%94%B5%E5%AD%90%E9%82%AE%E7%AE%B1">电子邮箱</a>，这就要求Web网站同时能提供<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Internet">Internet</a>界面和<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/WAP">WAP</a>界面。在MVC设计模式中， <strong>Model 响应用户请求并返回响应数据，View 负责格式化数据并把它们呈现给用户，业务逻辑和表示层分离，同一个 Model 可以被不同的 View 重用，所以大大提高了代码的可重用性。</strong></p>
<p>其次，<strong>Controller 是自包含（self-contained,指高独立内聚）的对象，与 Model 和 View 保持相对独立，所以可以方便的改变应用程序的数据层和业务规则</strong>。例如，把数据库从<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/MySQL">MySQL</a>移植到<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Oracle">Oracle</a>，或者把<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/RDBMS">RDBMS</a>数据源改变成<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LDAP">LDAP</a>数据源，只需改变 Controller 即可。一旦正确地实现了控制器，不管数据来自数据库还是<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/LDAP">LDAP</a>服务器，View 都会正确地显示它们。由于MVC模式的三个模块相互独立，改变其中一个不会影响其他两个，所以依据这种设计思想能构造良好的少互扰性的构件。</p>
<p>此外，Controller 提高了应用程序的灵活性和可配置性。<strong>Controller 可以用来连接不同的 Model 和 View 去完成用户的需求</strong>，也可以构造应用程序提供强有力的手段。给定一些可重用的 Model 、 View 和Controller 可以根据用户的需求选择适当的 Model 进行处理，然后选择适当的的 View 将处理结果显示给用户。</p>
<h3 id="评价、误解及适用范围">评价、误解及适用范围</h3>
<p>MVC模式在概念上强调 Model, View, Controller 的分离，各个模块也遵循着由 Controller 来处理消息，Model 掌管数据源，View 负责资料显示的职责分离原则，因此在实现上，MVC 模式的 Framework 通常会将 MVC 三个部分分离实现：</p>
<ul>
<li><strong>Model 负责资料访问</strong>，较现代的 Framework 都会建议使用独立的资料对象 (DTO, POCO, POJO 等) 来替代弱类型的集合对象。资料访问的代码会使用 Data Access 的代码或是 ORM-based Framework，也可以进一步使用 Repository Pattern 与 Unit of Works Pattern 来切割数据源的相依性。</li>
<li><strong>Controller 负责处理消息</strong>，较高端的 Framework 会有一个默认的实现来作为 Controller 的基础，例如 Spring 的 DispatcherServlet 或是 <a target="_blank" rel="noopener" href="http://ASP.NET">ASP.NET</a> MVC 的 Controller 等，在职责分离原则的基础上，每个 Controller 负责的部分不同，因此会将各个 Controller 切割成不同的文件以利维护。</li>
<li><strong>View 负责显示资料</strong>，这个部分多为前端应用，而 Controller 会有一个机制将处理的结果 (可能是 Model, 集合或是状态等) 交给 View，然后由 View 来决定怎么显示。例如 Spring Framework 使用 JSP 或相应技术，<a target="_blank" rel="noopener" href="http://ASP.NET">ASP.NET</a> MVC 则使用 Razor 处理资料的显示。</li>
</ul>
<p>也因为 MVC 模式强调职责分离，所以在发展 MVC 应用时会产生很多文件，在 IDE (集成开发环境) 不够成熟时它会是个问题，但在现代主流 IDE 都能使用类别对象的信息来组织代码编辑的情况下，多文件早已不是问题，而且 <strong>MVC 模式会要求开发者进一步思考应用程序的架构 (Application Architecture)，而非用大杂烩的方式开发应用程序，对于应用程序的生命周期以及后续的可扩展与可维护性而言有相当正面的帮助</strong>。另外，MVC 职责分离也带来了一个现代软件工程要求的重要特性：可测试性 (Testability)，<strong>MVC-based 的应用程序在良好的职责分离的设计下，各个部分可独立行使<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95">单元测试</a>，有利于与企业内的自动化测试、<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88">持续集成</a> (Continuous Integration) 与<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E4%BA%A4%E4%BB%98">持续交付</a> (Continuous Delivery) 流程集成，减少应用程序改版部署所需的时间。</strong></p>
<p>MVC 模式的应用程序的目的就是希望打破以往应用程序使用的大杂烩程序撰写方式，并间接诱使开发人员以更高的架构导向思维来思考应用程序的设计，因此对于一个刚入门的初学者来说，架构导向的思考会有一定的门槛，需要较多的实现与练习才能具备相应的能力，大多数的初学者还是较习惯于大杂烩式的程序撰写，所以可能会对 MVC 模式抱持着排斥或厌恶的心态，然而 MVC（或是其他的<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F_(%E8%AE%A1%E7%AE%97%E6%9C%BA)">设计模式</a>）都是有助于应用程序长远的发展，虽然大杂烩式的程序也可以用来发展长生命周期的应用程序，但是相较于 MVC，大杂烩式的程序在可扩展性和可维护性 (尤其是可测试性) 上会远比 MVC 复杂很多，相反的，<strong>MVC 模式的应用程序是在初始开发时期必须先思考并使用软件架构，使得开发时期会需要花较多心力，但是一旦应用程序完成后，可扩展性、可维护性和可测试性反而会因为 MVC 的特性而变得容易。</strong></p>
<p>因此，MVC 模式在已有众多优秀 Framework 的现代，早就已经没有不适合小型应用的问题，小型的应用还是可以由 MVC Framework 的应用来获取 MVC 的优点，同时它也能作为未来小型应用扩展到大型应用时的基础与入门砖。若一开始就想要做大型应用，那么 MVC 模式的职责分离以及要求开发的架构思考会更适合大型应用的开发。</p>
<h3 id="MVC的不足">MVC的不足</h3>
<p>（1）<strong>增加了系统结构和实现的复杂性</strong>。对于简单的界面，严格遵循MVC，使模型、视图与控制器分离，会增加结构的复杂性，并可能产生过多的更新操作，降低运行效率。</p>
<p>（2） 目前，一般高级的界面工具或构造器不支持MVC架构。改造这些工具以适应MVC需要和建立分离的部件的代价是很高的，从而造成使用MVC的困难。</p>
<p>(3)    降低了系统的性能。如果不采用分层式结构，很多业务可以直接造访数据库，以此获取相应的数据，如今却必须通过中间层来完成。</p>
<p>(4)    增加了代码量，增加了工作量。</p>
<h3 id="实际情况">实际情况</h3>
<p>在实际情况下，单独的 iOS、Android 和 Web 应用往往不能单独工作，这些客户端应用需要与服务端一起工作；当前端/客户端与后端一同工作时，其实分别『部署』了两个不同的应用，这两个应用都遵循 MVC 架构模式：</p>
<p><img src="2.jpg" alt=""></p>
<p>客户端和服务器通过网络进行连接，并组成了一个更大的 MVC 架构；从这个角度来看，服务端的模型层才存储了真正的数据，而客户端的模型层只不过是一个存储在客户端设备中的本地缓存和临时数据的集合；同理，服务端的视图层也不是整个应用的视图层，用于为用户展示数据的视图层位于客户端，也就是整个架构的最顶部；中间的五个部分，也就是从低端的模型层到最上面的视图共同组成了整个应用的控制器，将模型中的数据以合理的方式传递给最上层的视图层用于展示。</p>
<h2 id="3-代码规范">3.代码规范</h2>
<p>转载（有改动）：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/104253155">https://zhuanlan.zhihu.com/p/104253155</a>   在此致敬原作者</p>
<p>开始正文前，咱们还需要明确编码规范的两个原则：</p>
<ol>
<li><strong>封装和多态</strong>：Java是面向对象的编程语言，语言特征是：封装、继承和多态。但笔者认为继承有时候会破坏封装性，请谨慎使用，面向对象封装和多态是核心；</li>
<li><strong>可维护性优先于性能</strong>：编码规范围绕中心是代码的可维护性，在需要对代码可维护性和性能做出权衡时，优先考虑代码可维护性，笔者认为，好的代码结构可以保证好的性能，性能在设计时就应该纳入思考；</li>
</ol>
<p><strong>PS.个人认为第二点更重要</strong></p>
<h3 id="命名">命名</h3>
<p>业界有一句话也许大部分程序员都认同：“代码就是最好的注释”，而好的命名有利于增强代码的可读性。为了增强代码的可读性，笔者认为命名应遵从三个原则：</p>
<ol>
<li><strong>共识</strong>：共识是指不同人的横向比较，共识按范围分包含组内共识（业务相关的专有名词）、企业内部公司和业界共识；</li>
<li><strong>统一</strong>：统一是指单个人的垂直比较，<strong>单个人在不同时间点编写的变量、方法、类的命名要统一</strong>，不能出现同一个概念一会儿这样命名，一会儿又那样命名；命名不同意也会加大代码阅读难度；</li>
<li><strong>得体</strong>：<strong>得体是指用词合理，做到词能达意</strong>，命名能够很好地表达用意（类命名一般是名词短语，方法命名一般是动词短语）；</li>
</ol>
<p>《开发手册》提出了一系列强制和推荐的编程规约，其目的也是达成共识，做到见名知意。如有以下命名规约：</p>
<blockquote>
<p>代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。</p>
<p>代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。</p>
<p>类名使用 <code>UpperCamelCase</code> 风格，必须遵从驼峰形式，但以下情形例外：DO / BO /DTO / VO / AO</p>
<p>方法名、参数名、成员变量、局部变量都统一使用 <code>lowerCamelCase</code> 风格，必须遵从驼峰形式。</p>
<p>常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长（尽量短）。</p>
<p>中括号是数组类型的一部分，数组定义如下：<code>String[] args</code>;</p>
<p>POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。（没遇见过）</p>
<p>包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。</p>
<p>杜绝完全不规范的缩写，避免望文不知义。</p>
</blockquote>
<p>注：《开发手册》目的是在企业内部达成共识，所以才会加上阿里巴巴关键词限定，业界可用来作为参考，但各个企业还是需要根据实际情况制定自己的规范，比如上面的第3点，笔者认为为了统一，后面的特殊情况也不应该出现，还是应该<code>Do/Bo/Dto/Vo</code>这样命名，做到统一。此外一些推荐的规则，比如</p>
<blockquote>
<p>如果模块、接口、类、方法使用了设计模式，在命名时体现出具体模式。</p>
</blockquote>
<p>其实笔者认为应该作为强制规则发布，这样命名可以很好的告知设计模式，读者可以很快在脑海中绘制设计模式对应的代码结构并立刻知道代码功能（常见设计模式在程序员界已形成共识，如果对应设计模式还不了解，说明功底不够还需要修炼）。</p>
<p>统一讲的是个人在编码过程中做到命名前后一致，如果做不到统一，会给他人阅读就带来了难度。《开发手册》这类文献可以起到一定作用，但很大一部分还是个人的自我约束。举两个反例：</p>
<ul>
<li>同义词命名不统一：比如“指标“”这个词，一会儿用<code>Index</code>，一会儿用<code>indicator</code>；</li>
<li>拼写和英文命名不统一：比如“代理商”这个词，一会儿用<code>Agent</code>，一会儿用<code>DaiLiShang</code>；</li>
</ul>
<h4 id="变量命名">变量命名</h4>
<p><strong>变量名应该简短且有意义，并能够顾名思义</strong>。简单并不意味着越短越好，比如一个字符的变量名是不允许的，很影响代码的可读性。</p>
<p>反例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i;  <span class="comment">// 不允许 </span></span><br><span class="line"><span class="keyword">char</span> c;  <span class="comment">//  不允许</span></span><br></pre></td></tr></table></figure>
<p>对于局部变量，为了保证代码简洁，<strong>局部变量命名只要能够在代码中区分，应避免名称过长</strong>，影响阅读。</p>
<p>拿Spring MVC中<code>DispatcherServlet</code>类中的代码片段来举例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">HandlerMapping hm = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class); </span><br><span class="line"><span class="comment">// 而非HandlerMapping handleMapping = context.getBean(HANDLER_MAPPING_BEAN_NAME, HandlerMapping.class)</span></span><br><span class="line">HandlerAdapter ha = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class);  </span><br><span class="line"><span class="comment">// 而非HandlerAdapter handlerAdapter = context.getBean(HANDLER_ADAPTER_BEAN_NAME, HandlerAdapter.class); 变量命名可改成HandlerAdapter adapter = XXX;</span></span><br><span class="line">HandlerExceptionResolver her = context.getBean(HANDLER_EXCEPTION_RESOLVER_BEAN_NAME, HandlerExceptionResolver.class);</span><br><span class="line">ViewResolver vr = context.getBean(VIEW_RESOLVER_BEAN_NAME, ViewResolver.class);</span><br><span class="line">WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); </span><br><span class="line"><span class="comment">// 而非WebAsyncManager webAsyncManager = WebAsyncUtils.getAsyncManager(request);</span></span><br><span class="line">MultipartHttpServletRequest req = WebUtils.getNativeRequest(servletRequest, MultipartHttpServletRequest.class);</span><br><span class="line">HandlerExecutionChain handler = hm.getHandler(request);</span><br></pre></td></tr></table></figure>
<p>对于类中的私有域（field）名称，则不应该缩写，域名称需要很好的反映到底是哪个类的实例以免影响阅读。</p>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">@Autowired</span><br><span class="line">private WordStudyStatisticManager statisticManager; // 改成全名 private WordStudyStatisticManager wordStudyStatisticManager;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public CommonResult&lt;WordStudyStatistic&gt; addWordStudyStatistic(WordStudyStatistic wordStudyStatistic) &#123;</span><br><span class="line">   CommonResult&lt;WordStudyStatistic&gt; result = new CommonResult&lt;WordStudyStatistic&gt;();</span><br><span class="line">   try &#123;</span><br><span class="line">        Date current = new Date();</span><br><span class="line">        wordStudyStatistic.setCreated(current);</span><br><span class="line">        wordStudyStatistic.setModified(current);</span><br><span class="line">        result.addDefaultModel(studyStatisticManager.addWordStudyStatistic(wordStudyStatistic));</span><br><span class="line">        // 通过缩写减少字母个数没必要反而会影响阅读</span><br><span class="line">        result.setSuccess(true);</span><br><span class="line">   &#125; catch (Exception e) &#123;</span><br><span class="line">        logger.error(&quot;添加单词学习统计失败&quot;, e);</span><br><span class="line">        result.setSuccess(false);</span><br><span class="line">   &#125;</span><br><span class="line">   return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="常量命名">常量命名</h4>
<p>常量使用<strong>大写字母</strong> + 数字进行命名 。</p>
<p>正例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br></pre></td></tr></table></figure>
<p>反例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private static final int DefaultCapacity = 10;   </span><br><span class="line">private static final int Default_Capacity = 10;</span><br></pre></td></tr></table></figure>
<h4 id="方法命名">方法命名</h4>
<p>方法名称应该是一个动词短语（为了共识），不论public方法还是private方法，<strong>方法名称需要很好地反映方法功能本身。</strong></p>
<p>正例：</p>
<p>还是<code>DispatcherServlet</code>，私有方法较多，但通过名称可以很清楚地反映方法功能</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">initStragies(ApplicationContext); // Stragies说明该方法作用是初始化一系列策略</span><br><span class="line">initMultipartResolver(ApplicationContext);</span><br><span class="line">initLocaleResolver(ApplicationContext);</span><br><span class="line">initThemeResolver(ApplicationContext);</span><br><span class="line">initHandlerMappings(ApplicationContext);</span><br><span class="line">initHandlerAdapters(ApplicatonContext);</span><br><span class="line">initHandlerExceptionResolers(ApplicationContext);  </span><br><span class="line">initRequestToViewNameTranslator(ApplicatonContext); </span><br><span class="line">// 只要名称能合理的反映功能，不要担心方法过长</span><br><span class="line">...</span><br><span class="line">getDefaultStrategy(ApplicationContext, Class&lt;T&gt;);</span><br><span class="line">getDefaultStrategies(ApplicationContext, Class&lt;T&gt;);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这样的方法命名让读者就很舒服。</p>
<p>反例：方法职责不清晰造成方法名过长</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">// 接口定义</span><br><span class="line">public Map&lt;String, Obeject&gt; getUserInfoLoginInfoPasswordMap(Context context) &#123;</span><br><span class="line">  Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();  </span><br><span class="line">  ...</span><br><span class="line">  UserInfo user = xxx;</span><br><span class="line">  map.put(&quot;user&quot;, user);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  LoginInfo login = xxx;</span><br><span class="line">  map.put(&quot;login&quot;, login);</span><br><span class="line">  </span><br><span class="line">  ...</span><br><span class="line">  String password = xxx;</span><br><span class="line">  map.put(&quot;password&quot;, password);  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 客户端代码</span><br><span class="line">Map&lt;String, Obeject&gt; map = getUserInfoLoginInfoPasswordMap(context);</span><br><span class="line">map.get(&quot;user&quot;);</span><br><span class="line">map.get(&quot;login&quot;);</span><br><span class="line">map.get(&quot;login&quot;);</span><br></pre></td></tr></table></figure>
<p>只要命名合理，不要担心方法名称太长，但方法名称过长常常又意味着该方法干的事太多了，则需要思考是否可以拆分方法，上面这个例子不够典型，但也反映了一个设计原则，保证方法的职责单一，可以拆分成3个方法：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public UserInfo getUserInfo(Context context); </span><br><span class="line">public LoginInfo getLoginInfo(Context context); </span><br><span class="line">public String getPassword(Context context);</span><br></pre></td></tr></table></figure>
<p>如果方法实现会产生副作用（side effect），该副作用需要体现在方法名称。</p>
<p>反例：副作用未体现在方法名中</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private void checkPermission(User user) throws NoPermissionException&#123;</span><br><span class="line">   List&lt;Integer&gt; orgIds = orgService.getOrgIdsByUserId(user.getId());</span><br><span class="line">   if(CollectionUtils.isEmpty(orgIds) &#123;</span><br><span class="line">      throw new NoPermissionException(&quot;无权访问！&quot;);</span><br><span class="line">   &#125;;</span><br><span class="line">   </span><br><span class="line">   if(orgIds.contains(1)) &#123;</span><br><span class="line">      user.setOrgIds(orgIds);  // 包含副作用setOrgIds</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   throw new NoPermissionException(&quot;无权访问！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了体现方法名称可改成 fillOrgIdsAndCheckPermission。</p>
<p>反例：超长的方法名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; getByYearQuargerAndXXXXXXXXIdAndXXXXXConditionAndCityLevelList(YearQuarter yearQuarter, Integer XXXXXXXXId, XXXXXCondition condition, List&lt;Integer&gt; cityLevelList);</span><br></pre></td></tr></table></figure>
<p>方法名反映了入参却忽略了返回值。如果不存在方法重载，那么方法名无需通过入参进行区分但必须反映返回值，这样做的目的是：通过方法名称区分一个类的所有方法，因此，这个反例方法名可改成getXXXList（此外若入参超过4个，最好定义一个类对入参进行包装）。</p>
<h4 id="类命名">类命名</h4>
<p><strong>类名应该是名词，尽量保证类名简单且具有描述性，避免缩略语</strong>，如果使用到设计模式需要在类名中体现，目的是形成共识，帮助读者理解代码。</p>
<p>正例：List的实现类命名</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ArrayList  // 数组形式的List实现类</span><br><span class="line">LinkedList  // 链表形式的List实现类</span><br><span class="line">Stack  // 栈实现类，见名知意，说明是先进后出，后进先出的数据结构</span><br><span class="line">CopyOnWriteArrayList  // 说明是采用COW写时复制防并发策略的ArrayList</span><br><span class="line">FixedSizeList  // 固定了大小的的List</span><br><span class="line">SynchronizedList  // 使用Synchronized关键字控制的List,线程安全</span><br></pre></td></tr></table></figure>
<p>注：以上例子来自jdk、apache开源代码。</p>
<p>正例：使用了设计模式的类</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.beans.factory.BeanFactory // 简单工厂模式 </span><br><span class="line">org.eclipse.jetty.websocket.common.UpgradeRequestAdapter // 使用了适配器模式 </span><br><span class="line">org.apache.catalina.core.ThreadLocalLeakPreventionListener // 观察者模式 </span><br><span class="line">org.apache.naming.factory.webservices.ServiceProxy // 代理模式</span><br></pre></td></tr></table></figure>
<p>注：以上类来自Spring、jetty、tomcat。</p>
<h3 id="注释">注释</h3>
<p>注释有利于帮助理解代码，如果使用不当，反而会影响代码的简洁性，不利于理解代码。注释在使用上笔者认为需要坚持三个原则：</p>
<ol>
<li><strong>保持代码干净，消除不必要的注释</strong>：好的代码本身就是最好的注释，只在必要时通过注释协助理解代码，目的是保持代码的简洁性，增强代码的可读性；</li>
<li><strong>区分注释和<code>JavaDoc</code></strong>：类、域、方法使用<code>JavaDoc</code>，方法内部使用注释；</li>
<li>注释及时更新：注释也是代码的一部分，如果代码发生变更，注释也要跟着改；</li>
</ol>
<p>注释正例可通过《开发手册》作为参考，笔者更愿意通过一些反例告知读者哪些是错误的注释！</p>
<p>反例：加入过多的注释影响代码阅读</p>
<p>在系统开发中，笔者发现，代码有大片大片的注释，格式乱七八糟，笔者想强调一点：请把代码当成产品来看待，注意提交的代码一定要干净！可能有同学会反驳，注释掉的是代码，将来可能还需要还原，如果确实是这种情况，那么完全可以通过版本控制工具（git or svn）还原。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public String recommendGift(double budget) &#123;</span><br><span class="line">       // get gifts from helper</span><br><span class="line">       String[] gifts = giftHelper.getGifts();</span><br><span class="line">       String gift = null;</span><br><span class="line"></span><br><span class="line">       for (int i = 0; i &lt; gifts.length; i++) &#123;</span><br><span class="line">           gift = gifts[i];</span><br><span class="line"></span><br><span class="line">           // find out if gift already given</span><br><span class="line">           boolean isAlreadyGiven = false;</span><br><span class="line">           for (String given : giftsGiven) &#123;</span><br><span class="line">               if (gift.equals(given)) &#123;</span><br><span class="line">                   isAlreadyGiven = true;</span><br><span class="line">                   break;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           // calculate rating and budget</span><br><span class="line">           int x = rating * 200;</span><br><span class="line">           boolean ok = budget &lt; x;</span><br><span class="line"></span><br><span class="line">           // if both conditions satisfy, give it.</span><br><span class="line">           if (!isAlreadyGiven) &#123;</span><br><span class="line">               giftsGiven.add(gift);</span><br><span class="line">               // increment maintenance cost of the girlfriend</span><br><span class="line">               maintenanceCost += budget;</span><br><span class="line">               return gift;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       return gift;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果代码需要通过注释才能理解，这时可能就需要反思，是否是代码本身编写的问题，比如方法过长，试着重构（比如抽取方法、方法重命名等）。</p>
<p>修改后</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public String recommendGift(double budget) &#123;</span><br><span class="line">    String recommendedGift = null;</span><br><span class="line">    for (String gift : giftHelper.getGifts()) &#123;</span><br><span class="line">        recommendedGift = gift;</span><br><span class="line">        if (isGiftNotAlreadyGiven(recommendedGift) &amp;&amp; isUnderBudget(budget)) &#123;</span><br><span class="line">            updateMaintenanceCostAndGiftsGiven(budget, recommendedGift);</span><br><span class="line">            return recommendedGift;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return recommendedGift;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void updateMaintenanceCostAndGiftsGiven(double budget, String gift) &#123;</span><br><span class="line">    giftsGiven.add(gift);</span><br><span class="line">    maintenanceCost += budget;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean isUnderBudget(double budget) &#123;</span><br><span class="line">    int x = rating * 200;</span><br><span class="line">    boolean ok = budget &lt; x;</span><br><span class="line">    return ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean isGiftNotAlreadyGiven(String gift) &#123;</span><br><span class="line">    boolean isAlreadyGiven = true;</span><br><span class="line">    for (String given : giftsGiven) &#123;</span><br><span class="line">        if (gift.equals(given)) &#123;</span><br><span class="line">            isAlreadyGiven = false;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return isAlreadyGiven;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反例：<code>JavaDoc</code>和注释不分</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// User:xxxxx</span><br><span class="line">public class User &#123;</span><br><span class="line">	// 名字</span><br><span class="line">  private String name = &quot;George&quot;;</span><br><span class="line">	</span><br><span class="line">  // 获取全名</span><br><span class="line">  public String getFullName() &#123;</span><br><span class="line">     /** 家庭名字 **/</span><br><span class="line">     String familyName = &quot;Bush&quot;;</span><br><span class="line">     ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是<code>JavaDoc</code>，可参考《开发手册》注释章节部分强制规约：</p>
<blockquote>
<p>类、类属性、类方法的注释必须使用 Javadoc 规范，使用/*<em>内容</em>/格式，不得使用// xxx 方式；<br>
所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数；<br>
所有的类都必须添加创建者和创建日期；</p>
</blockquote>
<p>如果是注释，需要区分注释和解释：注释用于帮助理解业务流程，解释是说明这里为什么要这么做；注释用在方法内部单行注释，在被注释语句上方另起一行，解释紧跟代码之后，举个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">private User getLeader(Query query) &#123;</span><br><span class="line">   // 参数校验</span><br><span class="line">  checkParam(query);</span><br><span class="line">  </span><br><span class="line">   // 查询</span><br><span class="line">   List&lt;User&gt; users = xxManager.getUser(query);</span><br><span class="line">   if(CollectionUtils.isEmpty(users)) &#123;</span><br><span class="line">      return null;</span><br><span class="line">   &#125;</span><br><span class="line">   return users.get(0); // 第一个就是Leader </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解释用在比较特殊的业务上，替代方案是在领域内部单独提供一个方法，这样就不用解释了。</p>
<p>反例：代码发生变更，但注释没变</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 返回小于10的正整数</span><br><span class="line"> */</span><br><span class="line">public List&lt;Integer&gt; gePositiveIntegerGraterOrEqualsTen() &#123;</span><br><span class="line">   return Arrays.asList(1,2,3,4,5,6,7,8,9,10);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法第一版是返回小于10的正整数，后由于需求变更改成小于等于10的正整数，可是注释还是小于10，注释和方法实现不同步这让人感到很困惑。</p>
<h4 id="代码自解释">代码自解释</h4>
<p>注释是为了帮助理解代码，如果代码是自解释的（本身就具有很好的可读性），那么就无需添加注释了，这是最高境界，一般有三种做法：</p>
<ol>
<li><strong>合适的命名</strong>：包含变量、方法命名（前文已提）；</li>
<li>代码合理分段；</li>
<li><strong>代码是同一层面的抽象</strong>：一个方法的内部代码除了合理分段外，每一段都是同一业务层面的抽象，有助于读者理解代码；<strong>(MVC)</strong></li>
</ol>
<p>正例：将代码按照单一执行任务合理分段有利于增强可读性。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if(result.getStatus() != Status.OK)</span><br><span class="line">&#123; </span><br><span class="line">    throw new BusinessException();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">Context ctx = result.getContext(); </span><br><span class="line">ctx.beginTransaction();</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>以上是代码示例，<code>SpringMVC</code>包的<code>DispatcherServlet</code>中<code>doDispatch</code>方法可以很好地说明一个复杂处理逻辑分段的重要性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">		HttpServletRequest processedRequest = request;</span><br><span class="line">		HandlerExecutionChain mappedHandler = null;</span><br><span class="line">		boolean multipartRequestParsed = false;</span><br><span class="line"></span><br><span class="line">		WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);</span><br><span class="line"></span><br><span class="line">		try &#123;</span><br><span class="line">			ModelAndView mv = null;</span><br><span class="line">			Exception dispatchException = null;</span><br><span class="line"></span><br><span class="line">			try &#123;</span><br><span class="line">				processedRequest = checkMultipart(request);</span><br><span class="line">				multipartRequestParsed = processedRequest != request;</span><br><span class="line"></span><br><span class="line">				// Determine handler for the current request.</span><br><span class="line">				mappedHandler = getHandler(processedRequest, false);</span><br><span class="line">				if (mappedHandler == null || mappedHandler.getHandler() == null) &#123;</span><br><span class="line">					noHandlerFound(processedRequest, response);</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				// Determine handler adapter for the current request.</span><br><span class="line">				HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</span><br><span class="line"></span><br><span class="line">				// Process last-modified header, if supported by the handler.</span><br><span class="line">				String method = request.getMethod();</span><br><span class="line">				boolean isGet = &quot;GET&quot;.equals(method);</span><br><span class="line">				if (isGet || &quot;HEAD&quot;.equals(method)) &#123;</span><br><span class="line">					long lastModified = ha.getLastModified(request, mappedHandler.getHandler());</span><br><span class="line">					if (logger.isDebugEnabled()) &#123;</span><br><span class="line">						logger.debug(&quot;Last-Modified value for [&quot; + getRequestUri(request) + &quot;] is: &quot; + lastModified);</span><br><span class="line">					&#125;</span><br><span class="line">					if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;</span><br><span class="line">						return;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;</span><br><span class="line">					return;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				try &#123;</span><br><span class="line">					// Actually invoke the handler.</span><br><span class="line">					mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</span><br><span class="line">				&#125;</span><br><span class="line">				finally &#123;</span><br><span class="line">					if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">						return;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				applyDefaultViewName(request, mv);</span><br><span class="line">				mappedHandler.applyPostHandle(processedRequest, response, mv);</span><br><span class="line">			&#125;</span><br><span class="line">			catch (Exception ex) &#123;</span><br><span class="line">				dispatchException = ex;</span><br><span class="line">			&#125;</span><br><span class="line">			processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Exception ex) &#123;</span><br><span class="line">			triggerAfterCompletion(processedRequest, response, mappedHandler, ex);</span><br><span class="line">		&#125;</span><br><span class="line">		catch (Error err) &#123;</span><br><span class="line">			triggerAfterCompletionWithError(processedRequest, response, mappedHandler, err);</span><br><span class="line">		&#125;</span><br><span class="line">		finally &#123;</span><br><span class="line">			if (asyncManager.isConcurrentHandlingStarted()) &#123;</span><br><span class="line">				// Instead of postHandle and afterCompletion</span><br><span class="line">				mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);</span><br><span class="line">				return;</span><br><span class="line">			&#125;</span><br><span class="line">			// Clean up any resources used by a multipart request.</span><br><span class="line">			if (multipartRequestParsed) &#123;</span><br><span class="line">				cleanupMultipart(processedRequest);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>正例：代码是同一层面的抽象</p>
<p>以<code>SpringMVC</code>包的<code>DispatcherServlet</code>中<code>initStrategies</code>方法举例</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">      /**</span><br><span class="line"> * Initialize the strategy objects that this servlet uses.</span><br><span class="line"> * &lt;p&gt;May be overridden in subclasses in order to initialize further strategy objects.</span><br><span class="line"> */</span><br><span class="line">protected void initStrategies(ApplicationContext context) &#123;</span><br><span class="line">	initMultipartResolver(context);</span><br><span class="line">	initLocaleResolver(context);</span><br><span class="line">	initThemeResolver(context);</span><br><span class="line">	initHandlerMappings(context);</span><br><span class="line">	initHandlerAdapters(context);</span><br><span class="line">	initHandlerExceptionResolvers(context);</span><br><span class="line">	initRequestToViewNameTranslator(context);</span><br><span class="line">	initViewResolvers(context);</span><br><span class="line">	initFlashMapManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>initStrategies方法是DispatcherServlet这个类初始化策略的主流程，内部调用的是同一抽象层面的方法，且各个方法做到见名知意，这种清晰的代码结构我想就无需再注释了吧。</p>
<h4 id="无用注释">无用注释</h4>
<p>在日常代码中有一些滑稽的没有意义的注释。</p>
<p>反例：没有必要的注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 最大大小</span><br><span class="line"> */</span><br><span class="line">private static final int MAX_SIZE = 10;</span><br><span class="line"></span><br><span class="line">if(a == 5) &#123;  // 如果a等于5</span><br><span class="line">   counter = 0;  // 把counter设置成0</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>请不要侮辱阅读者的智商，这种注释请问到底有什么用！</p>
<p>反例：没有礼貌的注释</p>
<p>还记得前两年某视频网站在js代码注释中注释了“屌丝VIP”字样在网上被喷的事件，尊重别人才能赢得别人的尊重，应避免没有礼貌的侮辱性的注释。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 屌丝VIP</span><br><span class="line">if( user.getVipType() = xxx)</span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">// 要注意一些愚蠢的用户会输入一个负数</span><br><span class="line">...</span><br><span class="line">  </span><br><span class="line">// 修正由菜鸟工程师写的愚蠢得可怜的代码而导致的副作用</span><br><span class="line">...  </span><br></pre></td></tr></table></figure>
<p>这样的注释对于代码的写注释的人来说并没有任何好处，同时你永远都不会知道将来这些注释会被谁来阅读，你的老板、一个客户或者是刚才被你数落的愚蠢得可怜的工程师。</p>
<p>反例：过期的代码注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">   public static void main(String[] args) </span><br><span class="line">  &#123;</span><br><span class="line">     /* This block of code is no longer needed</span><br><span class="line">      * because we found out that Y2K was a hoax</span><br><span class="line">      * and our systems did not roll over to 1/1/1900 </span><br><span class="line">      */</span><br><span class="line">      //DateTime today = DateTime.Today;</span><br><span class="line">      //if (today == new DateTime(1900, 1, 1))</span><br><span class="line">      //&#123;</span><br><span class="line">      // today = today.AddYears(100);</span><br><span class="line">      // String message = &quot;The date has been fixed for Y2K.&quot;;</span><br><span class="line">      // System.out.println(message);</span><br><span class="line">      //&#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>“万一我们下次还要用到它呢“，每听到这样的解释我真心无语。无效代码注释本章节开头已说明，请删除无效的代码注释！需还原请通过版本控制工具还原！</strong></p>
<p>反例：故事性（代码不相关）注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 张三叫我这么做，如果有不懂的，你可以去问他。</span><br></pre></td></tr></table></figure>
<p>如果是一个局外人或一个新人，这种注释没有任何用，除了他俩知道外（业务过了一段时间他俩也忘了为什么这么做），对其他人提供不了任何有价值的信息。如果你不得不在你的代码注释中提及需求，那也不应该提及人名。在上面的示例中，好像程序想要告诉其它程序员，这根本没有必要在注释中提到一些和代码不相干的事。可能有人会狡辩，我还是必须这样写注释，原因有二：</p>
<ol>
<li>有时候，那些所谓的“高手”逼着我这么干，所以，我要把他的名字放在这里让所有人看看他有多SB。</li>
<li>有时候，我对需求并不了解，我们应该放一个联系人在在这里，以便你可以去询问之。</li>
</ol>
<p>对于第一点，正确的做法沟通解决问题，说明清楚为什么不能这么去做；如果非得这么干，那么好请发邮件告知或在文档中备注。不要在代码中写这样的注释；对于第二点，应该将联系人写在需求文档中。</p>
<p>反例：没有意义的注释</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// Sorry,这段代码写得不好，请多见谅</span><br></pre></td></tr></table></figure>
<p>很明显，程序员已经意识到代码的问题，这样的注释除了为自己的懒惰开脱外，不知道还有什么用！</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">// 勿动这块代码！！！ 如果需要改动，请不要影响到张三和李四的代码</span><br></pre></td></tr></table></figure>
<p>这种也是很无语的注释，当需要这样注释时，代码到底有多不可维护呀！</p>
<p>此外还有多年的TODO注释也是需要消灭的。</p>
<p>注释章节就写到这，希望对你有帮助。</p>
<h3 id="常量">常量</h3>
<p>常量是用final修饰符修饰的不可变数值基础类型（或数值类型），本节可讨论话题不多，笔者想强调4点：</p>
<ol>
<li><strong>在工程中不要使用一个常量类维护所有常量。</strong></li>
<li><strong>常量类请加修饰符final以表示他是不可继承的。</strong></li>
<li><strong>合理地放置常量类，即区分是类内部常量，还是包内常量，还是是整个工程常量。</strong></li>
<li><strong>几个具有相关性的常量（比如type，state）请使用枚举。</strong></li>
</ol>
<p>下面针对第一点，第三点说明：</p>
<p>反例：在工程中使用一个常量类维护所有常量</p>
<p>笔者曾见过很多老工程使用一个<code>SystemConsts</code>包含系统内定义的所有常量，在不断迭代后，多数类似<code>SystemConsts</code>这种类定义的常量常常是100+（注释至少都是300行+），面对几百行的常量，维护会特别麻烦：即使是老手，有时你还是不清楚到底有没有定义过该常量，如果定义过，那么很可能你需要花点时间去找是哪个常量，如果关键字搜索不对，那么很可能这个时间成本还不低；如果不凑巧关键字没找到，那么你得重新定义一个，但很可能出现常量重复定义，当需求发生变更时，<code>diamante</code>改动特别容易出现遗漏，引发bug。</p>
<p>正确的做法是：</p>
<ul>
<li>按功能分类，比如：缓存相关常量放在<code>CacheConsts</code>下，系统配置类常量放在<code>ConfigConsts</code>下；</li>
<li>按业务划分，如果是在指定范围取值的常量，需要替换成枚举；</li>
</ul>
<p>反例：不合适地放置常量类</p>
<p>易懂变量也要统一定义成应用内共享常量，两位程序员在两个类中分别定义了表示 “是”的变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类 A</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YES = <span class="string">&quot;yes&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类 B</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String YES = <span class="string">&quot;y&quot;</span>;</span><br><span class="line"></span><br><span class="line">A.YES.equals(B.YES)，</span><br></pre></td></tr></table></figure>
<p>预期是 true，但实际返回为 false，导致线上问题。</p>
<p>合理地放置常量类，正确的做法是：</p>
<ul>
<li>跨应用共享常量，放在准备提供给外部jar包所在module的<code>consts</code>目录；</li>
<li>工程内共享常量，放在工程common module下<code>consts</code>目录；</li>
<li>子模块内部共享，在相应子模块<code>consts</code>目录；</li>
<li>类内共享，放在类内部，注意加private进行限定；</li>
</ul>
<p>常量章节就写到这。</p>
<h3 id="异常处理"><strong>异常处理</strong></h3>
<p>在介绍异常处理规范之前，实在有必要了解Java的异常体系，什么时候使用受检异常，什么时候使用非受检异常。</p>
<ul>
<li><strong>Java异常体系：</strong><br>
在 Java 中，所有的异常都有一个共同的祖先 Throwable（可抛出）。**Throwable 指定代码中可用异常传播机制通过 Java 应用程序传输的任何问题的共性。**Throwable 有两个重要的子类：Exception（异常）和 Error（错误），二者都是 Java 异常处理的重要子类，各自都包含大量子类。<strong>Exception（异常）是应用程序中可能的可预测、可恢复问题。一般大多数异常表示中度到轻度的问题。<strong>异常一般是在特定环境下产生的，通常出现在代码的特定方法和操作中。在<code> EchoInput</code> 类中，当试图调用 <code>readLine </code>方法时，可能出现 <code>IOException </code>异常。<br>
<strong>Error（错误）表示运行应用程序中较严重问题</strong>。<strong>大多数错误与代码编写者执行的操作无直接关系，而表示代码运行时 JVM（Java 虚拟机）出现的问题</strong>。例如，当 JVM 不再有继续执行操作所需的内存资源时，将出现 <code>OutOfMemoryError</code>。<br>
Exception 类有一个重要的子类 <code>RuntimeException</code>。</strong><code>RuntimeException </code>类及其子类表示“JVM 常用操作”引发的错误</strong>。例如，若试图使用空值对象引用、除数为零或数组越界，则分别引发运行时异常（<code>NullPointerException</code>、<code>ArithmeticException</code>）和 <code>ArrayIndexOutOfBoundException</code>。</li>
<li><strong>受检异常：</strong><br>
**可检测异常经编译器验证，对于声明抛出异常的任何方法，编译器将强制执行处理(解决这个异常)或声明规则，**例如：<code>sqlExecption</code> 这个异常就是一个检测异常。你连接 JDBC 时，不捕捉这个异常，编译器就通不过，不允许编译。<strong>受检异常可预知可能出问题，必须处理</strong>。</li>
<li><strong>非检测异常：</strong><br>
<strong>非检测异常不遵循处理或声明规则。在产生此类异常时，不一定非要采取任何适当操作</strong>，编译器不会检查是否已解决了这样一个异常。例如：一个数组为 3 个长度，=E5__你使用下标为３时，就会产生数组下标越界异常。这个异常 JVM 不会进行检测，要靠程序员来判断。有两个主要类定义非检测异常：<code>RuntimeException </code>和 Error。<br>
Error 子类属于非检测异常，因为无法预知它们的产生时间。若 Java 应用程序内存不足，则随时可能出现 <code>OutOfMemoryError</code>；起因一般不是应用程序的特殊调用，而是 JVM 自身的问题。另外，Error 一般表示应用程序无法解决的严重问题。Error子类是非受检异常另一个原因是应用程序根本无法处理。<br>
<code>RuntimeException</code> 类也属于非检测异常，因为普通 JVM 操作引发的运行时异常随时可能发生，此类异常一般是由特定操作引发。但这些操作在 Java 应用程序中会频繁出现。因此，它们不受编译器检查与处理或声明规则的限制。</li>
<li><strong>封装一个API的时候什么情况下抛出异常</strong><br>
如果调用方可以从异常中采取措施进行恢复的，就使用checked exception，如果客户什么也做不了，就用unchecked exception。这里的措施指的是，不仅仅是记录异常，还要采取措施来恢复。</li>
</ul>
<p>Java异常机制是为了在异常情况设计的，在日常开发中不合理使用异常、乱用异常的情况还是很常见，我们有必要重新梳理异常的使用，做到正确使用。</p>
<p><strong>异常处理不能作为正常控制流(能不用异常就不要用）</strong></p>
<p>反例：将异常处理应用于普通控制流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"> int i = 0;</span><br><span class="line"> while(true)&#123;</span><br><span class="line">    range[i++].climb(); </span><br><span class="line"> &#125;</span><br><span class="line">&#125; </span><br><span class="line">catch(ArrayIndexOutOfBoundsException e)&#123;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>上面程序通过异常捕获结束循环进而完成数据的遍历，殊不知异常模式比标准模式要慢很多（很可能2倍以上），且正常的逻辑通过这种异常方式让人费解，代码的可读性较差。</strong></p>
<p>以上代码完全可以采用正常的控制逻辑</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(Mountain m : range) &#123;</span><br><span class="line"> m.climb();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>又比如：状态测试相关的的类应该提前进行状态测试，不应该通过异常机制作为控制流</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Iterator&lt;Foo&gt; it = collection.iterator();</span><br><span class="line">while(it.hasNext())&#123;</span><br><span class="line"> Foo foo = it.next();</span><br><span class="line">      ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而非：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line"> Iterator&lt;Foo&gt; it = collection.iterator();</span><br><span class="line"> while(true)&#123;</span><br><span class="line"> Foo foo = it.next();</span><br><span class="line">      ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125; </span><br><span class="line">catch(NoSuchElementException e)&#123;     </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总之，异常应该只用于异常的情况下，他们永远不应该用于正常的控制流，良好的API也不应该强迫他们的客户端为了正常的控制流而使用异常。对于可以规避的RuntimeException类异常，应该提前做检查。</p>
<p><strong>优先使用标准异常</strong></p>
<p>技术专家和普通程序员的区别在于：技术专家追求并且也能够实现高度的代码重用。对于异常也不例外，jdk提供了一组未受检异常（RuntimeException）,他们已经能够满足绝大部分API的异常抛出需要，完全没必要自己再写一个异常实现。</p>
<p>常见可重用异常如下：</p>
<ul>
<li>NullPointException空指针，在禁止使用null的情况下使- null</li>
<li>IllegalArgumentException 参数非法，非null的参数值不正确</li>
<li>IllegalStateException 状态非法，对象状态不合适</li>
<li>IndexOfBoundException 下标参数值越界</li>
<li>ConcurrentModificationException 在禁止并发修改情况下，检测到对象的并发修改</li>
<li>UnsupportedOperationException对象不支持该方法调用</li>
</ul>
<p>重用现有异常有如下好处：</p>
<ol>
<li>它能使你的API更易于学习和使用，因为大家都知道这些异常意味着啥；</li>
<li>客户端处理异常的代码可读性也能变强；</li>
</ol>
<p><strong>非受检异常和受检异常</strong>(这个比较重要)</p>
<p>非受检异常：即<code>RuntimeException</code>，应用于未按照API约定错误调用导致的异常，或程序实现自身错误导致的异常，如<code>IndexOutOfBoundExcetion</code>、<code>IllegalArgumentException</code>等；<strong>非受检异常本质上希望终止线程</strong>。</p>
<p>受检异常：应用于程序正确，但由于操作系统原因、网络原因导致的异常，如<code>IOException</code>、<code>ConnectExption</code>、<code>FileNotFountException</code>等，这类异常是可恢复的，必须在编译时明确告知客户端必须处理该类异常，大大增强了系统的可靠性。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">ZWN</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwn2001.github.io/2021/11/17/%E5%AD%A6%E7%BA%BF%E7%A7%BB%E5%8A%A8%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BE%8B%E4%BC%9A/">https://zwn2001.github.io/2021/11/17/%E5%AD%A6%E7%BA%BF%E7%A7%BB%E5%8A%A8%E7%AC%AC%E4%B8%80%E6%AC%A1%E4%BE%8B%E4%BC%9A/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://ZWN2001.github.io" target="_blank">ZWN's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD/">学线培训</a></div><div class="post_share"><div class="social-share" data-image="/img/default_top_img/44.jpg" data-sites="wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/11/29/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%AE%9E%E9%AA%8C%E5%85%AD%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E6%BA%90%E7%A0%81/"><img class="prev-cover" src="/img/default_top_img/3.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">数据结构实验六：二叉树源码</div></div></a></div><div class="next-post pull-right"><a href="/2021/11/06/web%E8%B8%A9%E5%9D%91%E6%B1%87%E6%80%BB/"><img class="next-cover" src="/img/default_top_img/38.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">web踩坑汇总</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2021/09/30/%E5%AD%A6%E7%BA%BFoj%E6%80%9D%E8%B7%AF%E8%AE%B2%E8%A7%A3/" title="学线oj思路讲解"><img class="cover" src="/img/default_top_img/22.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-09-30</div><div class="title">学线oj思路讲解</div></div></a></div><div><a href="/2021/10/07/%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%E4%B8%8EMaterialDesign%E5%9F%BA%E7%A1%80%E5%8E%9F%E5%88%99/" title="设计原则与MaterialDesign基础原则"><img class="cover" src="/img/default_top_img/6.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-07</div><div class="title">设计原则与MaterialDesign基础原则</div></div></a></div><div><a href="/2021/12/09/%E5%AD%A6%E7%BA%BF%E7%A7%BB%E5%8A%A8%E4%BE%8B%E4%BC%9A%EF%BC%9Agit/" title="学线移动例会：git"><img class="cover" src="/img/default_top_img/39.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-12-09</div><div class="title">学线移动例会：git</div></div></a></div><div><a href="/2021/10/11/%E7%AC%AC%E4%B8%89%E6%AC%A1%E5%9F%B9%E8%AE%AD%EF%BC%9A%E7%BD%91%E7%BB%9C%E9%83%A8%E5%88%86/" title="第三次培训：网络部分"><img class="cover" src="/img/default_top_img/16.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-11</div><div class="title">第三次培训：网络部分</div></div></a></div><div><a href="/2021/10/27/%E7%BD%91%E7%BB%9C%E7%9A%84%E5%BC%82%E6%AD%A5/" title="网络的异步与okhttp"><img class="cover" src="/img/default_top_img/3.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-27</div><div class="title">网络的异步与okhttp</div></div></a></div><div><a href="/2022/01/07/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD-winter-flutter-1/" title="学线培训:winter-flutter-1"><img class="cover" src="/img/default_top_img/11.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-01-07</div><div class="title">学线培训:winter-flutter-1</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div class="vcomment" id="vcomment"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">ZWN</div><div class="author-info__description">我虽无意逐鹿，却知苍生苦楚</div></div><div class="card-info-data"><div class="card-info-data-item is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div><div class="card-info-data-item is-center"><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a></div><div class="card-info-data-item is-center"><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div></div><a class="button--animated" id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/ZWN2001"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZWN2001" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">ZWN的新博客站</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">学线移动第一次培训</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E4%BD%9C%E4%B8%9A%E7%82%B9%E8%AF%84"><span class="toc-number">1.1.</span> <span class="toc-text">1.作业点评</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E7%BB%86%E8%AF%B4MVC%E6%9E%B6%E6%9E%84%E4%B8%8E%E9%A1%B9%E7%9B%AE%E5%88%86%E5%8C%85"><span class="toc-number">1.2.</span> <span class="toc-text">2.细说MVC架构与项目分包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BE%9D%E8%B5%96%E5%85%B3%E7%B3%BB"><span class="toc-number">1.2.2.</span> <span class="toc-text">依赖关系</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%98%E7%82%B9"><span class="toc-number">1.2.3.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AF%84%E4%BB%B7%E3%80%81%E8%AF%AF%E8%A7%A3%E5%8F%8A%E9%80%82%E7%94%A8%E8%8C%83%E5%9B%B4"><span class="toc-number">1.2.4.</span> <span class="toc-text">评价、误解及适用范围</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">1.2.5.</span> <span class="toc-text">MVC的不足</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E9%99%85%E6%83%85%E5%86%B5"><span class="toc-number">1.2.6.</span> <span class="toc-text">实际情况</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83"><span class="toc-number">1.3.</span> <span class="toc-text">3.代码规范</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%91%BD%E5%90%8D"><span class="toc-number">1.3.1.</span> <span class="toc-text">命名</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%98%E9%87%8F%E5%91%BD%E5%90%8D"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">变量命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F%E5%91%BD%E5%90%8D"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">常量命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E5%91%BD%E5%90%8D"><span class="toc-number">1.3.1.3.</span> <span class="toc-text">方法命名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%B1%BB%E5%91%BD%E5%90%8D"><span class="toc-number">1.3.1.4.</span> <span class="toc-text">类命名</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.2.</span> <span class="toc-text">注释</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%87%AA%E8%A7%A3%E9%87%8A"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">代码自解释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%97%A0%E7%94%A8%E6%B3%A8%E9%87%8A"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">无用注释</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%B8%E9%87%8F"><span class="toc-number">1.3.3.</span> <span class="toc-text">常量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86"><span class="toc-number">1.3.4.</span> <span class="toc-text">异常处理</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/01/17/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD%EF%BC%9Awinter-flutter%EF%BC%9AMethodChannel%E4%B8%8E%E6%A1%8C%E9%9D%A2%E7%BB%84%E4%BB%B6/" title="学线培训：winter-flutter：PlatformChannel与桌面组件"><img src="/img/default_top_img/46.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="学线培训：winter-flutter：PlatformChannel与桌面组件"/></a><div class="content"><a class="title" href="/2022/01/17/%E5%AD%A6%E7%BA%BF%E5%9F%B9%E8%AE%AD%EF%BC%9Awinter-flutter%EF%BC%9AMethodChannel%E4%B8%8E%E6%A1%8C%E9%9D%A2%E7%BB%84%E4%BB%B6/" title="学线培训：winter-flutter：PlatformChannel与桌面组件">学线培训：winter-flutter：PlatformChannel与桌面组件</a><time datetime="2022-01-17T10:02:27.000Z" title="发表于 2022-01-17 18:02:27">2022-01-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE-%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%AF%91%E7%A0%81/" title="数据结构课设:霍夫曼编码译码"><img src="/img/default_top_img/27.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="数据结构课设:霍夫曼编码译码"/></a><div class="content"><a class="title" href="/2022/01/14/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%BE%E8%AE%BE-%E9%9C%8D%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%E8%AF%91%E7%A0%81/" title="数据结构课设:霍夫曼编码译码">数据结构课设:霍夫曼编码译码</a><time datetime="2022-01-14T12:15:16.000Z" title="发表于 2022-01-14 20:15:16">2022-01-14</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/13/advanced-Python/" title="Python进阶语法记录-OOP、IO、Exception与网络"><img src="/img/default_top_img/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python进阶语法记录-OOP、IO、Exception与网络"/></a><div class="content"><a class="title" href="/2022/01/13/advanced-Python/" title="Python进阶语法记录-OOP、IO、Exception与网络">Python进阶语法记录-OOP、IO、Exception与网络</a><time datetime="2022-01-13T14:02:52.000Z" title="发表于 2022-01-13 22:02:52">2022-01-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/11/basic-Python/" title="Python基础语法记录"><img src="/img/default_top_img/22.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python基础语法记录"/></a><div class="content"><a class="title" href="/2022/01/11/basic-Python/" title="Python基础语法记录">Python基础语法记录</a><time datetime="2022-01-11T03:11:49.000Z" title="发表于 2022-01-11 11:11:49">2022-01-11</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/01/10/mix-code-flutter-cpp%EF%BC%9A%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/" title="mix-code_flutter-cpp"><img src="/img/default_top_img/7.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="mix-code_flutter-cpp"/></a><div class="content"><a class="title" href="/2022/01/10/mix-code-flutter-cpp%EF%BC%9A%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91/" title="mix-code_flutter-cpp">mix-code_flutter-cpp</a><time datetime="2022-01-10T08:02:05.000Z" title="发表于 2022-01-10 16:02:05">2022-01-10</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022 By ZWN</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">喵喵喵？</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex@latest/dist/contrib/copy-tex.css"><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function loadValine () {
  function initValine () {
    const valine = new Valine(Object.assign({
      el: '#vcomment',
      appId: '',
      appKey: '',
      placeholder: 'Please leave your footprints',
      avatar: 'monsterid',
      meta: 'nick,mail,link'.split(','),
      pageSize: '10',
      lang: 'en',
      recordIP: false,
      serverURLs: '',
      emojiCDN: '',
      emojiMaps: "",
      enableQQ: false,
      path: window.location.pathname,
      requiredFields: ["nick,mail"],
      visitor: false
    }, null))
  }

  if (typeof Valine === 'function') initValine() 
  else getScript('https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js').then(initValine)
}

if ('Valine' === 'Valine' || !true) {
  if (true) btf.loadComment(document.getElementById('vcomment'),loadValine)
  else setTimeout(loadValine, 0)
} else {
  function loadOtherComment () {
    loadValine()
  }
}</script></div><div class="app-refresh" id="app-refresh"> <div class="app-refresh-wrap"> <label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" onclick="location.reload()">点击刷新</a> </div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"点击刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",function(){showNotification()}),window.addEventListener("load",function(){navigator.serviceWorker.register("/sw.js")}));</script><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = true;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>