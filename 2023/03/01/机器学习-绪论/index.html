<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>机器学习-绪论 | ZWN's blog</title><meta name="author" content="洛雪"><meta name="copyright" content="洛雪"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="绪论 机器学习的定义 人可以通过经验学习，比方说“朝霞不出门，晚霞行千里”，就是通过经验得来的知识。获得知识后，即使在不同的地点，不同的时间，看到不同的霞，我们也能作出正确的判断。那么，机器是否也能学习并利用经验，从而对一些未出现过的情况，在不通过显式编程（人作出判断并告诉机器）的情况下也能作出正确的预测呢？答案是可以的，这就是机器学习。 对于机器来说，经验是通过数据传达的。机器学习的主要研究内容">
<meta property="og:type" content="article">
<meta property="og:title" content="机器学习-绪论">
<meta property="og:url" content="https://zwn2001.space/2023/03/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BB%AA%E8%AE%BA/index.html">
<meta property="og:site_name" content="ZWN&#39;s blog">
<meta property="og:description" content="绪论 机器学习的定义 人可以通过经验学习，比方说“朝霞不出门，晚霞行千里”，就是通过经验得来的知识。获得知识后，即使在不同的地点，不同的时间，看到不同的霞，我们也能作出正确的判断。那么，机器是否也能学习并利用经验，从而对一些未出现过的情况，在不通过显式编程（人作出判断并告诉机器）的情况下也能作出正确的预测呢？答案是可以的，这就是机器学习。 对于机器来说，经验是通过数据传达的。机器学习的主要研究内容">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://zwn2001.space/img/cover3/20-min.jpg">
<meta property="article:published_time" content="2023-03-01T13:10:02.000Z">
<meta property="article:modified_time" content="2023-06-01T00:05:11.725Z">
<meta property="article:author" content="洛雪">
<meta property="article:tag" content="机器学习">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://zwn2001.space/img/cover3/20-min.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://zwn2001.space/2023/03/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BB%AA%E8%AE%BA/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="manifest" href="/pwa/manifest.json"/><link rel="apple-touch-icon" sizes="180x180" href="/pwa/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/pwa/32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/pwa/16.png"/><link rel="mask-icon" href="/pwa/safari-pinned-tab.svg" color="#5bbad5"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"top_n_per_article":-1,"unescape":false,"languages":{"hits_empty":"找不到您查询的内容：${query}","hits_stats":"共找到 ${hits} 篇文章"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  noticeOutdate: {"limitDay":500,"position":"top","messagePrev":"距离上次更新已经过去","messageNext":"天啦！注意内容可能过时。"},
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":300},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: true,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '机器学习-绪论',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-06-01 08:05:11'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
    win.getCSS = (url,id = false) => new Promise((resolve, reject) => {
      const link = document.createElement('link')
      link.rel = 'stylesheet'
      link.href = url
      if (id) link.id = id
      link.onerror = reject
      link.onload = link.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        link.onload = link.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(link)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/transpancy.css"><link rel="stylesheet" href="/css/iconfont.css"><link rel="stylesheet" href="/css/rightmenu.css"><link rel="stylesheet" href="/css/loadimg.css"><link rel="stylesheet" href="/css/project.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 5.4.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" src="/img/favicon.png"/><div class="loading-image-dot"></div><div id="loading-percentage"></div></div></div><script>const loadingPercentage = document.getElementById("loading-percentage");
loadingPercentage.style.color = "black";
let loadingPercentageTimer = setInterval(function() {
  var progressBar = document.querySelector(".pace-progress");
  if (!progressBar) return
  var currentValue = progressBar.getAttribute("data-progress-text");
  if (currentValue !== loadingPercentage.textContent) {
    loadingPercentage.textContent = currentValue;
    if ( currentValue === "60%") {
      clearInterval(loadingPercentageTimer);
    }
  }
}, 100);
const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/favicon.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('/img/cover3/20-min.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="ZWN's blog"><span class="site-name">ZWN's blog</span></a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">机器学习-绪论</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-01T13:10:02.000Z" title="发表于 2023-03-01 21:10:02">2023-03-01</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-06-01T00:05:11.725Z" title="更新于 2023-06-01 08:05:11">2023-06-01</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0-%E8%AF%BE%E5%86%85%E7%9F%A5%E8%AF%86/">学习-课内知识</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">10.9k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>33分钟</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1>绪论</h1>
<h2 id="机器学习的定义">机器学习的定义</h2>
<p>人可以通过经验学习，比方说“朝霞不出门，晚霞行千里”，就是通过经验得来的知识。获得知识后，即使在不同的地点，不同的时间，看到不同的霞，我们也能作出正确的判断。那么，机器是否也能学习并利用经验，从而对一些未出现过的情况，在不通过显式编程（人作出判断并告诉机器）的情况下也能作出正确的预测呢？答案是可以的，这就是<strong>机器学习</strong>。</p>
<p>对于机器来说，<strong>经验</strong>是通过<strong>数据</strong>传达的。机器学习的主要研究内容就是从数据中产生<strong>模型</strong>的算法，也即<strong>学习算法</strong>。Mitchell给出一个更为形式化的定义，假设我们用P来表示程序处理任务T时的性能，如果程序通过利用经验E提高了在任务T上的性能，则称该程序对E进行了学习。</p>
<p>在本书中，<strong>模型</strong>泛指所有从数据中学得的结果，在别的文献中，也有对<strong>模型</strong>和<strong>模式</strong>作出区分的，模型指学得的全局性结果（比如一棵决策树），模式指学得的局部性结果（比如一条规则）。</p>
<p>另一本经典教材的作者Mitchell给出了一个形式化的定义，假设：</p>
<ul>
<li>P：计算机程序在某任务类T上的性能。</li>
<li>T：计算机程序希望实现的任务类。</li>
<li>E：表示经验，即历史的数据集。</li>
</ul>
<p>若该计算机程序通过利用经验E在任务T上获得了性能P的改善，则称该程序对E进行了学习。</p>
<p> </p>
<h2 id="基本概念">基本概念</h2>
<p>要进行机器学习，首先要有数据，我们可以收集一组结构相同的记录，这组记录的集合就称为<strong>数据集</strong>。比如下面这个西瓜数据集：</p>
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">色泽</th>
<th style="text-align:center">根蒂</th>
<th style="text-align:center">敲声</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">青绿</td>
<td style="text-align:center">蜷缩</td>
<td style="text-align:center">浊响</td>
</tr>
<tr>
<td style="text-align:center">002</td>
<td style="text-align:center">乌黑</td>
<td style="text-align:center">稍蜷</td>
<td style="text-align:center">沉闷</td>
</tr>
<tr>
<td style="text-align:center">003</td>
<td style="text-align:center">浅白</td>
<td style="text-align:center">硬挺</td>
<td style="text-align:center">清脆</td>
</tr>
</tbody>
</table>
<p><strong>注</strong>：实际使用数据时往往需要先进行编码，即把文本改为数值（比如青绿=1，乌黑=2，等等），以便计算机进行处理。</p>
<p>接下来给出一些基本概念的定义：</p>
<h3 id="示例-instance-，样本-sample">示例(instance)，样本(sample)</h3>
<blockquote>
<p><strong>数据集中的每条记录是对一个事件或对象（比如这里的西瓜）的描述，也称作示例或者样本</strong>。特别地，有时会把整个数据集称为一个样本，因为数据集可以看作是从样本空间中抽样所得。这时候就需要根据上下文信息来进行判断了。</p>
</blockquote>
<h3 id="属性-attribute-，特征-feature-，属性值-attribute-value">属性(attribute)，特征(feature)，属性值(attribute value)</h3>
<blockquote>
<p><strong>对象具备一些性质，并由此可以进行区分，这些性质就称为属性或者特征</strong>，比方说表格中的色泽、根蒂和敲声。不同对象在这些属性上会有不同的取值，这个取值就称为属性值。</p>
</blockquote>
<h3 id="属性空间-attribute-space-，样本空间-sample-space-，输入空间，特征向量-feature-vector">属性空间(attribute space)，样本空间(sample space)，输入空间，特征向量(feature vector)</h3>
<blockquote>
<p><strong>由属性张成的空间</strong>，比方说上面的表格中有3个属性，那就可以张成一个3维空间，<strong>每个样本都可以用空间中的一个点来表示，这个点对应于一个坐标向量，所以有时也把一个样本称为一个特征向量</strong>。</p>
</blockquote>
<h3 id="维数-dimensionality">维数(dimensionality)</h3>
<blockquote>
<p>即<strong>数据集中每个样本拥有的特征数目</strong>。</p>
</blockquote>
<h3 id="学习-learning-，训练-training-，训练样本-training-sample-，训练示例-training-instance">学习(learning)，训练(training)，训练样本(training sample)，训练示例(training instance)</h3>
<blockquote>
<p><strong>从数据中获的模型的过程</strong>。在这个过程中使用的数据称为训练数据，里面的每个样本称为一个训练样本，也称训练示例或训练例。训练样本的集合就是训练集。</p>
</blockquote>
<h3 id="模型-model-，学习器-learner-，假设-hypothesis-，真相-ground-truth">模型(model)，学习器(learner)，假设(hypothesis)，真相(ground-truth)</h3>
<blockquote>
<p>模型有时也称为学习器，可以看作一组参数的有序集合，能够把属性空间映射到输出空间上。每一个模型对应于一个假设，也即数据存在的某种规律。真相指的是真正存在的规律，学习就是为了接近真相。</p>
</blockquote>
<p>如果我们希望通过机器学习来实现预测(prediction)，那么只有样本是不够的，要让机器明白怎样的样本会产生怎样的结果，还需要为每个样本设置标记，<strong>标记有可能是离散值（分类任务），也可能是连续值（回归任务</strong>）。带标记的数据集如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">编号</th>
<th style="text-align:center">色泽</th>
<th style="text-align:center">根蒂</th>
<th style="text-align:center">敲声</th>
<th style="text-align:center">标记</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">001</td>
<td style="text-align:center">青绿</td>
<td style="text-align:center">蜷缩</td>
<td style="text-align:center">浊响</td>
<td style="text-align:center">好瓜</td>
</tr>
<tr>
<td style="text-align:center">002</td>
<td style="text-align:center">乌黑</td>
<td style="text-align:center">稍蜷</td>
<td style="text-align:center">沉闷</td>
<td style="text-align:center">坏瓜</td>
</tr>
<tr>
<td style="text-align:center">003</td>
<td style="text-align:center">浅白</td>
<td style="text-align:center">硬挺</td>
<td style="text-align:center">清脆</td>
<td style="text-align:center">坏瓜</td>
</tr>
</tbody>
</table>
<h3 id="标记-label-，样例-example-，标记空间-label-space-，输出空间">标记(label)，样例(example)，标记空间(label space)，输出空间</h3>
<blockquote>
<p><strong>标记指示的是对象的类别或者事件的结果，样本和标记组合起来就是样例。所有标记的集合称为标记空间，也称为输出空间</strong>。</p>
</blockquote>
<h3 id="分类-classification-，回归-regression-，聚类-clustering">分类(classification)，回归(regression)，聚类(clustering)</h3>
<blockquote>
<p>根据预测值的不同，可以把任务分为几种不同的类别。若预测的是离散值，比如“好瓜”，“坏瓜”，则该任务称为分类任务；若预测的是连续值，比如瓜的重量，则该任务称为回归任务；还有一种聚类任务，旨在基于某种度量将样本分为若干个簇(cluster)，使得同一簇内尽量相似，不同簇间尽量相异。聚类任务不需要对样本进行标记。</p>
</blockquote>
<blockquote>
<p>特别地，只涉及两种类别的分类任务称为二分类任务(binary classification)，通常称一个类为正类(positive class)，另一个类为反类或者负类(negative class)。涉及到多个类别的分类任务就称为多分类(multi-class classification)任务。</p>
</blockquote>
<h3 id="测试-testing-，测试样本-testing-sample-，测试示例-testing-instance">测试(testing)，测试样本(testing sample)，测试示例(testing instance)</h3>
<blockquote>
<p>训练完成后，使用模型预测新样本的标记这个过程称为测试。测试中使用到的样本称为测试样本，也称测试示例或测试例。</p>
</blockquote>
<h3 id="监督学习-supervised-learning-，无监督学习-unsupervised-learning">监督学习(supervised learning)，无监督学习(unsupervised learning)</h3>
<blockquote>
<p>根据训练样本是否标记可以把任务分为两大类，<strong>需要标记的是监督学习，不需要标记的是无监督学习</strong>。前者的代表是回归和分类，后者的代表是聚类。</p>
</blockquote>
<h3 id="泛化-generalization-能力">泛化(generalization)能力</h3>
<blockquote>
<p>让机器进行学习的目标并不仅仅是为了让模型能在训练数据上有好的表现，我们更希望模型在新的样本上也能有良好的表现。<strong>模型适用于新样本的能力就称为泛化能力</strong>，泛化能力好的模型能够更好地适用于整个样本空间。</p>
</blockquote>
<h3 id="独立同分布-independent-and-identically-distributed">独立同分布(independent and identically distributed)</h3>
<blockquote>
<p>一般来说，训练数据只占训练空间很少的一部分，当我们希望这一小部分的采样能够很好地反映整个样本空间的情况，从而令学得的模型具有良好的泛化能力。通常假设样本空间中的所有样本都服从于一个未知的分布(distribution)，并且训练样本都是从该分布上独立采样所得，这就称为独立同分布。训练样本越多，越能反映该分布的特性，从而能学得泛化能力更强的模型。</p>
</blockquote>
<p> </p>
<h2 id="假设空间">假设空间</h2>
<p>类似由样本构成的样本空间和由标记构成的标记空间，<strong>所有的假设共同构成了假设空间</strong>。学习的过程就可以看作是在假设空间中搜索最能<strong>匹配</strong>(fit)训练集的假设。</p>
<p>假设空间的规模有多大呢？举个例子，样本空间维度是3，也即每个样本由3个特征来表示。这三个属性可能的取值分别为3，2，2。那么假设空间的规模就是 <code>4 × 3 × 3 + 1 = 37</code>，为什么呢？<strong>因为除了可能的取值之外，每个属性还有一种选择就是使用通配符*号表示，即无论取何值都可以</strong>。所以一个有3种可能取值的属性在排列组合时有4种情形。最后的加一表示的是<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66334em;vertical-align:-0.08167em;"></span><span class="mord amsrm">∅</span></span></span></span> <strong>假设</strong>，它对应的是一种<strong>无论属性取何值都不可能达到目的的状况</strong>。比方说，前面的假设都是假设怎样的瓜会是好瓜，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\varnothing</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.66334em;vertical-align:-0.08167em;"></span><span class="mord amsrm">∅</span></span></span></span>假设则对应于好瓜根本不存在。</p>
<p>有时候会出现多个假设都能匹配训练集的情形，这些假设的集合就称为<strong>版本空间(version space)</strong>。版本空间是假设空间的子空间。</p>
<p> </p>
<h2 id="归纳偏好">归纳偏好</h2>
<p>对于学习算法来说，要产生一个模型就意味着要从版本空间中挑选出一个假设。但是版本空间中的假设都和训练集一致，无法直接分辨出哪一个更好，这时候<strong>归纳偏好</strong>，简称<strong>偏好</strong>就起作用了。</p>
<p>注意区分<strong>偏好</strong>和<strong>特征选择</strong>，前者是基于某种领域知识而产生的，后者则是基于对训练样本的分析进行的。</p>
<p>偏好指的是，在多个假设等效时，学习算法会认为某一种假设更优，并选择这种假设来建立最终的模型。如果一个学习算法没有偏好，比方说每次随机地从版本空间中选择一个假设，则它所给出的结果是时好时坏，自相矛盾的。所以任何一个有效的学习算法都应当有自己的归纳偏好。</p>
<p>怎样确定归纳偏好呢？一个常用的原则是<strong>奥卡姆剃刀(Occam’s razor)</strong>，用一句话概述就是：<strong>若多个假设与观察一致，则选最简单的那个</strong>。注意，奥卡姆剃刀并不是唯一的准则，并且如何诠释“最简单”也是待考虑的。</p>
<p>给定基于某种归纳偏好的算法产生的模型A和基于另一种归纳偏好的算法产生的模型B，有时我们会注意到，A和B在不同的样本集上的表现各有好坏，有时候A的效果更好，有时候B的效果更好。甚至一个随机产生的模型都有可能在某个样本集上表现得优于我们精心设计的算法所产生的模型。怎样去定位这个问题呢？</p>
<p>书中使用<strong>NFL定理(No Free Lunch Theorem)<strong>来解答了这个问题，有一个关键点就是</strong>总误差与学习算法无关</strong>，证明在书上有，这里主要解析一下书中想要表达的思路。当我们考虑样本空间的所有可能分布，并认为它们都以相同的概率出现或同等重要时，无论使用什么模型，造成的总误差都是相同的，与学习算法无关！</p>
<p>但是！现实中并不是这样的，我们只考虑样本空间服从同一种分布的情形。打个比方，模型A是精心设计的算法产生的，模型B则简单地设定为把任何样本预测为负类。那么对于按照样本分布抽样所得的测试集，模型A效果会比B好；但是如果只抽取负类样本作为测试集，则模型B优于A。显然这种情况下模型B没有任何意义，因为我们根本就不care全是负类这种分布！</p>
<p>所以说，若考虑所有潜在的问题，则所有算法都一样好。<strong>要谈论算法的优劣，必须结合具体问题</strong> ！学习算法的归纳偏好和问题是否相配，往往起到决定性的作用。</p>
<p> </p>
<h2 id="其它">其它</h2>
<p>关于发展历程和应用状况，属于阅读材料，所以这里不作详细的笔记了。这个小节再补充一点其他内容。</p>
<p><strong>归纳（induciotn）<strong>和</strong>演绎（deduction）<strong>是科学推理的两大基本手段，前者是从特殊到一般的</strong>泛化（generalization）</strong>，后者是从一般到特殊的<strong>特化（specialization）</strong>。举个例子：</p>
<h3 id="演绎">演绎</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">大前提：人都会死</span><br><span class="line">小前提：苏格拉底是人</span><br><span class="line">结论：  苏格拉底会死</span><br></pre></td></tr></table></figure>
<p>演绎是一个层层递进的过程，条件A指出一个可能，条件B指出另一种可能，互相交叉，构成大小前提，一直往下，从而推出新的可能。数学公理系统中，新的定理就是通过一组公理的演绎得出的。</p>
<h3 id="归纳">归纳</h3>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">事件1：苏格拉底死了</span><br><span class="line">事件2：柏拉图死了</span><br><span class="line">事件3：阿基米德死了</span><br><span class="line">结论： 人终有一死</span><br></pre></td></tr></table></figure>
<p>归纳是从一组平等的事物中发现普遍规律/联系的过程。机器学习中从样例学习就属于归纳推理。</p>
<p><strong>注</strong>：对于提到的人名，我很抱歉T.T</p>
<h3 id="归纳学习">归纳学习</h3>
<p>归纳学习有广义和狭义之分。广义上，只要是从样例中学习就都属于归纳学习；狭义上，不仅要从样例中学习，还要求学得<strong>概念（concept）</strong>，因此也称为<strong>概念学习</strong>。概念学习技术目前应用和研究都比较少，因为要学得泛化性能好且语义明确的概念太难了。现在的技术大多都是产生<strong>黑箱模型</strong>，难以明白学得的是什么，只知道它确实有用。</p>
<p>简要带过以下归纳学习（广义）的几大主流技术，最早期的主流是<strong>符号主义学习</strong>，例如决策树，能直接模拟人类对概念进行判定的流程，有良好的解释性很强大的表示能力。但是表示能力太强也直接导致了假设空间太大，复杂度极高的缺陷。问题规模较大时难以进行有效的学习。</p>
<p>接下来发展的另一主流技术是连接主义学习，例如神经网络。与符号主义学习能产生明确的概念不同，连接主义产生的是“黑箱”模型。连接主义学习涉及到大量的参数设置，而<strong>参数设置缺乏理论指导，只能依靠手动调参</strong>，参数的设置是差之毫厘谬以千里，参数的一点点差别体现在结果上可能是极其巨大的。因此，试错性大大地限制了连接主义学习的发展。</p>
<p>再往后，统计学习技术就闪亮登场了，例如支持向量机。它与连接主义学习有密切的联系，但没有连接主义学习那么大的局限性。</p>
<p>而现在最火的深度学习技术，其实就属于连接主义学习技术，可以简单地理解为多层神经网络。深度学习的模型复杂度非常高，以至于使用者只要下功夫调参，性能往往就会很好。为什么深度学习会突然变得热门呢？有两大支持，一是<strong>数据支持</strong>，深度学习模型参数极多，如果数据不够，很容易会过拟合，但这是一个大数据时代，海量的数据允许我们构造出精准的模型；二是<strong>计算支持</strong>，随着计算机技术的发展，现代计算机具备了足够的计算海量数据的能力。</p>
<p> </p>
<h2 id="课程补充">课程补充</h2>
<h3 id="K-NN简介">K-NN简介</h3>
<p>摘自 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/25994179">https://zhuanlan.zhihu.com/p/25994179</a></p>
<h4 id="基本概念，原理以及应用"><strong>基本概念，原理以及应用</strong></h4>
<p>k近邻算法是一种<strong>基本分类和回归方法</strong>。本篇文章只讨论分类问题的k近邻法。</p>
<p>K近邻算法，即是给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例<strong>最邻近</strong>的K个实例，<strong>这K个实例的多数属于某个类</strong>，就把该输入实例分类到这个类中。（<strong>这就类似于现实生活中少数服从多数的思想</strong>）根据这个说法，咱们来看下引自维基百科上的一幅图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "2.png" style="zoom:80%;" />
<p>如上图所示，有<strong>两类</strong>不同的样本数据，分别用蓝色的小正方形和红色的小三角形表示，而图正中间的那个绿色的圆所标示的数据则是<strong>待分类的数据</strong>。这也就是我们的目的，来了一个新的数据点，我要得到它的类别是什么？好的，下面我们根据k近邻的思想来给绿色圆点进行分类。</p>
<ul>
<li>如果K=3，绿色圆点的最邻近的3个点是2个红色小三角形和1个蓝色小正方形，<strong>少数从属于多数</strong>，基于统计的方法，判定绿色的这个待分类点属于红色的三角形一类。</li>
<li>如果K=5，绿色圆点的最邻近的5个邻居是2个红色三角形和3个蓝色的正方形，<strong>还是少数从属于多数</strong>，基于统计的方法，判定绿色的这个待分类点属于蓝色的正方形一类。</li>
</ul>
<p>从上面例子我们可以看出，k近邻的算法思想非常的简单，也非常的容易理解，那么我们是不是就到此结束了，<strong>该算法的原理我们也已经懂了，也知道怎么给新来的点如何进行归类，只要找到离它最近的k个实例，哪个类别最多即可</strong></p>
<p>其实并没有这么简单，算法的核心思想确实是这样，但是要想一个算法在实际应用中起作用，还有很多问题需要考虑。比如k怎么确定的，k为多少效果最好呢？所谓的最近邻又是如何来判断给定呢？</p>
<h4 id="k近邻算法中k的选取以及特征归一化的重要性"><strong>k近邻算法中k的选取以及特征归一化的重要性</strong></h4>
<h5 id="选取k值以及它的影响"><strong>选取k值以及它的影响</strong></h5>
<p>k近邻的k值我们应该怎么选取呢？</p>
<p><strong>如果我们选取较小的k值，那么就会意味着我们的整体模型会变得复杂，容易发生过拟合</strong></p>
<p><strong>假设我们选取k=1这个极端情况，怎么就使得模型变得复杂，又容易过拟合了呢</strong>？</p>
<p><strong>假设我们有训练数据和待分类点如下图</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "3.png" style="zoom:80%;" />
<p>上图中有俩类，一个是<strong>黑色的圆点</strong>，一个是<strong>蓝色的长方形</strong>，现在我们的待分类点是<strong>红色的五边形</strong></p>
<p>好，根据我们的k近邻算法步骤来决定待分类点应该归为哪一类。我们由图中可以得到，<strong>很容易我们能够看出来五边形离黑色的圆点最近，k又等于1，那太好了</strong>，我们最终判定待分类点是黑色的圆点。</p>
<p>由这个处理过程我们很容易能够感觉出问题了，如果k太小了，比如等于1，那么模型就太复杂了，<strong>我们很容易学习到噪声</strong>，也就非常容易判定为噪声类别，而在上图，如果，k大一点，k等于8，<strong>把长方形都包括进来</strong>，我们很容易得到我们正确的分类应该是蓝色的长方形！如下图：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "4.png" style="zoom:90%;" />
<p>所谓的过拟合就是在训练集上准确率非常高，而在测试集上准确率低，经过上例，我们可以得到k太小会导致<strong>过拟合</strong>，<strong>很容易将一些噪声（如上图离五边形很近的黑色圆点）学习到模型中，而忽略了数据真实的分布</strong></p>
<p><strong>如果我们选取较大的k值，就相当于用较大邻域中的训练数据进行预测，这时与输入实例较远的（不相似）训练实例也会对预测起作用，使预测发生错误，k值的增大意味着整体模型变得简单</strong></p>
<p>k值增大怎么就意味着模型变得简单了，不要急，我会解释的！哈哈。</p>
<p><strong>我们想，如果k=N（N为训练样本的个数）,那么无论输入实例是什么，都将简单地预测它属于在训练实例中最多的类。这时，模型是不是非常简单，这相当于你压根就没有训练模型呀</strong>。直接拿训练数据统计了一下各个数据的类别，找最大的而已！这好像下图所示：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "5.png" style="zoom:60%;" />
<p>我们统计了黑色圆形是8个，长方形个数是7个，那么哈哈，如果k=N，我就得出结论了，红色五边形是属于黑色圆形的（<strong>明显是错误的</strong>）</p>
<p><strong>这个时候，模型过于简单，完全忽略训练数据实例中的大量有用信息，是不可取的</strong></p>
<p><strong>恩，k值既不能过大，也不能过小，在我举的这个例子中，我们k值的选择，在下图红色圆边界之间这个范围是最好的，如下图</strong></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "6.png" style="zoom:80%;" />
<p>那么我们一般怎么选取呢？李航博士书上讲到，我们一般选取一个较小的数值，通常采取 交叉验证法来选取最优的k值。（<strong>也就是说，选取k值很重要的关键是实验调参，类似于神经网络选取多少层这种，通过调整超参数来得到一个较好的结果</strong>）</p>
<h5 id="距离的度量"><strong>距离的度量</strong></h5>
<p>在上文中说到，k近邻算法是在训练数据集中找到与该实例<strong>最邻近</strong>的K个实例，这K个实例的多数属于某个类，我们就说预测点属于哪个类。</p>
<p>定义中所说的最邻近是如何度量呢？我们怎么知道谁跟测试点最邻近。这里就会引出我们几种度量俩个点之间距离的标准。</p>
<p>我们可以有以下几种度量方式：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "7.png" style="zoom:90%;" />
<p>其中当p=2的时候，就是我们最常见的欧式距离，我们也一般都用欧式距离来衡量我们高维空间中俩点的距离。在实际应用中，距离函数的选择应该根据数据的特性和分析的需要而定，一般选取p=2欧式距离表示。</p>
<h5 id="特征归一化的必要性"><strong>特征归一化的必要性</strong></h5>
<p>首先举例如下，我用一个人身高(cm)与脚码（尺码）大小来作为特征值，类别为男性或者女性。我们现在如果有5个训练样本，分布如下：</p>
<p>A [(179,42),男] B [(178,43),男] C [(165,36)女] D [(177,42),男] E [(160,35),女]</p>
<p>通过上述训练样本，我们看出问题了吗？</p>
<p>很容易看到第一维身高特征是第二维脚码特征的4倍左右，那么在进行距离度量的时候，<strong>我们就会偏向于第一维特征</strong>。这样造成俩个特征并不是等价重要的，最终可能会导致距离计算错误，从而导致预测错误。</p>
<p>我们应该让每个特征都是同等重要的！这也是我们要归一化的原因！归一化公式如下：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "8.png" style="zoom:80%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "9.png" style="zoom:80%;" />
<h3 id="决策树">决策树</h3>
<p>暑期学过决策树，参见 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zwn-blog.xyz/2022/07/27/%E6%9A%91%E6%9C%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BC%95%E8%AE%BA/#%E5%86%B3%E7%AD%96%E6%A0%91">https://www.zwn-blog.xyz/2022/07/27/暑期机器学习引论/#决策树</a></p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "10.png" style="zoom:80%;" />
<h3 id="SVM">SVM</h3>
<p>网上看了PageRank最高的<a target="_blank" rel="noopener external nofollow noreferrer" href="https://tangshusen.me/2018/10/27/SVM/">博客</a>，感觉相当深刻，放在这里反而不合适，于是摘抄了一份放在<a href="#SVM-%E6%90%AC%E8%BF%90">文末</a>，希望有一天我也能完全吃透。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "11.png" style="zoom:70%;" />
<h3 id="学习范式">学习范式</h3>
<blockquote>
<p>Focus on ideas rather than detailed algorithms</p>
</blockquote>
<h4 id="集成学习">集成学习</h4>
<p>传统机器学习算法 (例如：决策树，人工神经网络，支持向量机，朴素贝叶斯等) 的目标都是寻找一个最优分类器尽可能的将训练数据分开。<strong>集成学习 (Ensemble Learning) 算法的基本思想就是将多个分类器组合，从而实现一个预测效果更好的集成分类器</strong>。集成算法可以说从一方面验证了中国的一句老话：三个臭皮匠，赛过诸葛亮。</p>
<p>Thomas G. Dietterich 指出了集成算法在统计，计算和表示上的有效原因：</p>
<ul>
<li>统计上的原因</li>
</ul>
<p>一个学习算法可以理解为在一个假设空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">H</mi></mrow><annotation encoding="application/x-tex">\mathcal H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathcal" style="margin-right:0.00965em;">H</span></span></span></span> 中选找到一个最好的假设。但是，当训练样本的数据量小到不够用来精确的学习到目标假设时，学习算法可以找到很多满足训练样本的分类器。所以，学习算法选择任何一个分类器都会面临一定错误分类的风险，因此将多个假设集成起来可以降低选择错误分类器的风险。</p>
<ul>
<li>计算上的原因</li>
</ul>
<p>很多学习算法在进行最优化搜索时很有可能<strong>陷入局部最优的错误</strong>中，因此对于学习算法而言很难得到一个全局最优的假设。事实上人工神经网络和决策树已经被证实为是一 个NP 问题。集成算法可以从多个起始点进行局部搜索，从而分散陷入局部最优的风险。</p>
<ul>
<li>表示上的原因</li>
</ul>
<p>在多数应用场景中，假设空间 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">H</mi></mrow><annotation encoding="application/x-tex">\mathcal H</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathcal" style="margin-right:0.00965em;">H</span></span></span></span> 中的任意一个假设都无法表示 (或近似表示) 真正的分类函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span>。因此，对于不同的假设条件，通过加权的形式可以扩大假设空间，从而学习算法可以在一个无法表示或近似表示真正分类函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 的假设空间中找到一个逼近函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>f</mi></mrow><annotation encoding="application/x-tex">f</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span></span></span></span> 的近似值。</p>
<p>目前，有三种常见的集成学习框架：bagging，boosting和stacking（上课只提到了前两个）。国内，南京大学的周志华教授对集成学习有很深入的研究，其在09年发表的一篇概述性论文<a href="https://link.zhihu.com/?target=http%3A//cs.nju.edu.cn/zhouzh/zhouzh.files/publication/springerEBR09.pdf" rel="external nofollow noreferrer">《</a><a href="https://link.zhihu.com/?target=http%3A//cs.nju.edu.cn/zhouzh/zhouzh.files/publication/springerEBR09.pdf" rel="external nofollow noreferrer">Ensemble Learning》</a>对这三种集成学习框架有了明确的定义，概括如下：</p>
<p>bagging：从训练集从进行子抽样组成每个基模型所需要的子训练集，对所有基模型预测的结果进行综合产生最终的预测结果：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "13.png" style="zoom:80%;" />
<p>boosting：训练过程为阶梯状，基模型按次序一一进行训练（实现上可以做到并行），基模型的训练集按照某种策略每次都进行一定的转化。对所有基模型预测的结果进行线性综合产生最终的预测结果：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "14.png" style="zoom:80%;" />
<p>stacking：将训练好的所有基模型对训练基进行预测，第j个基模型对第i个训练样本的预测值将作为新的训练集中第i个样本的第j个特征值，最后基于新的训练集进行训练。同理，预测的过程也要先经过所有基模型的预测形成新的测试集，最后再对<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E6%B5%8B%E8%AF%95%E9%9B%86&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A111637662%7D">测试集</a>进行预测：</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "15.png" style="zoom:80%;" />
<p>有了这些基本概念之后，直觉将告诉我们，由于不再是单一的模型进行预测，所以模型有了“集思广益”的能力，也就不容易产生过拟合现象。</p>
<h5 id="Bagging">Bagging</h5>
<p><strong>Bagging 的核心思路是——民主。</strong></p>
<p>Bagging 的思路是所有基础模型都一致对待，每个基础模型手里都只有一票。然后使用民主投票的方式得到最终的结果。</p>
<p>大部分情况下，<strong>经过 bagging 得到的结果方差（variance）更小</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "16.webp" style="zoom:80%;" />
<p><strong>具体过程：</strong></p>
<ol>
<li>从原始样本集中抽取训练集。每轮从原始样本集中使用Bootstraping的方法抽取n个训练样本（在训练集中，有些样本可能被多次抽取到，而有些样本可能一次都没有被抽中）。共进行k轮抽取，得到k个训练集。（k个训练集之间是相互独立的）</li>
<li>每次使用一个训练集得到一个模型，k个训练集共得到k个模型。（注：这里并没有具体的分类算法或回归方法，我们可以根据具体问题采用不同的分类或回归方法，如决策树、感知器等）</li>
<li>对分类问题：将上步得到的k个模型采用投票的方式得到分类结果；对回归问题，计算上述模型的均值作为最后的结果。（所有模型的重要性相同）</li>
</ol>
<p><strong>举例：</strong></p>
<p>在 bagging 的方法中，最广为熟知的就是随机森林了：bagging + 决策树 = 随机森林</p>
<p>《<a target="_blank" rel="noopener external nofollow noreferrer" href="https://easyai.tech/ai-definition/decision-tree/">一文看懂决策树（3个步骤+3种典型算法+10个优缺点）</a>》</p>
<p>《<a target="_blank" rel="noopener external nofollow noreferrer" href="https://easyai.tech/ai-definition/random-forest/">一文看懂随机森林（4个步骤+4种方式评测+10个优缺点）</a>》</p>
<h5 id="Boosting">Boosting</h5>
<p><strong>Boosting 的核心思路是——挑选精英。</strong></p>
<p>Boosting 和 bagging 最本质的差别在于他对基础模型不是一致对待的，而是经过不停的考验和筛选来挑选出“精英”，然后给精英更多的投票权，表现不好的基础模型则给较少的投票权，然后综合所有人的投票得到最终结果。</p>
<p>大部分情况下，<strong>经过 boosting 得到的结果偏差（bias）更小</strong>。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "17.webp" style="zoom:80%;" />
<p><strong>具体过程：</strong></p>
<ol>
<li>通过加法模型将基础模型进行线性的组合。</li>
<li>每一轮训练都提升那些错误率小的基础模型权重，同时减小错误率高的模型权重。</li>
<li>在每一轮改变训练数据的权值或概率分布，通过提高那些在前一轮被弱分类器分错样例的权值，减小前一轮分对样例的权值，来使得分类器对误分的数据有较好的效果。</li>
</ol>
<p><strong>举例：</strong></p>
<p>在 boosting 的方法中，比较主流的有 <a target="_blank" rel="noopener external nofollow noreferrer" href="https://easyai.tech/ai-definition/adaboost/">Adaboost</a> 和 Gradient boosting 。</p>
<p>《<a target="_blank" rel="noopener external nofollow noreferrer" href="https://easyai.tech/ai-definition/adaboost/">一文看懂 Adaboost 以及它的优缺点</a>》</p>
<h5 id="Bagging-和-Boosting-的4-点差别">Bagging 和 Boosting 的4 点差别</h5>
<p><strong>样本选择上：</strong></p>
<p>Bagging：训练集是在原始集中有放回选取的，从原始集中选出的各轮训练集之间是独立的。</p>
<p>Boosting：每一轮的训练集不变，只是训练集中每个样例在分类器中的权重发生变化。而权值是根据上一轮的分类结果进行调整。</p>
<p><strong>样例权重：</strong></p>
<p>Bagging：使用均匀取样，每个样例的权重相等</p>
<p>Boosting：根据错误率不断调整样例的权值，错误率越大则权重越大。</p>
<p><strong>预测函数：</strong></p>
<p>Bagging：所有预测函数的权重相等。</p>
<p>Boosting：每个弱分类器都有相应的权重，对于分类误差小的分类器会有更大的权重。</p>
<p><strong>并行计算：</strong></p>
<p>Bagging：各个预测函数可以并行生成</p>
<p>Boosting：各个预测函数只能顺序生成，因为后一个模型参数需要前一轮模型的结果。</p>
<p>差别部分内容转自《<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/liuwu265/p/4690486.html">Bagging和Boosting 概念及区别</a>》</p>
<h4 id="深度学习">深度学习</h4>
<h5 id="深度学习是一个数学问题">深度学习是一个数学问题</h5>
<p>机器学习和数学，是深度学习的一体两面。机器学习是深度学习的方法论，数学是其背后的理论支撑。</p>
<p>其实每一种算法，究其根本，都是一种数学表达。无论是机器学习，还是深度学习，都是试图找到一个函数，这个函数可以简单，可以复杂，函数的表达并不重要，只是一个工具，重要的是这个函数能够尽可能准确的拟合出输入数据和输出结果间的关系。</p>
<p>这就是机器学习要做到的事，找到一个数学表达，即上述例子中的函数f。</p>
<p>而深度学习的魅力在于，它的数学表达特别的强！</p>
<p>深度学习的强大是有数学原理支撑的，这个原理叫做“万能近似定理”（Universal approximation theorem）。这个定理的道理很简单 —— 神经网络可以拟合任何函数，不管这个函数的表达是多么的复杂。</p>
<p>因为这个定理，深度学习在拟合函数这一方面的能力十分强大、暴力和神秘。</p>
<p>但是，哪有免费的午餐，深度学习的强大也带来了对应的问题 —— 黑箱化</p>
<p>黑箱的意思是，深度学习的中间过程不可知，深度学习产生的结果不可控。</p>
<p>一方面，我们比较难知道网络具体在做些什么；另一方面，我们很难解释神经网络在解决问题的时候，为什么要这么做，为什么有效果。</p>
<p>在传统的机器学习中，算法的结构大多充满了逻辑，这种结构可以被人分析，最终抽象为某种流程图或者一个代数上的公式，最典型的比如决策树，具有非常高的可解释性。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "18.jpg" style="zoom:100%;" />
<p>到了深度学习，这样子的直观就不见了。简单来说，深度学习的工作原理，是通过一层层神经网络，使得输入的信息在经过每一层时，都做一个数学拟合，这样每一层都提供了一个函数。因为深度学习有好多层，通过这每一层的函数的叠加，深度学习网络的输出就无限逼近目标输出了。这样一种“万能近似”，很多时候是输入和输出在数值上的一种耦合，而不是真的找到了一种代数上的表达式。当我们在说”拟合“、”函数“这一类词的时候，你或许认为我们会像写公式一样把输入和输出之间的关系列在黑板上。但事实并不是这样，深度学习拟合出来的函数，一般人还真写不出来……</p>
<p>所以，很多时候，你的深度学习网络能很好的完成你的任务，可是你并不知道网络学习到了什么，也不知道网络为什么做出了特定的选择。知其然而不知其所以然，这可以看作是深度学习的常态，也是深度学习工作中的一大挑战。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "19.png" style="zoom:50%;" />
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "20.png" style="zoom:50%;" />
<p>先拿一个最简单的例子来说：一个系统的输入是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> ，输出为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> ，我们知道 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mn>2</mn><mo separator="true">;</mo><mi>x</mi><mo>=</mo><mn>2</mn><mo separator="true">,</mo><mi>y</mi><mo>=</mo><mn>4</mn></mrow><annotation encoding="application/x-tex">x=1,y=2;x=2,y=4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">x</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">4</span></span></span></span>，以此类推。我们很容易就得出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 与 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 之间的映射关系，即 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 是两倍的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> （ <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi><mo>=</mo><mn>2</mn><mi>x</mi></mrow><annotation encoding="application/x-tex">y=2x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord mathnormal">x</span></span></span></span> ）。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "22.png" alt="img" style="zoom:80%;" />
<p>这里的两倍，就是输入和输出之间的映射关系。当我们知道了这种映射关系之后，我随便给出一个输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> （比如1203），都能得到输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> （2406）。</p>
<p>这个例子比较简单，我们一眼就能看出输入和输出之间的关系，当 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 为图片、声音、<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E8%82%A1%E5%B8%82%E4%BA%A4%E6%98%93&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1155390509%7D">股市交易</a>单、人口与房价等等复杂的输入时，如何计算出想要的输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>y</mi></mrow><annotation encoding="application/x-tex">y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.625em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span></span></span></span> 呢？</p>
<p>这时候就很明确了，从输入推理出输出的关键就在于，获取输入和输出之间的映射关系，我们将输入和输出之间的映射关系定义成一个函数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi><mo>=</mo><mi>F</mi><mo stretchy="false">(</mo><mi>X</mi><mo separator="true">,</mo><mi>θ</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">Y=F(X,\theta)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span></span></span></span>，这里的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 就是输出， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 是输入。</p>
<p>关键就在于，怎么求解这个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 呢？这时候就要祭出神经网络了，它的作用就是通过调整参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 来求解输入输出之间的映射关系 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>F</mi></mrow><annotation encoding="application/x-tex">F</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.13889em;">F</span></span></span></span> 。</p>
<p>从理论上来讲，神经网络通过调整各层的参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> ，可以拟合任意复杂度的函数（这一部分不展开了，感兴趣的可以去学习相关内容）。我们先喂给神经网络一定量的输入输出数据，通过一次次的训练，让网络学习到当前输入输出数据之间的映射关系。那么如果未知的输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 与训练神经网络的输入服从同分布的话，将这个未知输入 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 送入神经网络中就能够映射出一个输出 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 。</p>
<p>神经网络就get到预测的能力了！</p>
<p>可是这种映射的结果一定是准确的吗，比如我输入一张猫咪的图像进入识别动物的神经网络，我想要的输出结果是：<strong>这是一只猫咪</strong>。但神经网络给出的输出有可能是：<strong>这是一只狗狗</strong></p>
<p><strong>这意味着，神经网络学习到的输入和输出之间的映射关系，不一定是准确的！</strong></p>
<p>那么什么样的神经网络能够更加准确的学习到输入和输出之间的映射关系呢？答案是<strong>更深的神经网络。</strong></p>
<p>原来把网络层数加深就好了！</p>
<p>可是神经网络采取下图这种全连接的连接方式，即每层中的任意个神经元都与下一层的全部神经元相连接，然后每个连接之间都有一组参数 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> ，这种全连接形式带来的参数量是极其巨大的，导致的计算量是不可接受的。</p>
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src= "21.jpg" style="zoom:100%;" />
<p>那么是不是换成大算力的计算设备就可以了呢？答案是否定的。</p>
<p>参数量巨大只是其中的一个问题，还有一个问题是，过于深的神经网络在求解过程中很容易陷入局部最优解，而非<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E5%85%A8%E5%B1%80%E6%9C%80%E4%BC%98%E8%A7%A3&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1155390509%7D">全局最优解</a>。这成为了阻碍深度神经网络发展的主要因素。</p>
<p>直到 2006 年，深度学习界的大牛，Hinton 教授发表的论文中提出了两个重要观点：（1）多层的神经网络具有优秀的特征学习能力，能够学习到数据更本质的特征；（2）可通过<a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/search?q=%E9%80%90%E5%B1%82%E9%A2%84%E8%AE%AD%E7%BB%83&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A1155390509%7D">逐层预训练</a>的方式解决深度神经网络难以获得全局最优解的问题。</p>
<h4 id="半监督学习">半监督学习</h4>
<p>目前知道最科学的定义是来自《Introduction to Semi-supervised Learning》，这里只给出一个自我感觉良好的说法，大概就是，在有标签数据+无标签数据混合成的训练数据中使用的机器学习算法吧。一般假设，无标签数据比有标签数据多，甚至多得多。</p>
<p>虽然训练数据中含有大量无标签数据，但其实在很多半监督学习算法中用的训练数据还有挺多要求的，一般默认的有：无标签数据一般是有标签数据中的某一个类别的（不要不属于的，也不要属于多个类别的）；有标签数据的标签应该都是对的；无标签数据一般是类别平衡的（即每一类的样本数差不多）；无标签数据的分布应该和有标签的相同或类似 等等。</p>
<p>事实上，某些要求在实际应用中挺强人所难的，所以明明感觉半监督好像很厉害，但应用就是不多啊。但在学术上，这些要求还是可以有滴。</p>
<p>一般，半监督学习算法可分为：self-training（自训练算法）、Graph-based Semi-supervised Learning（基于图的半监督算法）、Semi-supervised supported vector machine（半监督支持向量机，S3VM）。简单介绍如下：</p>
<p>1.<strong>简单自训练</strong>（simple self-training）：用有标签数据训练一个分类器，然后用这个分类器对无标签数据进行分类，这样就会产生伪标签（pseudo label）或软标签（soft label），挑选你认为分类正确的无标签样本（此处应该有一个<strong>挑选准则</strong>），把选出来的无标签样本用来训练分类器。</p>
<p>2.<strong>协同训练</strong>（co-training）：其实也是 self-training 的一种，但其思想是好的。假设每个数据可以从不同的角度（view）进行分类，不同角度可以训练出不同的分类器，然后用这些从不同角度训练出来的分类器对无标签样本进行分类，再选出认为可信的无标签样本加入训练集中。由于这些分类器从不同角度训练出来的，可以形成一种互补，而提高分类精度；就如同从不同角度可以更好地理解事物一样。</p>
<p>3.<strong>半监督字典学习</strong>：其实也是 self-training 的一种，先是用有标签数据作为字典，对无标签数据进行分类，挑选出你认为分类正确的无标签样本，加入字典中（此时的字典就变成了半监督字典了）</p>
<p>4.<strong>标签传播算法</strong>（Label Propagation Algorithm）：是一种基于图的半监督算法，通过构造图结构（数据点为顶点，点之间的相似性为边）来寻找<strong>训练数据</strong>中有标签数据和无标签数据的关系。是的，只是训练数据中，这是一种直推式的半监督算法，即只对训练集中的无标签数据进行分类，这其实感觉很像一个有监督分类算法…，但其实并不是，因为其标签传播的过程，会流经无标签数据，即有些无标签数据的标签的信息，是从另一些无标签数据中流过来的，这就用到了无标签数据之间的联系</p>
<p>5.<strong>半监督支持向量机</strong>：监督支持向量机是利用了结构风险最小化来分类的，半监督支持向量机还用上了无标签数据的空间分布信息，即决策超平面应该与无标签数据的分布一致（应该经过无标签数据密度低的地方）（<strong>这其实是一种假设</strong>，不满足的话这种无标签数据的空间分布信息会误导决策超平面，导致性能比只用有标签数据时还差）</p>
<p>其实，半监督学习的方法大都建立在对数据的某种假设上，只有满足这些假设，半监督算法才能有性能的保证，这也是限制了半监督学习应用的一大障碍。</p>
<p> </p>
<h2 id="参考">参考</h2>
<blockquote>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/134089340">https://zhuanlan.zhihu.com/p/134089340</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Vay-keen/Machine-learning-learning-notes">https://github.com/Vay-keen/Machine-learning-learning-notes</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/familyld/Machine_Learning">https://github.com/familyld/Machine_Learning</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/25994179">https://zhuanlan.zhihu.com/p/25994179</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://leovan.me/cn/2018/12/ensemble-learning/">https://leovan.me/cn/2018/12/ensemble-learning/</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://easyai.tech/ai-definition/ensemble-learning/">https://easyai.tech/ai-definition/ensemble-learning/</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/72415675">https://zhuanlan.zhihu.com/p/72415675</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/question/63492375">https://www.zhihu.com/question/63492375</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/question/27068705">https://www.zhihu.com/question/27068705</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/question/19725590/answer/241988854">https://www.zhihu.com/question/19725590/answer/241988854</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://tangshusen.me/2018/10/27/SVM/">https://tangshusen.me/2018/10/27/SVM/</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.joinquant.com/view/community/detail/a98b7021e7391c62f6369207242700b2">https://www.joinquant.com/view/community/detail/a98b7021e7391c62f6369207242700b2</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/79531731">https://zhuanlan.zhihu.com/p/79531731</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/Charmve/PaperWeeklyAI/blob/master/03_Maiwei%20AI%20PaperWeekly/03_%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%26%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%AE%97%E6%B3%95%E4%B9%8B%E2%80%94%E2%80%94K%E6%9C%80%E8%BF%91%E9%82%BB(k-Nearest%20Neighbor%EF%BC%8CKNN)%E5%88%86%E7%B1%BB%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86%E8%AE%B2%E8%A7%A3.md">https://github.com/Charmve/PaperWeeklyAI/blob/master/03_Maiwei AI PaperWeekly/03_机器学习%26深度学习理论/机器学习算法之——K最近邻(k-Nearest Neighbor，KNN)分类算法原理讲解.md</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/zc02051126/article/details/49618633">https://blog.csdn.net/zc02051126/article/details/49618633</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/127022333">https://zhuanlan.zhihu.com/p/127022333</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://0809zheng.github.io/2020/03/30/ridge.html">https://0809zheng.github.io/2020/03/30/ridge.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/wuliytTaotao/p/10837533.html">https://www.cnblogs.com/wuliytTaotao/p/10837533.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://link.springer.com/referenceworkentry/10.1007/978-1-4899-7687-1_910#Sec13186">https://link.springer.com/referenceworkentry/10.1007/978-1-4899-7687-1_910#Sec13186</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://palm.seu.edu.cn/zhangml/files/mla11-mll.pdf">http://palm.seu.edu.cn/zhangml/files/mla11-mll.pdf</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/zwqjoy/article/details/80431496">https://blog.csdn.net/zwqjoy/article/details/80431496</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://ryuchen.club/posts/0x000034/">https://ryuchen.club/posts/0x000034/</a>  (推荐）</p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/78798251">https://zhuanlan.zhihu.com/p/78798251</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/622244758">https://zhuanlan.zhihu.com/p/622244758</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.biaodianfu.com/hierarchical-clustering.html">https://www.biaodianfu.com/hierarchical-clustering.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/411533418">https://zhuanlan.zhihu.com/p/411533418</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/33196506">https://zhuanlan.zhihu.com/p/33196506</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/wry789/p/13125658.html">https://www.cnblogs.com/wry789/p/13125658.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/qq_41485273/article/details/113178117">https://blog.csdn.net/qq_41485273/article/details/113178117</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.jianshu.com/p/7d4323c28716">https://www.jianshu.com/p/7d4323c28716</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="http://lunarnai.cn/2019/01/02/watermelon-chap-13/">http://lunarnai.cn/2019/01/02/watermelon-chap-13/</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/weixin_42301220/article/details/124075747?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522168421964616800182162046%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=168421964616800182162046&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~rank_v31_ecpm-9-124075747-null-null.142%5Ev87%5Econtrol_2,239%5Ev2%5Einsert_chatgpt&amp;utm_term=%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0%20%E8%A5%BF%E7%93%9C%E4%B9%A6&amp;spm=1018.2226.3001.4187">【周志华机器学习】十三、半监督学习</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/411533418">https://zhuanlan.zhihu.com/p/411533418</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.huaxiaozhuan.com/%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0/chapters/12_semi_supervised.html">https://www.huaxiaozhuan.com/统计学习/chapters/12_semi_supervised.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/tyh70537/article/details/80244490">https://blog.csdn.net/tyh70537/article/details/80244490</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://zhuanlan.zhihu.com/p/37747650">https://zhuanlan.zhihu.com/p/37747650</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://7125messi.github.io/post/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E5%AE%9E%E7%8E%B0/">7125messi.github.io</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/qq_40722827/article/details/104515955">https://blog.csdn.net/qq_40722827/article/details/104515955</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/dyl222/p/11055756.html">https://www.cnblogs.com/dyl222/p/11055756.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.zhihu.com/tardis/zm/art/392908965">https://www.zhihu.com/tardis/zm/art/392908965</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://blog.csdn.net/j123kaishichufa/article/details/7679682">https://blog.csdn.net/j123kaishichufa/article/details/7679682</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/heaad/archive/2011/01/02/1924088.html">https://www.cnblogs.com/heaad/archive/2011/01/02/1924088.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://www.cnblogs.com/stevenlk/p/6543628.html">https://www.cnblogs.com/stevenlk/p/6543628.html</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://baidinghub.github.io/2020/04/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E5%8D%81%E4%BA%8C%EF%BC%89PCA/#2%E3%80%81%E6%A0%B8%E5%8C%96%E7%BA%BF%E6%80%A7%E9%99%8D%E7%BB%B4">baidinghub.github.io-PCA</a></p>
<p><a target="_blank" rel="noopener external nofollow noreferrer" href="https://baidinghub.github.io/2020/04/03/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89%E7%BA%BF%E6%80%A7%E5%88%A4%E5%88%AB%E5%88%86%E6%9E%90LDA/#1%E3%80%81%E6%A8%A1%E5%9E%8B%E4%BB%8B%E7%BB%8D">baidinghub.github.io-LDA</a></p>
<p>等等</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://zwn2001.space">洛雪</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://zwn2001.space/2023/03/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BB%AA%E8%AE%BA/">https://zwn2001.space/2023/03/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E7%BB%AA%E8%AE%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://zwn2001.space" target="_blank">ZWN's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a></div><div class="post_share"><div class="social-share" data-image="/img/cover3/20-min.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/" title="机器学习-模型评估与选择"><img class="cover" src="/img/cover3/32.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">机器学习-模型评估与选择</div></div></a></div><div class="next-post pull-right"><a href="/2023/02/20/How-To-Use-Hexo/" title="How-To-Use-Hexo Hexo建站小教程"><img class="cover" src="/img/cover1/1.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">How-To-Use-Hexo Hexo建站小教程</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/07/27/%E6%9A%91%E6%9C%9F%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%BC%95%E8%AE%BA/" title="暑期机器学习引论"><img class="cover" src="/img/cover2/1-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-07-27</div><div class="title">暑期机器学习引论</div></div></a></div><div><a href="/2023/03/06/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-KNN/" title="机器学习-KNN"><img class="cover" src="/img/cover3/9-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-06</div><div class="title">机器学习-KNN</div></div></a></div><div><a href="/2023/03/05/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-SVM/" title="机器学习-SVM"><img class="cover" src="/img/cover3/3-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-05</div><div class="title">机器学习-SVM</div></div></a></div><div><a href="/2023/03/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E4%BB%A3%E4%BB%B7%E6%95%8F%E6%84%9F%E5%AD%A6%E4%B9%A0/" title="机器学习-代价敏感学习"><img class="cover" src="/img/cover1/15.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-15</div><div class="title">机器学习-代价敏感学习</div></div></a></div><div><a href="/2023/03/04/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%86%B3%E7%AD%96%E6%A0%91/" title="机器学习-决策树"><img class="cover" src="/img/cover3/6-min.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-04</div><div class="title">机器学习-决策树</div></div></a></div><div><a href="/2023/03/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E6%A0%87%E7%AD%BE%E5%AD%A6%E4%B9%A0/" title="机器学习-多标签学习"><img class="cover" src="/img/cover1/13.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-10</div><div class="title">机器学习-多标签学习</div></div></a></div></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="giscus-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/favicon.png" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">洛雪</div><div class="author-info__description">我虽无意逐鹿，却知苍生苦楚</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">135</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">42</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/ZWN2001"><i class="fab fa-github"></i><span>我的Github</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/ZWN2001" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">新域名：www.zwn2001.space，有效期：10年。https://www.zwn-blog.xyz/将在2023年末过期</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.1.</span> <span class="toc-text">机器学习的定义</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.2.</span> <span class="toc-text">基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-instance-%EF%BC%8C%E6%A0%B7%E6%9C%AC-sample"><span class="toc-number">1.2.1.</span> <span class="toc-text">示例(instance)，样本(sample)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7-attribute-%EF%BC%8C%E7%89%B9%E5%BE%81-feature-%EF%BC%8C%E5%B1%9E%E6%80%A7%E5%80%BC-attribute-value"><span class="toc-number">1.2.2.</span> <span class="toc-text">属性(attribute)，特征(feature)，属性值(attribute value)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E7%A9%BA%E9%97%B4-attribute-space-%EF%BC%8C%E6%A0%B7%E6%9C%AC%E7%A9%BA%E9%97%B4-sample-space-%EF%BC%8C%E8%BE%93%E5%85%A5%E7%A9%BA%E9%97%B4%EF%BC%8C%E7%89%B9%E5%BE%81%E5%90%91%E9%87%8F-feature-vector"><span class="toc-number">1.2.3.</span> <span class="toc-text">属性空间(attribute space)，样本空间(sample space)，输入空间，特征向量(feature vector)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%B4%E6%95%B0-dimensionality"><span class="toc-number">1.2.4.</span> <span class="toc-text">维数(dimensionality)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0-learning-%EF%BC%8C%E8%AE%AD%E7%BB%83-training-%EF%BC%8C%E8%AE%AD%E7%BB%83%E6%A0%B7%E6%9C%AC-training-sample-%EF%BC%8C%E8%AE%AD%E7%BB%83%E7%A4%BA%E4%BE%8B-training-instance"><span class="toc-number">1.2.5.</span> <span class="toc-text">学习(learning)，训练(training)，训练样本(training sample)，训练示例(training instance)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E5%9E%8B-model-%EF%BC%8C%E5%AD%A6%E4%B9%A0%E5%99%A8-learner-%EF%BC%8C%E5%81%87%E8%AE%BE-hypothesis-%EF%BC%8C%E7%9C%9F%E7%9B%B8-ground-truth"><span class="toc-number">1.2.6.</span> <span class="toc-text">模型(model)，学习器(learner)，假设(hypothesis)，真相(ground-truth)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E8%AE%B0-label-%EF%BC%8C%E6%A0%B7%E4%BE%8B-example-%EF%BC%8C%E6%A0%87%E8%AE%B0%E7%A9%BA%E9%97%B4-label-space-%EF%BC%8C%E8%BE%93%E5%87%BA%E7%A9%BA%E9%97%B4"><span class="toc-number">1.2.7.</span> <span class="toc-text">标记(label)，样例(example)，标记空间(label space)，输出空间</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E7%B1%BB-classification-%EF%BC%8C%E5%9B%9E%E5%BD%92-regression-%EF%BC%8C%E8%81%9A%E7%B1%BB-clustering"><span class="toc-number">1.2.8.</span> <span class="toc-text">分类(classification)，回归(regression)，聚类(clustering)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%8B%E8%AF%95-testing-%EF%BC%8C%E6%B5%8B%E8%AF%95%E6%A0%B7%E6%9C%AC-testing-sample-%EF%BC%8C%E6%B5%8B%E8%AF%95%E7%A4%BA%E4%BE%8B-testing-instance"><span class="toc-number">1.2.9.</span> <span class="toc-text">测试(testing)，测试样本(testing sample)，测试示例(testing instance)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-supervised-learning-%EF%BC%8C%E6%97%A0%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0-unsupervised-learning"><span class="toc-number">1.2.10.</span> <span class="toc-text">监督学习(supervised learning)，无监督学习(unsupervised learning)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%9B%E5%8C%96-generalization-%E8%83%BD%E5%8A%9B"><span class="toc-number">1.2.11.</span> <span class="toc-text">泛化(generalization)能力</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%8B%AC%E7%AB%8B%E5%90%8C%E5%88%86%E5%B8%83-independent-and-identically-distributed"><span class="toc-number">1.2.12.</span> <span class="toc-text">独立同分布(independent and identically distributed)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%81%87%E8%AE%BE%E7%A9%BA%E9%97%B4"><span class="toc-number">1.3.</span> <span class="toc-text">假设空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E7%BA%B3%E5%81%8F%E5%A5%BD"><span class="toc-number">1.4.</span> <span class="toc-text">归纳偏好</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E5%AE%83"><span class="toc-number">1.5.</span> <span class="toc-text">其它</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BC%94%E7%BB%8E"><span class="toc-number">1.5.1.</span> <span class="toc-text">演绎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E7%BA%B3"><span class="toc-number">1.5.2.</span> <span class="toc-text">归纳</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BD%92%E7%BA%B3%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.5.3.</span> <span class="toc-text">归纳学习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BE%E7%A8%8B%E8%A1%A5%E5%85%85"><span class="toc-number">1.6.</span> <span class="toc-text">课程补充</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#K-NN%E7%AE%80%E4%BB%8B"><span class="toc-number">1.6.1.</span> <span class="toc-text">K-NN简介</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%8C%E5%8E%9F%E7%90%86%E4%BB%A5%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-number">1.6.1.1.</span> <span class="toc-text">基本概念，原理以及应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#k%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%E4%B8%ADk%E7%9A%84%E9%80%89%E5%8F%96%E4%BB%A5%E5%8F%8A%E7%89%B9%E5%BE%81%E5%BD%92%E4%B8%80%E5%8C%96%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7"><span class="toc-number">1.6.1.2.</span> <span class="toc-text">k近邻算法中k的选取以及特征归一化的重要性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E5%8F%96k%E5%80%BC%E4%BB%A5%E5%8F%8A%E5%AE%83%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-number">1.6.1.2.1.</span> <span class="toc-text">选取k值以及它的影响</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%B7%9D%E7%A6%BB%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="toc-number">1.6.1.2.2.</span> <span class="toc-text">距离的度量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E5%BD%92%E4%B8%80%E5%8C%96%E7%9A%84%E5%BF%85%E8%A6%81%E6%80%A7"><span class="toc-number">1.6.1.2.3.</span> <span class="toc-text">特征归一化的必要性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%B3%E7%AD%96%E6%A0%91"><span class="toc-number">1.6.2.</span> <span class="toc-text">决策树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SVM"><span class="toc-number">1.6.3.</span> <span class="toc-text">SVM</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E8%8C%83%E5%BC%8F"><span class="toc-number">1.6.4.</span> <span class="toc-text">学习范式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">集成学习</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Bagging"><span class="toc-number">1.6.4.1.1.</span> <span class="toc-text">Bagging</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Boosting"><span class="toc-number">1.6.4.1.2.</span> <span class="toc-text">Boosting</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#Bagging-%E5%92%8C-Boosting-%E7%9A%844-%E7%82%B9%E5%B7%AE%E5%88%AB"><span class="toc-number">1.6.4.1.3.</span> <span class="toc-text">Bagging 和 Boosting 的4 点差别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">深度学习</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%98%AF%E4%B8%80%E4%B8%AA%E6%95%B0%E5%AD%A6%E9%97%AE%E9%A2%98"><span class="toc-number">1.6.4.2.1.</span> <span class="toc-text">深度学习是一个数学问题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0"><span class="toc-number">1.6.4.3.</span> <span class="toc-text">半监督学习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83"><span class="toc-number">1.7.</span> <span class="toc-text">参考</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/23/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E6%8E%92%E6%9F%A5/" title="记一次博客公式渲染排查"><img src="/img/cover3/13-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="记一次博客公式渲染排查"/></a><div class="content"><a class="title" href="/2023/06/23/%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%8D%9A%E5%AE%A2%E5%85%AC%E5%BC%8F%E6%B8%B2%E6%9F%93%E6%8E%92%E6%9F%A5/" title="记一次博客公式渲染排查">记一次博客公式渲染排查</a><time datetime="2023-06-23T01:21:51.000Z" title="发表于 2023-06-23 09:21:51">2023-06-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/19/A-star%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/" title="A-star路径规划"><img src="/img/cover2/21-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="A-star路径规划"/></a><div class="content"><a class="title" href="/2023/06/19/A-star%E8%B7%AF%E5%BE%84%E8%A7%84%E5%88%92/" title="A-star路径规划">A-star路径规划</a><time datetime="2023-06-19T13:17:15.000Z" title="发表于 2023-06-19 21:17:15">2023-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/17/PID%E7%AE%97%E6%B3%95/" title="PID算法"><img src="/img/cover3/29.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="PID算法"/></a><div class="content"><a class="title" href="/2023/06/17/PID%E7%AE%97%E6%B3%95/" title="PID算法">PID算法</a><time datetime="2023-06-17T12:06:22.000Z" title="发表于 2023-06-17 20:06:22">2023-06-17</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/06/05/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/" title="服务开发"><img src="/img/cover3/21-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="服务开发"/></a><div class="content"><a class="title" href="/2023/06/05/%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91/" title="服务开发">服务开发</a><time datetime="2023-06-05T05:06:30.000Z" title="发表于 2023-06-05 13:06:30">2023-06-05</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/05/17/SDU%E9%80%89%E8%AF%BE%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95/" title="SDU选课黑白名单"><img src="/img/cover3/23-min.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="SDU选课黑白名单"/></a><div class="content"><a class="title" href="/2023/05/17/SDU%E9%80%89%E8%AF%BE%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95/" title="SDU选课黑白名单">SDU选课黑白名单</a><time datetime="2023-05-17T14:39:33.000Z" title="发表于 2023-05-17 22:39:33">2023-05-17</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div><div class="js-pjax" id="rightMenu"><div class="rightMenu-group rightMenu-small"><a class="rightMenu-item" href="javascript:window.history.back();" rel="external nofollow noreferrer"><i class="fa fa-arrow-left"></i></a><a class="rightMenu-item" href="javascript:window.history.forward();" rel="external nofollow noreferrer"><i class="fa fa-arrow-right"></i></a><a class="rightMenu-item" href="javascript:window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-refresh"></i></a><a class="rightMenu-item" href="javascript:rmf.scrollToTop();" rel="external nofollow noreferrer"><i class="fa fa-arrow-up"></i></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-text"><a class="rightMenu-item" href="javascript:rmf.copySelect();" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制</span></a><a class="rightMenu-item" href="javascript:window.open(&quot;https://www.google.com/search?q=&quot;+window.getSelection().toString());" rel="external nofollow noreferrer"><i class="iconfont icon-baidu"></i><span>搜索</span></a><a class="rightMenu-item" href="javascript:rmf.searchinThisPage();" rel="external nofollow noreferrer"><i class="fas fa-search"></i><span>站内搜索</span></a><a class="rightMenu-item" href="#post-comment" onclick="rmf.yinyong()"><i class="fa-solid fa-message"></i><span>引用文本评论</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-too"><a class="rightMenu-item" href="javascript:window.open(window.getSelection().toString());window.location.reload();" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-paste"><a class="rightMenu-item" href="javascript:rmf.paste()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>粘贴</span></a></div><!--.rightMenu-group.rightMenu-line.hide#menu-post//a.rightMenu-item(href="#post-comment")
//    i.fas.fa-comment
//    span='空降评论'
//a.rightMenu-item(href="javascript:switchCommentBarrage()")
//    i.iconfont.icon-danmu
//    span='开/关评论弹幕'
//a.rightMenu-item(href="javascript:rmf.copyWordsLink()")
//    i.fa.fa-link
//    span='复制本文地址'--><div class="rightMenu-group rightMenu-line hide" id="menu-to"><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>新窗口打开</span></a><a class="rightMenu-item" id="menu-too" href="javascript:rmf.open()" rel="external nofollow noreferrer"><i class="fa fa-link"></i><span>转到链接</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制链接</span></a></div><div class="rightMenu-group rightMenu-line hide" id="menu-img"><a class="rightMenu-item" href="javascript:rmf.saveAs()" rel="external nofollow noreferrer"><i class="fa fa-download"></i><span>保存图片</span></a><a class="rightMenu-item" href="javascript:rmf.openWithNewTab()" rel="external nofollow noreferrer"><i class="fa fa-window-restore"></i><span>在新窗口打开</span></a><a class="rightMenu-item" href="javascript:rmf.click()" rel="external nofollow noreferrer"><i class="fa fa-arrows-alt"></i><span>全屏显示</span></a><a class="rightMenu-item" href="javascript:rmf.copyLink()" rel="external nofollow noreferrer"><i class="fa fa-copy"></i><span>复制图片链接</span></a></div><div class="rightMenu-group rightMenu-line"><!--a.rightMenu-item(href="javascript:toRandomPost()")--><!--    i.fa.fa-paper-plane--><!--    span='随便逛逛'--><a class="rightMenu-item" href="javascript:rmf.switchDarkMode();" rel="external nofollow noreferrer"><i class="fa fa-moon"></i><span>昼夜切换</span></a><a class="rightMenu-item" href="javascript:rmf.translate();" rel="external nofollow noreferrer"><i class="iconfont icon-fanti"></i><span>繁简转换</span></a><a class="rightMenu-item" href="javascript:rmf.switchReadMode();" rel="external nofollow noreferrer"><i class="fa fa-book"></i><span>阅读模式</span></a><!--a.rightMenu-item(href="javascript:pjax.loadUrl(\"/license/\");")--><!--    i.fa.fa-info-circle--><!--    span='版权声明'--><!--a.rightMenu-item(href="javascript:toggleWinbox();")--><!--    i.fas.fa-cog--><!--    span='博客设置'--><a class="rightMenu-item" href="javascript:fullScreen();" rel="external nofollow noreferrer"><i class="fas fa-expand"></i><span>进入全屏</span></a></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function getGiscusTheme (theme) {
  return theme === 'dark' ? 'dark' : 'light'
}

function loadGiscus () {
  const config = Object.assign({
    src: 'https://giscus.app/client.js',
    'data-repo': 'ZWN2001/ZWN2001.github.io',
    'data-repo-id': 'R_kgDOGH1XWg',
    'data-category-id': 'DIC_kwDOGH1XWs4CXnHJ',
    'data-mapping': 'pathname',
    'data-theme': getGiscusTheme(document.documentElement.getAttribute('data-theme')),
    'data-reactions-enabled': '1',
    crossorigin: 'anonymous',
    async: true
  },{"data-lang":"zh-CN","data-loading":"lazy","crossorigin":"anonymous","data-mapping":"og:title","data-input-position":"top","data-category":"Announcements"})

  let ele = document.createElement('script')
  for (let key in config) {
    ele.setAttribute(key, config[key])
  }
  document.getElementById('giscus-wrap').insertAdjacentElement('afterbegin',ele)
}

function changeGiscusTheme (theme) {
  function sendMessage(message) {
    const iframe = document.querySelector('iframe.giscus-frame')
    if (!iframe) return
    iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app')
  }

  sendMessage({
    setConfig: {
      theme: getGiscusTheme(theme)
    }
  });
}

btf.addModeChange('giscus', changeGiscusTheme)

if ('Giscus' === 'Giscus' || !true) {
  if (true) btf.loadComment(document.getElementById('giscus-wrap'), loadGiscus)
  else loadGiscus()
} else {
  function loadOtherComment () {
    loadGiscus()
  }
}</script></div><script type="text/javascript" src="https://cdn1.tianli0.top/npm/jquery@latest/dist/jquery.min.js"></script><script type="text/javascript" src="/js/rightmenu.js"></script><script type="text/javascript" src="/js/memos/waterfall.min.js"></script><script type="text/javascript" src="/js/memos/project.js"></script><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div class="no-result" id="local-search-results"></div><div id="local-search-stats-wrap"></div></div></div><div id="search-mask"></div><script src="/js/search/local-search.js"></script></div></div><!-- hexo injector body_end start -->
  <script data-pjax src="https://cdn.jsdelivr.net/gh/Zfour/hexo-github-calendar@1.21/hexo_githubcalendar.js"></script>
  <script data-pjax>
        function GithubCalendarConfig(){
            var git_githubapiurl ="https://my-hexo-github-calender.vercel.app/api/?ZWN2001";
            var git_color =['#ebedf0', '#f1f8ff', '#dbedff', '#c8e1ff', '#79b8ff', '#2188ff', '#0366d6', '#005cc5', '#044289', '#032f62', '#05264c'];
            var git_user ="ZWN2001";
            var parent_div_git = document.getElementById('recent-posts');
            var git_div_html = '<div class="recent-post-item" style="width:100%;height:auto;padding:10px;"><div id="github_loading" style="width:10%;height:100%;margin:0 auto;display: block"><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink"  viewBox="0 0 50 50" style="enable-background:new 0 0 50 50" xml:space="preserve"><path fill="#d0d0d0" d="M25.251,6.461c-10.318,0-18.683,8.365-18.683,18.683h4.068c0-8.071,6.543-14.615,14.615-14.615V6.461z" transform="rotate(275.098 25 25)"><animateTransform attributeType="xml" attributeName="transform" type="rotate" from="0 25 25" to="360 25 25" dur="0.6s" repeatCount="indefinite"></animateTransform></path></svg></div><div id="github_container"></div></div>';
            if(parent_div_git && location.pathname =='/'){
                console.log('已挂载github calendar')
                // parent_div_git.innerHTML=git_div_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",git_div_html) // 有报错，但不影响使用(支持pjax跳转)
            };
            GithubCalendar(git_githubapiurl,git_color,git_user)
        }
        if(document.getElementById('recent-posts')){
            GithubCalendarConfig()
        }
    </script>
    <style>#github_container{min-height:280px}@media screen and (max-width:650px) {#github_container{background-image:;min-height:0px}}</style>
    <style></style> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/编程知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📚 洛雪の编程知识 (16)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/实用知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 洛雪の实用知识 (14)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/学习-课外拓展/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">👩‍💻 洛雪の学习-课外拓展 (19)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="https://zwn2001.space/categories/学习-课内知识/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 洛雪の学习-课内知识 (57)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><a class="magnet_link_more"  href="https://zwn2001.space/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><!-- hexo injector body_end end --></body></html>